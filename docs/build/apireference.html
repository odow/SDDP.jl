<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · SDDP.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><link href="assets/custom.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SDDP.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Manual</a></li><li><a class="toctext" href="readings.html">Readings</a></li><li class="current"><a class="toctext" href="apireference.html">Reference</a><ul class="internal"><li><a class="toctext" href="#Communicating-the-problem-to-the-solver-1">Communicating the problem to the solver</a></li><li><a class="toctext" href="#Solving-the-problem-efficiently-1">Solving the problem efficiently</a></li><li><a class="toctext" href="#Understanding-the-solution-1">Understanding the solution</a></li><li><a class="toctext" href="#Read-and-write-the-model-to-disk-1">Read and write the model to disk</a></li><li><a class="toctext" href="#Extras-for-Experts-1">Extras for Experts</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="apireference.html">Reference</a></li></ul><a class="edit-page" href="https://github.com/odow/SDDP.jl/blob/master/docs\\src\\apireference.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Reference</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-Reference-1" href="#API-Reference-1">API Reference</a></h1><h2><a class="nav-anchor" id="Communicating-the-problem-to-the-solver-1" href="#Communicating-the-problem-to-the-solver-1">Communicating the problem to the solver</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.SDDPModel" href="#SDDP.SDDPModel"><code>SDDP.SDDPModel</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SDDPModel(;kwargs...) do ...

end</code></pre><p><strong>Description</strong></p><p>This function constructs an SDDPModel. <code>SDDPModel</code> takes the following keyword arguments. Some are required, and some are optional.</p><p><strong>Required Keyword arguments</strong></p><ul><li><p><code>stages::Int</code></p></li></ul><p>The number of stages in the problem. A stage is defined as each step in time at  which a decion can be made. Defaults to <code>1</code>.</p><ul><li><p><code>objective_bound</code></p></li></ul><p>A valid bound on the initial value/cost to go. i.e. for maximisation this may  be some large positive number, for minimisation this may be some large negative  number. Users can pass either a single value (which bounds the cost-to-go in all  stages), or a vector of values (one for each stage), or a vector (one element  for each stage) of vectors of values (one value for each markov state in the stage).</p><ul><li><p><code>solver::MathProgBase.AbstractMathProgSolver</code></p></li></ul><p>MathProgBase compliant solver that returns duals from a linear program. If this  isn&#39;t specified then you must use <code>JuMP.setsolver(sp, solver)</code> in the stage  definition.</p><p><strong>Optional Keyword arguments</strong></p><ul><li><p><code>sense</code></p></li></ul><p>Must be either <code>:Max</code> or <code>:Min</code>. Defaults to <code>:Min</code>.</p><ul><li><p><code>cut_oracle::SDDP.AbstractCutOracle</code></p></li></ul><p>The cut oracle is responsible for collecting and storing the cuts that define  a value function. The cut oracle may decide that only a subset of the total  discovered cuts are relevant, which improves solution speed by reducing the  size of the subproblems that need solving. Currently must be one of     * <code>DefaultCutOracle()</code> (see <code>DefaultCutOracle</code> for explanation)     * <code>LevelOneCutOracle()</code>(see <code>LevelOneCutOracle</code> for explanation)</p><ul><li><p><code>risk_measure</code></p></li></ul><p>If a single risk measure is given (i.e. <code>risk_measure = Expectation()</code>), then  this measure will be applied to every stage in the problem. Another option is  to provide a vector of risk measures. There must be one element for every  stage. For example:</p><pre><code class="language-none">risk_measure = [ NestedAVaR(lambda=0.5, beta=0.25), Expectation() ]</code></pre><p>will apply the <code>i</code>&#39;th element of <code>risk_measure</code> to every Markov state in the <code>i</code>&#39;th stage. The last option is to provide a vector (one element for each stage) of vectors of risk measures (one for each Markov state in the stage). For example:</p><pre><code class="language-none">risk_measure = [
# Stage 1 Markov 1 # Stage 1 Markov 2 #
    [ Expectation(), Expectation() ],
    # ------- Stage 2 Markov 1 ------- ## ------- Stage 2 Markov 2 ------- #
    [ NestedAVaR(lambda=0.5, beta=0.25), NestedAVaR(lambda=0.25, beta=0.3) ]
    ]</code></pre><p>Note that even though the last stage does not have a future cost function associated with it (as it has no children), we still have to specify a risk measure. This is necessary to simplify the implementation of the algorithm.</p><p>For more help see <code>NestedAVaR</code> or <code>Expectation</code>.</p><ul><li><p><code>markov_transition</code></p></li></ul><p>Define the transition probabilties of the stage graph. If a single array is given, it is assumed that there is an equal number of Markov states in each stage and the transition probabilities are stage invariant. Row indices represent the Markov state in the previous stage. Column indices represent the Markov state in the current stage. Therefore:</p><pre><code class="language-none">markov_transition = [0.1 0.9; 0.8 0.2]</code></pre><p>is the transition matrix when there is 10% chance of transitioning from Markov state 1 to Markov state 1, a 90% chance of transitioning from Markov state 1 to Markov state 2, an 80% chance of transitioning from Markov state 2 to Markov state 1, and a 20% chance of transitioning from Markov state 2 to Markov state 2.</p><p><strong>Returns</strong></p><ul><li><p><code>m</code>: the <code>SDDPModel</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/odow/SDDP.jl/blob/0087cb973c9c88e82070ca95549b331aa13d0fac/src\\SDDP.jl#L55-L138">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.Expectation" href="#SDDP.Expectation"><code>SDDP.Expectation</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Expectation()</code></pre><p><strong>Description</strong></p><p>The expectation risk measure.</p></div><a class="source-link" target="_blank" href="https://github.com/odow/SDDP.jl/blob/0087cb973c9c88e82070ca95549b331aa13d0fac/src\\riskmeasures.jl#L51-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.NestedAVaR" href="#SDDP.NestedAVaR"><code>SDDP.NestedAVaR</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">NestedAVaR(;lambda=1.0, beta=1.0)</code></pre><p><strong>Description</strong></p><p>A risk measure that is a convex combination of Expectation and Average Value @ Risk (also called Conditional Value @ Risk).</p><pre><code class="language-none">λ * E[x] + (1 - λ) * AV@R(1-β)[x]</code></pre><p><strong>Keyword Arguments</strong></p><ul><li><p><code>lambda</code></p></li></ul><p>Convex weight on the expectation (<code>(1-lambda)</code> weight is put on the AV@R component. Inreasing values of <code>lambda</code> are less risk averse (more weight on expecattion)</p><ul><li><p><code>beta</code></p></li></ul><p>The quantile at which to calculate the Average Value @ Risk. Increasing values  of <code>beta</code> are less risk averse. If <code>beta=0</code>, then the AV@R component is the  worst case risk measure.</p><p><strong>Returns</strong></p><pre><code class="language-none">m::NestedAVaR&lt;:AbstractRiskMeasure</code></pre></div><a class="source-link" target="_blank" href="https://github.com/odow/SDDP.jl/blob/0087cb973c9c88e82070ca95549b331aa13d0fac/src\\avar_riskaversion.jl#L23-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.DefaultCutOracle" href="#SDDP.DefaultCutOracle"><code>SDDP.DefaultCutOracle</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">DefaultCutOracle()</code></pre><p><strong>Description</strong></p><p>Initialize the default cut oracle.</p><p>This oracle keeps every cut discovered and does not perform cut selection.</p></div><a class="source-link" target="_blank" href="https://github.com/odow/SDDP.jl/blob/0087cb973c9c88e82070ca95549b331aa13d0fac/src\\cutoracles.jl#L27-L35">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.LevelOneCutOracle" href="#SDDP.LevelOneCutOracle"><code>SDDP.LevelOneCutOracle</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">LevelOneCutOracle()</code></pre><p><strong>Description</strong></p><p>Initialize the cut oracle for Level One cut selection. See:</p><p>V. de Matos,A. Philpott, E. Finardi, Improving the performance of Stochastic Dual Dynamic Programming, Journal of Computational and Applied Mathematics 290 (2015) 196–208.</p></div><a class="source-link" target="_blank" href="https://github.com/odow/SDDP.jl/blob/0087cb973c9c88e82070ca95549b331aa13d0fac/src\\dematos_cutoracle.jl#L16-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.@state" href="#SDDP.@state"><code>SDDP.@state</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@state(sp, stateleaving, stateentering)</code></pre><p><strong>Description</strong></p><p>Define a new state variable in the subproblem <code>sp</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>sp</code>               the subproblem</p></li><li><p><code>stateleaving</code>     any valid JuMP <code>@variable</code> syntax to define the value of the state variable at the end of the stage</p></li><li><p><code>stateentering</code>    any valid JuMP <code>@variable</code> syntax to define the value of the state variable at the beginning of the stage</p></li></ul><p><strong>Examples</strong></p><ul><li><p><code>@state(sp, 0 &lt;= x[i=1:3] &lt;= 1, x0==rand(3)[i] )</code></p></li><li><p><code>@state(sp,      y        &lt;= 1, y0==0.5        )</code></p></li><li><p><code>@state(sp,      z            , z0==0.5        )</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/odow/SDDP.jl/blob/0087cb973c9c88e82070ca95549b331aa13d0fac/src\\states.jl#L76-L93">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.@states" href="#SDDP.@states"><code>SDDP.@states</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@states(sp, begin
    stateleaving1, stateentering1
    stateleaving2, stateentering2
end)</code></pre><p><strong>Description</strong></p><p>Define a new state variables in the subproblem <code>sp</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>sp</code>               the subproblem</p></li><li><p><code>stateleaving</code>     any valid JuMP <code>@variable</code> syntax to define the value of the state variable at the end of the stage</p></li><li><p><code>stateentering</code>    any valid JuMP <code>@variable</code> syntax to define the value of the state variable at the beginning of the stage</p></li></ul><p><strong>Usage</strong></p><pre><code class="language-none">@states(sp, begin
    0 &lt;= x[i=1:3] &lt;= 1, x0==rand(3)[i]
         y        &lt;= 1, y0==0.5
         z            , z0==0.5
 end)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/odow/SDDP.jl/blob/0087cb973c9c88e82070ca95549b331aa13d0fac/src\\states.jl#L123-L146">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.@rhsnoise" href="#SDDP.@rhsnoise"><code>SDDP.@rhsnoise</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@rhsnoise(sp, rhs, constraint)</code></pre><p><strong>Description</strong></p><p>Add a constraint with a noise in the RHS vector to the subproblem <code>sp</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>sp</code>         the subproblem</p></li><li><p><code>rhs</code>        keyword argument <code>key=value</code> where <code>value</code> is a one-dimensional array containing the noise realisations</p></li><li><p><code>constraint</code> any valid JuMP <code>@constraint</code> syntax that includes the keyword defined by <code>rhs</code></p></li></ul><p><strong>Examples</strong></p><ul><li><p><code>@rhsnoise(sp, i=1:2, x + y &lt;= i )</code></p></li><li><p><code>@rhsnoise(sp, i=1:2, x + y &lt;= 3 * rand(2)[i] )</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/odow/SDDP.jl/blob/0087cb973c9c88e82070ca95549b331aa13d0fac/src\\noises.jl#L56-L71">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.@rhsnoises" href="#SDDP.@rhsnoises"><code>SDDP.@rhsnoises</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@rhsnoises(sp, rhs, begin
    constraint
end)</code></pre><p><strong>Description</strong></p><p>The plural form of <code>@rhsnoise</code> similar to the JuMP macro <code>@constraints</code>.</p><p><strong>Arguments</strong></p><p>See <code>@rhsnoise</code>.</p><p><strong>Examples</strong></p><pre><code class="language-none">@rhsnoises(sp, i=1:2, begin
    x + y &lt;= i
    x + y &lt;= 3 * rand(2)[i]
end)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/odow/SDDP.jl/blob/0087cb973c9c88e82070ca95549b331aa13d0fac/src\\noises.jl#L124-L142">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.setnoiseprobability!" href="#SDDP.setnoiseprobability!"><code>SDDP.setnoiseprobability!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">setnoiseprobability!(sp::JuMP.Model, distribution::Vector{Float64})</code></pre><p><strong>Description</strong></p><p>Set the probability distribution of the stagewise independent noise in the <code>sp</code> subproblem.</p><p><strong>Arguments</strong></p><ul><li><p><code>sp</code>            the subproblem</p></li><li><p><code>distribution</code> vector containing the probability of each outcome occuring.   Should sum to <code>1</code>. Defaults to the uniform distribution.</p></li></ul><p><strong>Examples</strong></p><p>If there are two realizations:</p><ul><li><p><code>setnoiseprobability!(sp, [0.3, 0.7])</code></p></li><li><p><code>setnoiseprobability!(sp, [0.5, 0.6])</code> will error!</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/odow/SDDP.jl/blob/0087cb973c9c88e82070ca95549b331aa13d0fac/src\\noises.jl#L30-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.@stageobjective" href="#SDDP.@stageobjective"><code>SDDP.@stageobjective</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@stageobjective(sp, kw=noises, objective)</code></pre><p><strong>Description</strong></p><p>Define an objective that depends on the realization of the stagewise noise. <code>objective</code> can be any valid third argument to the JuMP <code>@objective</code> macro (i.e. <code>@objective(sp, Min, objective)</code>) that utilises the variable <code>kw</code> that takes the realizations defined in <code>noises</code>.</p><p><strong>Examples</strong></p><pre><code class="language-none">@stageobjective(sp, w=1:2, w * x)
@stageobjective(sp, i=1:2, w[i]^2 * x)
@stageobjective(sp, i=1:2, x[i])</code></pre></div><a class="source-link" target="_blank" href="https://github.com/odow/SDDP.jl/blob/0087cb973c9c88e82070ca95549b331aa13d0fac/src\\noises.jl#L161-L177">source</a><div><pre><code class="language-none">@stageobjective(sp, objective)</code></pre><p><strong>Description</strong></p><p>Define a deterministic objective.</p><p><strong>Examples</strong></p><pre><code class="language-none">@stageobjective(sp, x + y)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/odow/SDDP.jl/blob/0087cb973c9c88e82070ca95549b331aa13d0fac/src\\noises.jl#L190-L201">source</a></section><h2><a class="nav-anchor" id="Solving-the-problem-efficiently-1" href="#Solving-the-problem-efficiently-1">Solving the problem efficiently</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.solve" href="#JuMP.solve"><code>JuMP.solve</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">solve(m::SDDPModel; kwargs...)</code></pre><p><strong>Description</strong></p><p>Solve the SDDPModel <code>m</code> using SDDP. Accepts a number of keyword arguments to control the solution process.</p><p><strong>Positional arguments</strong></p><ul><li><p><code>m</code>: the SDDPModel to solve</p></li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>max_iterations::Int</code>:  The maximum number of cuts to add to a single stage problem before terminating.  Defaults to <code>10</code>.</p></li><li><p><code>time_limit::Real</code>:  The maximum number of seconds (in real time) to compute for before termination.  Defaults to <code>Inf</code>.</p></li><li><p><code>simulation::MonteCarloSimulation</code>: see <code>MonteCarloSimulation</code></p></li><li><p><code>bound_convergence::BoundConvergence</code>: see <code>BoundConvergence</code></p></li><li><p><code>cut_selection_frequency::Int</code>:  Frequency (by iteration) with which to rebuild subproblems using a subset of  cuts. Frequent cut selection (i.e. <code>cut_selection_frequency</code> is small) reduces  the size of the subproblems that are solved, but incurrs the overhead of rebuilding  the subproblems. However, infrequent cut selection (i.e.  <code>cut_selection_frequency</code> is large) allows the subproblems to grow large (many  constraints) leading to an increase in the solve time of individual subproblems.  Defaults to <code>0</code> (never run).</p></li><li><p><code>print_level::Int</code>:   0 - off: nothing logged.   1 - on: solve iterations logged.   2 - verbose: detailed timing information is also logged.   Defaults to <code>1</code></p></li><li><p><code>log_file::String</code>:  Relative filename to write the log to disk. Defaults to <code>&quot;&quot;</code> (no log written)</p></li><li><p><code>solve_type</code>:  One of</p><ul><li><p><code>Asyncronous()</code> - solve using a parallelised algorithm</p></li><li><p><code>Serial()</code> - solve using a serial algorithm</p></li></ul><p>Default chooses automatically based on the number of available processors.</p></li><li><p><code>reduce_memory_footprint::Bool</code>:  Implements the idea proposed in https://github.com/JuliaOpt/JuMP.jl/issues/969#issuecomment-282191105  to reduce the memory consumption when running SDDP. This is an issue if you  wish to save the model <code>m</code> to disk since it discards important information.  Defaults to <code>false</code>.</p></li><li><p><code>cut_output_file::String</code>:  Relative filename to write discovered cuts to disk. Defaults to <code>&quot;&quot;</code> (no cuts written)</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>status::Symbol</code>:  Reason for termination. One of</p><ul><li><p><code>:solving</code></p></li><li><p><code>:interrupted</code></p></li><li><p><code>:converged</code></p></li><li><p><code>:max_iterations</code></p></li><li><p><code>:bound_convergence</code></p></li><li><p><code>:time_limit</code></p></li></ul></li></ul></div><a class="source-link" target="_blank" href="https://github.com/odow/SDDP.jl/blob/0087cb973c9c88e82070ca95549b331aa13d0fac/src\\SDDP.jl#L390-L448">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.MonteCarloSimulation" href="#SDDP.MonteCarloSimulation"><code>SDDP.MonteCarloSimulation</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">MonteCarloSimulation(;kwargs...)</code></pre><p><strong>Description</strong></p><p>Collection of settings to control the simulation phase of the SDDP solution process.</p><p><strong>Arguments</strong></p><ul><li><p><code>frequency::Int</code></p></li></ul><p>The frequency (by iteration) with which to run the policy simulation phase of the algorithm in order to construct a statistical bound for the policy. Defaults to <code>0</code> (never run).</p><ul><li><p><code>min::Float64</code></p></li></ul><p>Minimum number of simulations to conduct before constructing a confidence interval for the bound. Defaults to <code>20</code>.</p><ul><li><p><code>step::Float64</code></p></li></ul><p>Number of additional simulations to conduct before constructing a new confidence interval for the bound. Defaults to <code>1</code>.</p><ul><li><p><code>max::Float64</code></p></li></ul><p>Maximum number of simulations to conduct in the policy simulation phase. Defaults to <code>min</code>.</p><ul><li><p><code>confidence::Float64</code></p></li></ul><p>Confidence level of the confidence interval. Defaults to <code>0.95</code> (95% CI).</p><ul><li><p><code>termination::Bool</code></p></li></ul><p>Whether to terminate the solution algorithm with the status <code>:converged</code> if the deterministic bound is with in the statistical bound after <code>max</code> simulations. Defaults to <code>false</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/odow/SDDP.jl/blob/0087cb973c9c88e82070ca95549b331aa13d0fac/src\\typedefinitions.jl#L203-L231">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.BoundConvergence" href="#SDDP.BoundConvergence"><code>SDDP.BoundConvergence</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">BoundConvergence(;kwargs...)</code></pre><p><strong>Description</strong></p><p>Collection of settings to control the bound stalling convergence test.</p><p><strong>Arguments</strong></p><ul><li><p><code>iterations::Int</code></p></li></ul><p>Terminate if the maximum deviation in the deterministic bound from the mean over the last <code>iterations</code> number of iterations is less than <code>rtol</code> (in relative terms) or <code>atol</code> (in absolute terms).</p><ul><li><p><code>rtol::Float64</code></p></li></ul><p>Maximum allowed relative deviation from the mean. Defaults to <code>0.0</code></p><ul><li><p><code>atol::Float64</code></p></li></ul><p>Maximum allowed absolute deviation from the mean. Defaults to <code>0.0</code></p></div><a class="source-link" target="_blank" href="https://github.com/odow/SDDP.jl/blob/0087cb973c9c88e82070ca95549b331aa13d0fac/src\\typedefinitions.jl#L176-L194">source</a></section><h2><a class="nav-anchor" id="Understanding-the-solution-1" href="#Understanding-the-solution-1">Understanding the solution</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.simulate" href="#SDDP.simulate"><code>SDDP.simulate</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">simulate(m::SDDPPModel,variables::Vector{Symbol};
    noises::Vector{Int}, markovstates::Vector{Int})</code></pre><p><strong>Description</strong></p><p>Perform a historical simulation of the current policy in model  <code>m</code>.</p><p><code>noises</code> is a vector with one element for each stage giving the index of the (in-sample) stagewise independent noise to sample in each stage. <code>markovstates</code> is a vector with one element for each stage giving the index of the (in-sample) markov state to sample in each stage.</p><p><strong>Examples</strong></p><pre><code class="language-none">simulate(m, [:x, :u], noises=[1,2,2], markovstates=[1,1,2])</code></pre></div><a class="source-link" target="_blank" href="https://github.com/odow/SDDP.jl/blob/0087cb973c9c88e82070ca95549b331aa13d0fac/src\\simulate.jl#L60-L76">source</a><div><pre><code class="language-none">results = simulate(m::SDDPPModel, N::Int, variables::Vector{Symbol})</code></pre><p><strong>Description</strong></p><p>Perform <code>N</code> Monte-Carlo simulations of the current policy in model <code>m</code> saving the values of the variables named in <code>variables</code> at every stage.</p><p><code>results</code> is a vector containing a dictionary for each simulation. In addition to the variables specified in the function call, other special keys are:</p><ul><li><p><code>:stageobjective</code> - costs incurred during the stage (not future)</p></li><li><p><code>:obj</code>            - objective of the stage including future cost</p></li><li><p><code>:markov</code>         - index of markov state visited</p></li><li><p><code>:noise</code>          - index of noise visited</p></li><li><p><code>:objective</code>      - Total objective of simulation</p></li></ul><p>All values can be accessed as follows</p><pre><code class="language-none">results[simulation index][key][stage]</code></pre><p>with the exception of <code>:objective</code> which is just</p><pre><code class="language-none">results[simulation index][:objective]</code></pre><p><strong>Examples</strong></p><pre><code class="language-none">results = simulate(m, 10, [:x, :u])
results[1][:objective] # objective of simulation 1
mean(r[:objective] for r in results) # mean objective of the simulations
results[2][:x][3] # value of :x in stage 3 in second simulation</code></pre></div><a class="source-link" target="_blank" href="https://github.com/odow/SDDP.jl/blob/0087cb973c9c88e82070ca95549b331aa13d0fac/src\\simulate.jl#L92-L123">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.getbound" href="#SDDP.getbound"><code>SDDP.getbound</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getbound(m)</code></pre><p><strong>Description</strong></p><p>Get the lower (if minimizing), or upper (if maximizing) bound of the solved SDDP model <code>m</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/odow/SDDP.jl/blob/0087cb973c9c88e82070ca95549b331aa13d0fac/src\\utilities.jl#L15-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.newplot" href="#SDDP.newplot"><code>SDDP.newplot</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">SDDP.newplot()</code></pre><p><strong>Description</strong></p><p>Initialize a new <code>SimulationPlot</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/odow/SDDP.jl/blob/0087cb973c9c88e82070ca95549b331aa13d0fac/src\\visualizer\\visualize_simulation.jl#L22-L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.addplot!" href="#SDDP.addplot!"><code>SDDP.addplot!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">SDDP.addplot!(p::SimulationPlot, ivals::AbstractVector{Int}, tvals::AbstractVector{Int}, f::Function; kwargs...)</code></pre><p><strong>Description</strong></p><p>Add a new figure to the SimulationPlot <code>p</code>, where the y-value is given by <code>f(i, t)</code> for all <code>i</code> in <code>ivals</code> (one for each series) and <code>t</code> in <code>tvals</code> (one for each stage).</p><p><strong>Keywords</strong></p><ul><li><p><code>xlabel</code>: set the xaxis label;</p></li><li><p><code>ylabel</code>: set the yaxis label;</p></li><li><p><code>title</code>: set the title of the plot;</p></li><li><p><code>ymin</code>: set the minimum y value;</p></li><li><p><code>ymax</code>: set the maximum y value;</p></li><li><p><code>cumulative</code>: plot the additive accumulation of the value across the stages;</p></li><li><p><code>interpolate</code>: interpolation method for lines between stages. Defaults to <code>&quot;linear&quot;</code>  see <a href="https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#line_interpolate">the d3 docs</a></p></li></ul><pre><code class="language-none">for all options.</code></pre><p><strong>Examples</strong></p><pre><code class="language-none">results = simulate(m, 10)
p = SDDP.newplot()
SDDP.addplot!(p, 1:10, 1:3, (i,t)-&gt;results[i][:stageobjective][t])</code></pre></div><a class="source-link" target="_blank" href="https://github.com/odow/SDDP.jl/blob/0087cb973c9c88e82070ca95549b331aa13d0fac/src\\visualizer\\visualize_simulation.jl#L31-L55">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.show-Tuple{SDDP.SimulationPlot}" href="#Base.show-Tuple{SDDP.SimulationPlot}"><code>Base.show</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">show(p::SimulationPlot)</code></pre><p><strong>Description</strong></p><p>Launch a browser and render the SimulationPlot plot <code>p</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/odow/SDDP.jl/blob/0087cb973c9c88e82070ca95549b331aa13d0fac/src\\visualizer\\visualize_simulation.jl#L84-L90">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.plotvaluefunction" href="#SDDP.plotvaluefunction"><code>SDDP.plotvaluefunction</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none"> SDDP.plotvaluefunction(m::SDDPModel, stage::Int, markovstate::Int, states::Union{Float64, AbstractVector{Float64}}...; label1=&quot;State 1&quot;, label2=&quot;State 2&quot;)</code></pre><p><strong>Description</strong></p><p>Plot the value function of stage <code>stage</code> and Markov state <code>markovstate</code> in the SDDPModel <code>m</code> at the points in the discretized state space given by <code>states</code>. If the value in <code>states</code> is a real number, the state is evaluated at that point. If the value is a vector, the state is evaluated at all the points in the vector. At most two states can be vectors.</p><p><strong>Examples</strong></p><pre><code class="language-none">SDDP.plotvaluefunction(m, 2, 1, 0.0:0.1:1.0, 0.5, 0.0:0.1:1.0; label1=&quot;State 1&quot;, label2=&quot;State 3&quot;)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/odow/SDDP.jl/blob/0087cb973c9c88e82070ca95549b331aa13d0fac/src\\visualizer\\visualize_value_function.jl#L84-L98">source</a></section><h2><a class="nav-anchor" id="Read-and-write-the-model-to-disk-1" href="#Read-and-write-the-model-to-disk-1">Read and write the model to disk</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.loadcuts!" href="#SDDP.loadcuts!"><code>SDDP.loadcuts!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">loadcuts!(m::SDDPModel, filename::String)</code></pre><p>Load cuts from the file created using the <code>cut_output_file</code> argument in <code>solve</code>.</p><p><strong>Example</strong></p><pre><code class="language-none">m = SDDPModel() do ... end
status = solve(m; cut_output_file=&quot;path/to/m.cuts&quot;)`
m2 = SDDPModel() do ... end
loadcuts!(m2, &quot;path/to/m.cuts&quot;)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/odow/SDDP.jl/blob/0087cb973c9c88e82070ca95549b331aa13d0fac/src\\defaultvaluefunction.jl#L199-L212">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.savemodel!" href="#SDDP.savemodel!"><code>SDDP.savemodel!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">SDDP.savemodel!(filename::String, m::SDDPModel)</code></pre><p>Save the SDDPModel <code>m</code> to the location <code>filename</code>. Can be loaded at a later date with <code>m = SDDP.loadmodel(filename)</code>.</p><p>Note: this function relies in the internal Julia <code>Base.serialize</code>function. It should not be relied on to save an load models between versions of Julia (i.e between v0.5 and v0.6). For a longer-term solution, see <code>SDDP.loadcuts!</code> for help.</p></div><a class="source-link" target="_blank" href="https://github.com/odow/SDDP.jl/blob/0087cb973c9c88e82070ca95549b331aa13d0fac/src\\utilities.jl#L204-L213">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.loadmodel" href="#SDDP.loadmodel"><code>SDDP.loadmodel</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">loadmodel(filename::String)</code></pre><p>Load a model from the location <code>filename</code> that was saved using <code>SDDP.savemodel!</code>.</p><p>Note: this function relies in the internal Julia <code>Base.serialize</code>function. It should not be relied on to save an load models between versions of Julia (i.e between v0.5 and v0.6). For a longer-term solution, see <code>SDDP.loadcuts!</code> for help.</p></div><a class="source-link" target="_blank" href="https://github.com/odow/SDDP.jl/blob/0087cb973c9c88e82070ca95549b331aa13d0fac/src\\utilities.jl#L236-L244">source</a></section><h2><a class="nav-anchor" id="Extras-for-Experts-1" href="#Extras-for-Experts-1">Extras for Experts</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.AbstractCutOracle" href="#SDDP.AbstractCutOracle"><code>SDDP.AbstractCutOracle</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractCutOracle</code></pre><p><strong>Description</strong></p><p>Abstract type for all cut oracles.</p></div><a class="source-link" target="_blank" href="https://github.com/odow/SDDP.jl/blob/0087cb973c9c88e82070ca95549b331aa13d0fac/src\\typedefinitions.jl#L16-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.storecut!" href="#SDDP.storecut!"><code>SDDP.storecut!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">storecut!(oracle::AbstactCutOracle, m::SDDPModel, sp::JuMP.Model, cut::Cut)</code></pre><p><strong>Description</strong></p><p>Store the cut <code>cut</code> in the Cut Oracle <code>oracle</code>. <code>oracle</code> will belong to the subproblem <code>sp</code> in the SDDPModel <code>m</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/odow/SDDP.jl/blob/0087cb973c9c88e82070ca95549b331aa13d0fac/src\\cutoracles.jl#L7-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.validcuts" href="#SDDP.validcuts"><code>SDDP.validcuts</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">validcuts(oracle::AbstactCutOracle)</code></pre><p><strong>Description</strong></p><p>Return an iterable list of all the valid cuts contained within <code>oracle</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/odow/SDDP.jl/blob/0087cb973c9c88e82070ca95549b331aa13d0fac/src\\cutoracles.jl#L17-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.AbstractRiskMeasure" href="#SDDP.AbstractRiskMeasure"><code>SDDP.AbstractRiskMeasure</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractRiskMeasure</code></pre><p><strong>Description</strong></p><p>Abstract type for all risk measures.</p></div><a class="source-link" target="_blank" href="https://github.com/odow/SDDP.jl/blob/0087cb973c9c88e82070ca95549b331aa13d0fac/src\\typedefinitions.jl#L7-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.modifyprobability!" href="#SDDP.modifyprobability!"><code>SDDP.modifyprobability!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">modifyprobability!(measure::AbstractRiskMeasure,
        riskadjusted_distribution,
        original_distribution::Vector{Float64},
        observations::Vector{Float64},
        m::SDDPModel,
        sp::JuMP.Model
)</code></pre><p><strong>Description</strong></p><p>Calculate the risk-adjusted probability of each scenario using the &#39;change-of-probabilities&#39; approach of Philpott, de Matos, and Finardi,(2013). On solving multistage stochastic programs with coherent risk measures. Operations Research 61(4), 957-970.</p><p><strong>Arguments</strong></p><ul><li><p><code>measure::AbstractRiskMeasure</code></p></li></ul><p>The risk measure</p><ul><li><p><code>riskadjusted_distribution</code></p></li></ul><p>A new probability distribution</p><ul><li><p><code>original_distribution::Vector{Float64}</code></p></li></ul><p>The original probability distribution.</p><ul><li><p><code>observations::Vector{Float64}</code></p></li></ul><p>The vector of objective values from the next stage  problems (one for each scenario).</p><ul><li><p><code>m::SDDPModel</code></p></li></ul><p>The full SDDP model</p><ul><li><p><code>sp::JuMP.Model</code></p></li></ul><p>The stage problem that the cut will be added to.</p></div><a class="source-link" target="_blank" href="https://github.com/odow/SDDP.jl/blob/0087cb973c9c88e82070ca95549b331aa13d0fac/src\\riskmeasures.jl#L7-L37">source</a></section><footer><hr/><a class="previous" href="readings.html"><span class="direction">Previous</span><span class="title">Readings</span></a></footer></article></body></html>
