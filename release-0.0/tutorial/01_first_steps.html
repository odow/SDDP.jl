<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial One: first steps · SDDP.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SDDP.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Tutorials</span><ul><li class="current"><a class="toctext" href="01_first_steps.html">Tutorial One: first steps</a><ul class="internal"><li><a class="toctext" href="#Formulating-the-problem-1">Formulating the problem</a></li><li><a class="toctext" href="#Solving-the-problem-1">Solving the problem</a></li><li><a class="toctext" href="#Understanding-the-solution-1">Understanding the solution</a></li></ul></li><li><a class="toctext" href="02_rhs_noise.html">Tutorial Two: RHS noise</a></li><li><a class="toctext" href="03_objective_noise.html">Tutorial Three: objective noise</a></li><li><a class="toctext" href="04_markovian_policygraphs.html">Tutorial Four: Markovian policy graphs</a></li><li><a class="toctext" href="05_risk.html">Tutorial Five: risk</a></li><li><a class="toctext" href="06_cut_selection.html">Tutorial Six: cut selection</a></li><li><a class="toctext" href="07_plotting.html">Tutorial Seven: plotting</a></li><li><a class="toctext" href="08_odds_and_ends.html">Tutorial Eight: odds and ends</a></li><li><a class="toctext" href="09_nonlinear.html">Tutorial Nine: nonlinear models</a></li><li><a class="toctext" href="10_parallel.html">Tutorial Ten: parallelism</a></li><li><a class="toctext" href="11_DRO.html">Tutorial Eleven: distributionally robust SDDP</a></li><li><a class="toctext" href="12_price_interpolation.html">Tutorial Twelve: price interpolation</a></li><li><a class="toctext" href="13_constraint_noise.html">Tutorial Thirteen: constraint noise</a></li></ul></li><li><a class="toctext" href="../readings.html">Readings</a></li><li><a class="toctext" href="../apireference.html">Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li>Tutorials</li><li><a href="01_first_steps.html">Tutorial One: first steps</a></li></ul><a class="edit-page" href="https://github.com/odow/SDDP.jl/blob/master/docs/src/tutorial/01_first_steps.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tutorial One: first steps</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Tutorial-One:-first-steps-1" href="#Tutorial-One:-first-steps-1">Tutorial One: first steps</a></h1><p>Hydrothermal scheduling is the most common application of stochastic dual dynamic programming. To illustrate some of the basic functionality of SDDP.jl, we implement a very simple model of the hydrothermal scheduling problem.</p><p>In this model, there are two generators: a thermal generator, and a hydro generator. The thermal generator has a short-run marginal cost of \$50/MWh in the first stage, \$100/MWh in the second stage, and \$150/MWh in the third stage. The hydro generator has a short-run marginal cost of \$0/MWh.</p><p>We consider the problem of scheduling the generation over three time periods in order to meet a known demand of 150 MWh in each period.</p><p>The hydro generator draws water from a reservoir which has a maximum capacity of 200 units. We assume that at the start of the first time period, the reservoir is full. In addition to the ability to generate electricity by passing water through the hydroelectric turbine, the hydro generator can also spill water down a spillway (bypassing the turbine) in order to prevent the water from over-topping the dam. We assume that there is no cost of spillage.</p><p>The objective of the optimization is to minimize the expected cost of generation over the three time periods.</p><h2><a class="nav-anchor" id="Formulating-the-problem-1" href="#Formulating-the-problem-1">Formulating the problem</a></h2><p>First, we need to load some packages. For this example, we are going to use the <a href="https://github.com/JuliaOpt/Clp.jl">Clp.jl</a> package; however, you are free to use any solver that you could normally use with JuMP.</p><pre><code class="language-julia">using SDDP, JuMP, Clp</code></pre><p>Next, we need to initialize our model. In our example, we are minimizing, there are three stages, and we know a lower bound of <code>0.0</code>. Therefore, we can initialize our model using the <a href="../apireference.html#SDDP.SDDPModel"><code>SDDPModel</code></a> constructor:</p><pre><code class="language-julia">m = SDDPModel(
                  sense = :Min,
                 stages = 3,
                 solver = ClpSolver(),
        objective_bound = 0.0
                                        ) do sp, t
    # ... stuff to go here ...
end</code></pre><p>If you haven&#39;t seen the <code>do sp, t ... end</code> syntax before, this syntax is equivalent to the following:</p><pre><code class="language-julia">function define_subproblem(sp::JuMP.Model, t::Int)
    # ... stuff to go here ...
end
m = SDDPModel(
    define_subproblem,
    sense           = :Min,
    stages          = 3,
    solver          = ClpSolver(),
    objective_bound = 0.0
)</code></pre><p>The function <code>define_subproblem</code> (although you can call it anything you like) takes two arguments: <code>sp</code>, a <code>JuMP.Model</code> that we will use to build each subproblem; and <code>t</code>, an <code>Int</code> that is a counter from <code>1</code> to the number of stages. In this case, <code>t=1, 2, 3</code>. The <code>sense</code>, <code>stages</code>, and <code>solver</code> keyword arguments to <code>SDDPModel</code> should be obvious; however, the <code>objective_bound</code> is worth explaining.</p><p>In order to solve a model using SDDP, we need to define a valid lower bound for every subproblem. (See <a href="../introduction.html#Introduction-to-SDDP-1">Introduction to SDDP</a> for details.) In this example, the least-cost solution is to meet demand entirely from the hydro generator, incurring a cost of \$0/MWh. Therefore, we set <code>objective_bound=0.0</code>.</p><p>Now we need to define build each subproblem using a mix of JuMP and SDDP.jl syntax.</p><h3><a class="nav-anchor" id="State-variables-1" href="#State-variables-1">State variables</a></h3><p>There is one state variable in our model: the quantity of water in the reservoir at the end of stage <code>t</code>. Two add this state variable to the model, SDDP.jl defines the <a href="../apireference.html#SDDP.@state"><code>@state</code></a> macro.  This macro takes three arguments:</p><ol><li><p><code>sp</code> - the JuMP model;</p></li><li><p>an expression for the outgoing state variable; and</p></li><li><p>an expression for the incoming state variable.</p></li></ol><p>The 2nd argument can be any valid JuMP <code>@variable</code> syntax and can include, for example, upper and lower bounds. The 3rd argument must be the name of the incoming state variable, followed by <code>==</code>, and then the value of the state variable at the root node of the policy graph. For our hydrothermal example, the state variable can be constructed as:</p><pre><code class="language-julia">@state(sp, 0 &lt;= outgoing_volume &lt;= 200, incoming_volume == 200)</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>You must define the same state variables (in the same order) in every subproblem. If a state variable is unused in a particular stage, it must still be defined.</p></div></div><h3><a class="nav-anchor" id="Control-variables-1" href="#Control-variables-1">Control variables</a></h3><p>We now need to define some control variables. In SDDP.jl, control variables are just normal JuMP variables. Therefore, we can define the three variables in the hydrothermal scheduling problem (thermal generation, hydro generation, and the quantity of water to spill) as follows:</p><pre><code class="language-julia">@variables(sp, begin
    thermal_generation &gt;= 0
    hydro_generation   &gt;= 0
    hydro_spill        &gt;= 0
 end)</code></pre><h3><a class="nav-anchor" id="Constraints-1" href="#Constraints-1">Constraints</a></h3><p>Before we specify the constraints, we need to create some data. For this problem, we need the inflow to the reservoir in each stage <code>t=1, 2, 3</code>. Therefore, we create the vector:</p><pre><code class="language-julia">inflow = [50.0, 50.0, 50.0]</code></pre><p>The inflow in stage <code>t</code> can be accessed as <code>inflow[t]</code>.</p><p>First, we have the water balance constraint: the volume of water at the end of the stage must equal the volume of water at the start of the stage, plus any inflows, less that used for generation or spilled down the spillway.</p><pre><code class="language-julia">@constraint(sp,
    incoming_volume + inflow[t] - hydro_generation - hydro_spill == outgoing_volume
)</code></pre><p>Note that we use <code>t</code> defined by the <code>SDDPModel</code> constructor. There is also a constraint that total generation must equal demand of 150 MWh:</p><pre><code class="language-julia">@constraint(sp,
    thermal_generation + hydro_generation == 150
)</code></pre><h3><a class="nav-anchor" id="The-stage-objective-1" href="#The-stage-objective-1">The stage objective</a></h3><p>Finally, there is a cost on thermal generation of \$50/MWh in the first stage, \$100/MWh in the second stage, and \$150/MWh in the third stage. To add the stage-objective, we use the aptly named <a href="../apireference.html#SDDP.@stageobjective"><code>@stageobjective</code></a> macro provided by SDDP.jl:</p><pre><code class="language-julia">if t == 1
    @stageobjective(sp,  50.0 * thermal_generation )
elseif t == 2
    @stageobjective(sp, 100.0 * thermal_generation )
elseif t == 3
    @stageobjective(sp, 150.0 * thermal_generation )
end</code></pre><div class="admonition info"><div class="admonition-title">Info</div><div class="admonition-text"><p><code>if</code> statements can be used more broadly in the subproblem definition to conditionally and variables and constraints into different subproblems.</p></div></div><p>We can also implement the stage-objective more succinctly using a vector:</p><pre><code class="language-julia">fuel_cost = [50.0, 100.0, 150.0]
@stageobjective(sp, fuel_cost[t] * thermal_generation )</code></pre><h2><a class="nav-anchor" id="Solving-the-problem-1" href="#Solving-the-problem-1">Solving the problem</a></h2><p>Putting all that we have discussed above together, we get:</p><pre><code class="language-julia">using SDDP, JuMP, Clp
m = SDDPModel(
                  sense = :Min,
                 stages = 3,
                 solver = ClpSolver(),
        objective_bound = 0.0
                                        ) do sp, t
    @state(sp, 0 &lt;= outgoing_volume &lt;= 200, incoming_volume == 200)
    @variables(sp, begin
        thermal_generation &gt;= 0
        hydro_generation   &gt;= 0
        hydro_spill        &gt;= 0
     end)
    inflow = [50.0, 50.0, 50.0]
    @constraints(sp, begin
        incoming_volume + inflow[t] - hydro_generation - hydro_spill == outgoing_volume
        thermal_generation + hydro_generation == 150
    end)
    fuel_cost = [50.0, 100.0, 150.0]
    @stageobjective(sp, fuel_cost[t] * thermal_generation )
end</code></pre><p>To solve this problem, we use the <a href="../apireference.html#JuMP.solve"><code>solve</code></a> method:</p><pre><code class="language-julia">status = solve(m; iteration_limit=5)</code></pre><p>The argument <code>iteration_limit</code> is self-explanatory. The return value <code>status</code> is a symbol describing why the SDDP algorithm terminated. In this case, the value is <code>:iteration_limit</code>. We discuss other arguments to the <a href="../apireference.html#JuMP.solve"><code>solve</code></a> method and other possible values for <code>status</code> in future sections of this manual.</p><p>During the solve, the following log is printed to the screen.</p><pre><code class="language-none">-------------------------------------------------------------------------------
                          SDDP.jl © Oscar Dowson, 2017-2018
-------------------------------------------------------------------------------
    Solver:
        Serial solver
    Model:
        Stages:         3
        States:         1
        Subproblems:    3
        Value Function: Default
-------------------------------------------------------------------------------
              Objective              |  Cut  Passes    Simulations   Total
     Simulation       Bound   % Gap  |   #     Time     #    Time    Time
-------------------------------------------------------------------------------
       15.000K         5.000K        |     1    0.0      0    0.0    0.0
        5.000K         5.000K        |     2    0.0      0    0.0    0.0
        5.000K         5.000K        |     3    0.0      0    0.0    0.0
        5.000K         5.000K        |     4    0.0      0    0.0    0.0
        5.000K         5.000K        |     5    0.0      0    0.0    0.0
-------------------------------------------------------------------------------
    Other Statistics:
        Iterations:         5
        Termination Status: iteration_limit
===============================================================================</code></pre><p>The header and footer of the output log contain self-explanatory statistics about the problem. The numeric columns are worthy of description. Each row corresponds to one iteration of the SDDP algorithm.</p><p>The left half of the log relates to the objective of the problem. In the <em>Simulation</em> column, we give the cumulative cost of each forward pass. In the <em>Bound</em> column, we give the lower bound (upper if maximizing) obtained after the backward pass has completed in each iteration. Ignore the <em>% Gap</em> column for now, that is addressed in <a href="02_rhs_noise.html#Tutorial-Two:-RHS-noise-1">Tutorial Two: RHS noise</a>.</p><p>The right half of the log displays timing statistics. <em>Cut Passes</em> displays the number of cutting iterations conducted (in <em>#</em>) and the time it took to (in <em>Time</em>). Ignore the <em>Simulations</em> columns for now, they are addressed in Tutorial <a href="02_rhs_noise.html#Tutorial-Two:-RHS-noise-1">Tutorial Two: RHS noise</a>. Finally, the <em>Total Time</em> column records the total time spent solving the problem.</p><p>This log can be silenced by setting the <code>print_level</code> keyword argument to <code>solve</code> to <code>0</code>. In addition, the log will be written to the file given by the <code>log_file</code> keyword argument (this is off by default).</p><h2><a class="nav-anchor" id="Understanding-the-solution-1" href="#Understanding-the-solution-1">Understanding the solution</a></h2><p>The first thing we want to do is to query the lower (upper if maximizing) bound of the solution. This can be done via the <a href="../apireference.html#SDDP.getbound"><code>getbound</code></a> function:</p><pre><code class="language-julia">getbound(m)</code></pre><p>This returns the value of the <em>Bound</em> column in the last row in the output table above. In this example, the bound is <code>5000.0</code>.</p><p>Then, we can perform a Monte Carlo simulation of the policy using the <a href="../apireference.html#SDDP.simulate"><code>simulate</code></a> function. It takes three arguments. The first is the <a href="../apireference.html#SDDP.SDDPModel"><code>SDDPModel</code></a> <code>m</code>. The second is the number of replications to perform. The third is a vector of variable names to record the value of at each stage and replication. Since our example is deterministic, it is sufficient to perform a single replication:</p><pre><code class="language-julia">simulation_result = simulate(m,
    1,
    [:outgoing_volume, :thermal_generation, :hydro_generation, :hydro_spill]
)</code></pre><p>The return value, <code>simulation_result</code>, is a vector of dictionaries containing one element for each Monte Carlo replication. In this case, <code>length(simulation_result) = 1</code>. The keys of the dictionary are the variable symbols given in the <code>simulate</code> function, and their associated values are vectors, with one element for each stage, or the variable value in the simulated solution. For example, we can query the optimal quantity of hydro generation in each stage as follows:</p><pre><code class="language-julia">julia&gt; simulation_result[1][:hydro_generation]
3-element Array{Any, 1}:
  50.0
 150.0
 150.0</code></pre><p>This concludes our first very simple tutorial for SDDP.jl. In the next tutorial, <a href="02_rhs_noise.html#Tutorial-Two:-RHS-noise-1">Tutorial Two: RHS noise</a>, we introduce stagewise-independent noise into the model.</p><footer><hr/><a class="previous" href="../index.html"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="02_rhs_noise.html"><span class="direction">Next</span><span class="title">Tutorial Two: RHS noise</span></a></footer></article></body></html>
