var documenterSearchIndex = {"docs":
[{"location":"guides/create_a_general_policy_graph/#Create-a-general-policy-graph","page":"Create a general policy graph","title":"Create a general policy graph","text":"","category":"section"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"DocTestSetup = quote\n    using SDDP, HiGHS\nend","category":"page"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"SDDP.jl uses the concept of a policy graph to formulate multistage stochastic programming problems. For more details, read An introduction to SDDP.jl or the paper Dowson, O., (2020). The policy graph decomposition of multistage stochastic optimization problems. Networks, 76(1), 3-23. doi.","category":"page"},{"location":"guides/create_a_general_policy_graph/#Creating-a-[SDDP.Graph](@ref)","page":"Create a general policy graph","title":"Creating a SDDP.Graph","text":"","category":"section"},{"location":"guides/create_a_general_policy_graph/#Linear-graphs","page":"Create a general policy graph","title":"Linear graphs","text":"","category":"section"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"Linear policy graphs can be created using the SDDP.LinearGraph function.","category":"page"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"julia> graph = SDDP.LinearGraph(3)\nRoot\n 0\nNodes\n 1\n 2\n 3\nArcs\n 0 => 1 w.p. 1.0\n 1 => 2 w.p. 1.0\n 2 => 3 w.p. 1.0","category":"page"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"We can add nodes to a graph using SDDP.add_node and edges using SDDP.add_edge.","category":"page"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"julia> SDDP.add_node(graph, 4)\n\njulia> SDDP.add_edge(graph, 3 => 4, 1.0)\n\njulia> SDDP.add_edge(graph, 4 => 1, 0.9)\n\njulia> graph\nRoot\n 0\nNodes\n 1\n 2\n 3\n 4\nArcs\n 0 => 1 w.p. 1.0\n 1 => 2 w.p. 1.0\n 2 => 3 w.p. 1.0\n 3 => 4 w.p. 1.0\n 4 => 1 w.p. 0.9","category":"page"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"Look! We just made a cyclic graph! SDDP.jl can solve infinite horizon problems. The probability on the arc that completes a cycle should be interpreted as a discount factor.","category":"page"},{"location":"guides/create_a_general_policy_graph/#guide_unicyclic_policy_graph","page":"Create a general policy graph","title":"Unicyclic policy graphs","text":"","category":"section"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"Linear policy graphs with a single infinite-horizon cycle can be created using the SDDP.UnicyclicGraph function.","category":"page"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"julia> SDDP.UnicyclicGraph(0.95; num_nodes = 2)\nRoot\n 0\nNodes\n 1\n 2\nArcs\n 0 => 1 w.p. 1.0\n 1 => 2 w.p. 1.0\n 2 => 1 w.p. 0.95","category":"page"},{"location":"guides/create_a_general_policy_graph/#guide_markovian_policy_graph","page":"Create a general policy graph","title":"Markovian policy graphs","text":"","category":"section"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"Markovian policy graphs can be created using the SDDP.MarkovianGraph function.","category":"page"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"julia> SDDP.MarkovianGraph(Matrix{Float64}[[1.0]', [0.4 0.6]])\nRoot\n (0, 1)\nNodes\n (1, 1)\n (2, 1)\n (2, 2)\nArcs\n (0, 1) => (1, 1) w.p. 1.0\n (1, 1) => (2, 1) w.p. 0.4\n (1, 1) => (2, 2) w.p. 0.6","category":"page"},{"location":"guides/create_a_general_policy_graph/#General-graphs","page":"Create a general policy graph","title":"General graphs","text":"","category":"section"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"Arbitrarily complicated graphs can be constructed using SDDP.Graph, SDDP.add_node and SDDP.add_edge. For example","category":"page"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"julia> graph = SDDP.Graph(:root_node)\nRoot\n root_node\nNodes\n {}\nArcs\n {}\n\njulia> SDDP.add_node(graph, :decision_node)\n\njulia> SDDP.add_edge(graph, :root_node => :decision_node, 1.0)\n\njulia> SDDP.add_edge(graph, :decision_node => :decision_node, 0.9)\n\njulia> graph\nRoot\n root_node\nNodes\n decision_node\nArcs\n root_node => decision_node w.p. 1.0\n decision_node => decision_node w.p. 0.9","category":"page"},{"location":"guides/create_a_general_policy_graph/#Creating-a-policy-graph","page":"Create a general policy graph","title":"Creating a policy graph","text":"","category":"section"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"Once you have constructed an instance of SDDP.Graph, you can create a policy graph by passing the graph as the first argument.","category":"page"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"julia> graph = SDDP.Graph(\n           :root_node,\n           [:decision_node],\n           [\n               (:root_node => :decision_node, 1.0),\n               (:decision_node => :decision_node, 0.9)\n           ]);\n\njulia> model = SDDP.PolicyGraph(\n               graph,\n               lower_bound = 0,\n               optimizer = HiGHS.Optimizer) do subproblem, node\n           println(\"Called from node: \", node)\n       end;\nCalled from node: decision_node","category":"page"},{"location":"guides/create_a_general_policy_graph/#Special-cases","page":"Create a general policy graph","title":"Special cases","text":"","category":"section"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"There are two special cases which cover the majority of models in the literature.","category":"page"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"SDDP.LinearPolicyGraph is a special case where a SDDP.LinearGraph is passed as the first argument.\nSDDP.MarkovianPolicyGraph is a special case where a SDDP.MarkovianGraph is passed as the first argument.","category":"page"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"Note that the type of the names of all nodes (including the root node) must be the same. In this case, they are Symbols.","category":"page"},{"location":"guides/create_a_general_policy_graph/#Simulating-non-standard-policy-graphs","page":"Create a general policy graph","title":"Simulating non-standard policy graphs","text":"","category":"section"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"If you simulate a policy graph with a node that has outgoing arcs that sum to less than one, you will end up with simulations of different lengths. (The most common case is an infinite horizon stochastic program, aka a linear policy graph with a single cycle.)","category":"page"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"To simulate a fixed number of stages, use:","category":"page"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"simulations = SDDP.simulate(\n    model,\n    1,\n    sampling_scheme = SDDP.InSampleMonteCarlo(\n        max_depth = 10,\n        terminate_on_dummy_leaf = false\n    )\n)","category":"page"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"Here, max_depth controls the number of stages, and terminate_on_dummy_leaf = false stops us from terminating early.","category":"page"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"See also Simulate using a different sampling scheme.","category":"page"},{"location":"guides/create_a_general_policy_graph/#Creating-a-Markovian-graph-automatically","page":"Create a general policy graph","title":"Creating a Markovian graph automatically","text":"","category":"section"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"SDDP.jl can create a Markovian graph by automatically discretizing a one-dimensional stochastic process and fitting a Markov chain.","category":"page"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"To access this functionality, pass a function that takes no arguments and returns a Vector{Float64} to SDDP.MarkovianGraph. To keyword arguments also need to be provided: budget is the total number of nodes in the Markovian graph, and scenarios is the number of realizations of the simulator function used to approximate the graph.","category":"page"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"In some cases, scenarios may be too small to provide a reasonable fit of the stochastic process. If so, SDDP.jl will automatically try to re-fit the Markov chain using more scenarios.","category":"page"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"function simulator()\n    scenario = zeros(5)\n    for i = 2:5\n        scenario[i] = scenario[i - 1] + rand() - 0.5\n    end\n    return scenario\nend\n\nmodel = SDDP.PolicyGraph(\n    SDDP.MarkovianGraph(simulator; budget = 10, scenarios = 100),\n    sense = :Max,\n    upper_bound = 1e3\n) do subproblem, node\n    (stage, price) = node\n    @variable(subproblem, x >= 0, SDDP.State, initial_value = 1)\n    @constraint(subproblem, x.out <= x.in)\n    @stageobjective(subproblem, price * x.out)\nend","category":"page"},{"location":"guides/debug_a_model/#Debug-a-model","page":"Debug a model","title":"Debug a model","text":"","category":"section"},{"location":"guides/debug_a_model/","page":"Debug a model","title":"Debug a model","text":"Building multistage stochastic programming models is hard. There are a lot of different pieces that need to be put together, and we typically have no idea of the optimal policy, so it can be hard (impossible?) to validate the solution.","category":"page"},{"location":"guides/debug_a_model/","page":"Debug a model","title":"Debug a model","text":"That said, here are a few tips to verify and validate models built using SDDP.jl.","category":"page"},{"location":"guides/debug_a_model/#Writing-subproblems-to-file","page":"Debug a model","title":"Writing subproblems to file","text":"","category":"section"},{"location":"guides/debug_a_model/","page":"Debug a model","title":"Debug a model","text":"The first step to debug a model is to write out the subproblems to a file in order to check that you are actually building what you think you are building.","category":"page"},{"location":"guides/debug_a_model/","page":"Debug a model","title":"Debug a model","text":"This can be achieved with the help of two functions: SDDP.parameterize and SDDP.write_subproblem_to_file. The first lets you parameterize a node given a noise, and the second writes out the subproblem to a file.","category":"page"},{"location":"guides/debug_a_model/","page":"Debug a model","title":"Debug a model","text":"Here is an example model:","category":"page"},{"location":"guides/debug_a_model/","page":"Debug a model","title":"Debug a model","text":"using SDDP, HiGHS\n\nmodel = SDDP.LinearPolicyGraph(\n            stages = 2,\n            lower_bound = 0.0,\n            optimizer = HiGHS.Optimizer,\n        ) do subproblem, t\n    @variable(subproblem, x, SDDP.State, initial_value = 1)\n    @variable(subproblem, y)\n    @constraint(subproblem, balance, x.in == x.out + y)\n    SDDP.parameterize(subproblem, [1.1, 2.2]) do ω\n        @stageobjective(subproblem, ω * x.out)\n        JuMP.fix(y, ω)\n    end\nend\n\n# output\n\nA policy graph with 2 nodes.\n Node indices: 1, 2","category":"page"},{"location":"guides/debug_a_model/","page":"Debug a model","title":"Debug a model","text":"Initially, model hasn't been parameterized with a concrete realizations of ω. Let's do so now by parameterizing the first subproblem with ω=1.1.","category":"page"},{"location":"guides/debug_a_model/","page":"Debug a model","title":"Debug a model","text":"julia> SDDP.parameterize(model[1], 1.1)","category":"page"},{"location":"guides/debug_a_model/","page":"Debug a model","title":"Debug a model","text":"Easy! To parameterize the second stage problem, we would have used model[2].","category":"page"},{"location":"guides/debug_a_model/","page":"Debug a model","title":"Debug a model","text":"Now to write out the problem to a file. We'll get a few warnings because some variables and constraints don't have names. They don't matter, so ignore them.","category":"page"},{"location":"guides/debug_a_model/","page":"Debug a model","title":"Debug a model","text":"julia> SDDP.write_subproblem_to_file(model[1], \"subproblem.lp\")\n\njulia> read(\"subproblem.lp\") |> String |> print\nminimize\nobj: 1.1 x_out + 1 x2\nsubject to\nbalance: -1 y + 1 x_in - 1 x_out = 0\nBounds\nx2 >= 0\ny = 1.1\nx_in free\nx_out free\nEnd","category":"page"},{"location":"guides/debug_a_model/","page":"Debug a model","title":"Debug a model","text":"It is easy to see that ω has been set in the objective, and as the fixed value for y.","category":"page"},{"location":"guides/debug_a_model/","page":"Debug a model","title":"Debug a model","text":"It is also possible to parameterize the subproblems using values for ω that are not in the original problem formulation.","category":"page"},{"location":"guides/debug_a_model/","page":"Debug a model","title":"Debug a model","text":"julia> SDDP.parameterize(model[1], 3.3)\n\njulia> SDDP.write_subproblem_to_file(model[1], \"subproblem.lp\")\n\njulia> read(\"subproblem.lp\") |> String |> print\nminimize\nobj: 3.3 x_out + 1 x2\nsubject to\nbalance: -1 y + 1 x_in - 1 x_out = 0\nBounds\nx2 >= 0\ny = 3.3\nx_in free\nx_out free\nEnd\n\njulia> rm(\"subproblem.lp\")  # Clean up.","category":"page"},{"location":"guides/debug_a_model/#Solve-the-deterministic-equivalent","page":"Debug a model","title":"Solve the deterministic equivalent","text":"","category":"section"},{"location":"guides/debug_a_model/","page":"Debug a model","title":"Debug a model","text":"Sometimes, it can be helpful to solve the deterministic equivalent of a problem in order to obtain an exact solution to the problem. To obtain a JuMP model that represents the deterministic equivalent, use SDDP.deterministic_equivalent. The returned model is just a normal JuMP model. Use JuMP to optimize it and query the solution.","category":"page"},{"location":"guides/debug_a_model/","page":"Debug a model","title":"Debug a model","text":"julia> det_equiv = SDDP.deterministic_equivalent(model, HiGHS.Optimizer)\nA JuMP Model\nFeasibility problem with:\nVariables: 24\n`AffExpr`-in-`MathOptInterface.EqualTo{Float64}`: 10 constraints\n`VariableRef`-in-`MathOptInterface.EqualTo{Float64}`: 8 constraints\n`VariableRef`-in-`MathOptInterface.GreaterThan{Float64}`: 6 constraints\n`VariableRef`-in-`MathOptInterface.LessThan{Float64}`: 4 constraints\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: HiGHS\n\njulia> set_silent(det_equiv)\n\njulia> optimize!(det_equiv)\n\njulia> objective_value(det_equiv)\n-5.472500000000001","category":"page"},{"location":"guides/debug_a_model/","page":"Debug a model","title":"Debug a model","text":"warning: Warning\nThe deterministic equivalent scales poorly with problem size. Only use this on small problems!","category":"page"},{"location":"guides/add_multidimensional_noise/#Add-multi-dimensional-noise-terms","page":"Add multi-dimensional noise terms","title":"Add multi-dimensional noise terms","text":"","category":"section"},{"location":"guides/add_multidimensional_noise/","page":"Add multi-dimensional noise terms","title":"Add multi-dimensional noise terms","text":"DocTestSetup = quote\n    using SDDP, HiGHS\nend","category":"page"},{"location":"guides/add_multidimensional_noise/","page":"Add multi-dimensional noise terms","title":"Add multi-dimensional noise terms","text":"Multi-dimensional stagewise-independent random variables can be created by forming the Cartesian product of the random variables.","category":"page"},{"location":"guides/add_multidimensional_noise/#A-simple-example","page":"Add multi-dimensional noise terms","title":"A simple example","text":"","category":"section"},{"location":"guides/add_multidimensional_noise/","page":"Add multi-dimensional noise terms","title":"Add multi-dimensional noise terms","text":"If the sample space and probabilities are given as vectors for each marginal distribution, do:","category":"page"},{"location":"guides/add_multidimensional_noise/","page":"Add multi-dimensional noise terms","title":"Add multi-dimensional noise terms","text":"julia> model = SDDP.LinearPolicyGraph(\n           stages = 3,\n           lower_bound = 0,\n           optimizer = HiGHS.Optimizer,\n       ) do subproblem, t\n           @variable(subproblem, x, SDDP.State, initial_value = 0.0)\n           Ω = [(value = v, coefficient = c) for v in [1, 2] for c in [3, 4, 5]]\n           P = [v * c for v in [0.5, 0.5] for c in [0.3, 0.5, 0.2]]\n           SDDP.parameterize(subproblem, Ω, P) do ω\n               JuMP.fix(x.out, ω.value)\n               @stageobjective(subproblem, ω.coefficient * x.out)\n               println(\"ω is: \", ω)\n           end\n       end;\n\njulia> SDDP.simulate(model, 1);\nω is: (value = 1, coefficient = 4)\nω is: (value = 1, coefficient = 3)\nω is: (value = 2, coefficient = 4)","category":"page"},{"location":"guides/add_multidimensional_noise/#Using-Distributions.jl","page":"Add multi-dimensional noise terms","title":"Using Distributions.jl","text":"","category":"section"},{"location":"guides/add_multidimensional_noise/","page":"Add multi-dimensional noise terms","title":"Add multi-dimensional noise terms","text":"For sampling multidimensional random variates, it can be useful to use the Product type from Distributions.jl.","category":"page"},{"location":"guides/add_multidimensional_noise/#Finite-discrete-distributions","page":"Add multi-dimensional noise terms","title":"Finite discrete distributions","text":"","category":"section"},{"location":"guides/add_multidimensional_noise/","page":"Add multi-dimensional noise terms","title":"Add multi-dimensional noise terms","text":"There are several ways to go about this. If the sample space is finite, and small enough that it makes sense to enumerate each element, we can use Base.product and Distributions.support to generate the entire sample space Ω from each of the marginal distributions. ","category":"page"},{"location":"guides/add_multidimensional_noise/","page":"Add multi-dimensional noise terms","title":"Add multi-dimensional noise terms","text":"We can then evaluate the density function of the product distribution on each element of this space to get the vector of corresponding probabilities, P.","category":"page"},{"location":"guides/add_multidimensional_noise/","page":"Add multi-dimensional noise terms","title":"Add multi-dimensional noise terms","text":"julia> import Distributions\n\njulia> distributions = [\n           Distributions.Binomial(10, 0.5),\n           Distributions.Bernoulli(0.5),\n           Distributions.truncated(Distributions.Poisson(5), 2, 8)\n       ];\n\njulia> supports = Distributions.support.(distributions);\n\njulia> Ω = vec([collect(ω) for ω in Base.product(supports...)]);\n\njulia> P = [Distributions.pdf(Distributions.Product(distributions), ω) for ω in Ω];\n\njulia> model = SDDP.LinearPolicyGraph(\n           stages = 3,\n           lower_bound = 0,\n           optimizer = HiGHS.Optimizer,\n       ) do subproblem, t\n           @variable(subproblem, x, SDDP.State, initial_value = 0.0)\n           SDDP.parameterize(subproblem, Ω, P) do ω\n               JuMP.fix(x.out, ω[1])\n               @stageobjective(subproblem, ω[2] * x.out + ω[3])\n               println(\"ω is: \", ω)\n           end\n       end;\n\njulia> SDDP.simulate(model, 1);\nω is: [10, 0, 3]\nω is: [0, 1, 6]\nω is: [6, 0, 5]","category":"page"},{"location":"guides/add_multidimensional_noise/#Sampling","page":"Add multi-dimensional noise terms","title":"Sampling","text":"","category":"section"},{"location":"guides/add_multidimensional_noise/","page":"Add multi-dimensional noise terms","title":"Add multi-dimensional noise terms","text":"For sample spaces that are too large to explicitly represent, we can instead approximate the distribution by a sample of N points. Now Ω is a sample from the full sample space, and P is the uniform distribution over those points. Points with higher density in the full sample space will appear more frequently in Ω.","category":"page"},{"location":"guides/add_multidimensional_noise/","page":"Add multi-dimensional noise terms","title":"Add multi-dimensional noise terms","text":"julia> import Distributions\n\njulia> distributions = Distributions.Product([\n           Distributions.Binomial(100, 0.5),\n           Distributions.Geometric(1 / 20),\n           Distributions.Poisson(20),\n       ]);\n\njulia> N = 100;\n\njulia> Ω = [rand(distributions) for _ in 1:N];\n\njulia> P = fill(1 / N, N);\n\njulia> model = SDDP.LinearPolicyGraph(\n           stages = 3,\n           lower_bound = 0,\n           optimizer = HiGHS.Optimizer,\n       ) do subproblem, t\n           @variable(subproblem, x, SDDP.State, initial_value = 0.0)\n           SDDP.parameterize(subproblem, Ω, P) do ω\n               JuMP.fix(x.out, ω[1])\n               @stageobjective(subproblem, ω[2] * x.out + ω[3])\n               println(\"ω is: \", ω)\n           end\n       end;\n\njulia> SDDP.simulate(model, 1);\nω is: [54, 38, 19]\nω is: [43, 3, 13]\nω is: [43, 4, 17]","category":"page"},{"location":"examples/booking_management/","page":"Booking management","title":"Booking management","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/examples/booking_management.jl\"","category":"page"},{"location":"examples/booking_management/#Booking-management","page":"Booking management","title":"Booking management","text":"","category":"section"},{"location":"examples/booking_management/","page":"Booking management","title":"Booking management","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/booking_management/","page":"Booking management","title":"Booking management","text":"This example concerns the acceptance of booking requests for rooms in a hotel in the lead up to a large event.","category":"page"},{"location":"examples/booking_management/","page":"Booking management","title":"Booking management","text":"Each stage, we receive a booking request and can choose to accept or decline it. Once accepted, bookings cannot be terminated.","category":"page"},{"location":"examples/booking_management/","page":"Booking management","title":"Booking management","text":"using SDDP, HiGHS, Test\n\nfunction booking_management_model(num_days, num_rooms, num_requests)\n    # maximum revenue that could be accrued.\n    max_revenue = (num_rooms + num_requests) * num_days * num_rooms\n    # booking_requests is a vector of {0,1} arrays of size\n    # (num_days x num_rooms) if the room is requested.\n    booking_requests = Array{Int,2}[]\n    for room in 1:num_rooms\n        for day in 1:num_days\n            # note: length_of_stay is 0 indexed to avoid unnecessary +/- 1\n            # on the indexing\n            for length_of_stay in 0:(num_days-day)\n                req = zeros(Int, (num_rooms, num_days))\n                req[room:room, day.+(0:length_of_stay)] .= 1\n                push!(booking_requests, req)\n            end\n        end\n    end\n\n    return model = SDDP.LinearPolicyGraph(\n        stages = num_requests,\n        upper_bound = max_revenue,\n        sense = :Max,\n        optimizer = HiGHS.Optimizer,\n    ) do sp, stage\n        @variable(\n            sp,\n            0 <= vacancy[room = 1:num_rooms, day = 1:num_days] <= 1,\n            SDDP.State,\n            Bin,\n            initial_value = 1\n        )\n        @variables(\n            sp,\n            begin\n                # Accept request for booking of room for length of time.\n                0 <= accept_request <= 1, Bin\n                # Accept a booking for an individual room on an individual day.\n                0 <= room_request_accepted[1:num_rooms, 1:num_days] <= 1, Bin\n                # Helper for JuMP.fix\n                req[1:num_rooms, 1:num_days]\n            end\n        )\n        for room in 1:num_rooms, day in 1:num_days\n            @constraints(\n                sp,\n                begin\n                    # Update vacancy if we accept a room request\n                    vacancy[room, day].out ==\n                    vacancy[room, day].in - room_request_accepted[room, day]\n                    # Can't accept a request of a filled room\n                    room_request_accepted[room, day] <= vacancy[room, day].in\n                    # Can't accept invididual room request if entire request is declined\n                    room_request_accepted[room, day] <= accept_request\n                    # Can't accept request if room not requested\n                    room_request_accepted[room, day] <= req[room, day]\n                    # Accept all individual rooms is entire request is accepted\n                    room_request_accepted[room, day] + (1 - accept_request) >= req[room, day]\n                end\n            )\n        end\n        SDDP.parameterize(sp, booking_requests) do request\n            return JuMP.fix.(req, request)\n        end\n        @stageobjective(\n            sp,\n            sum(\n                (room + stage - 1) * room_request_accepted[room, day] for\n                room in 1:num_rooms for day in 1:num_days\n            )\n        )\n    end\nend\n\nfunction booking_management(duality_handler)\n    m_1_2_5 = booking_management_model(1, 2, 5)\n    SDDP.train(m_1_2_5; log_frequency = 5, duality_handler = duality_handler)\n    if duality_handler == SDDP.ContinuousConicDuality()\n        @test SDDP.calculate_bound(m_1_2_5) >= 7.25 - 1e-4\n    else\n        @test isapprox(SDDP.calculate_bound(m_1_2_5), 7.25, atol = 0.02)\n    end\n\n    m_2_2_3 = booking_management_model(2, 2, 3)\n    SDDP.train(m_2_2_3; log_frequency = 10, duality_handler = duality_handler)\n    if duality_handler == SDDP.ContinuousConicDuality()\n        @test SDDP.calculate_bound(m_1_2_5) > 6.13\n    else\n        @test isapprox(SDDP.calculate_bound(m_2_2_3), 6.13, atol = 0.02)\n    end\nend\n\nbooking_management(SDDP.ContinuousConicDuality())","category":"page"},{"location":"examples/booking_management/","page":"Booking management","title":"Booking management","text":"New version of HiGHS stalls booking_management(SDDP.LagrangianDuality())","category":"page"},{"location":"examples/booking_management/","page":"Booking management","title":"Booking management","text":"","category":"page"},{"location":"examples/booking_management/","page":"Booking management","title":"Booking management","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/no_strong_duality/","page":"No strong duality","title":"No strong duality","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/examples/no_strong_duality.jl\"","category":"page"},{"location":"examples/no_strong_duality/#No-strong-duality","page":"No strong duality","title":"No strong duality","text":"","category":"section"},{"location":"examples/no_strong_duality/","page":"No strong duality","title":"No strong duality","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/no_strong_duality/","page":"No strong duality","title":"No strong duality","text":"This example is interesting, because strong duality doesn't hold for the extensive form (see if you can show why!), but we still converge.","category":"page"},{"location":"examples/no_strong_duality/","page":"No strong duality","title":"No strong duality","text":"using SDDP, HiGHS, Test\n\nfunction no_strong_duality()\n    model = SDDP.PolicyGraph(\n        SDDP.Graph(\n            :root,\n            [:node],\n            [(:root => :node, 1.0), (:node => :node, 0.5)],\n        ),\n        optimizer = HiGHS.Optimizer,\n        lower_bound = 0.0,\n    ) do sp, t\n        @variable(sp, x, SDDP.State, initial_value = 1.0)\n        @stageobjective(sp, x.out)\n        @constraint(sp, x.in == x.out)\n    end\n    SDDP.train(model)\n    @test SDDP.calculate_bound(model) ≈ 2.0 atol = 1e-5\n    return\nend\n\nno_strong_duality()","category":"page"},{"location":"examples/no_strong_duality/","page":"No strong duality","title":"No strong duality","text":"","category":"page"},{"location":"examples/no_strong_duality/","page":"No strong duality","title":"No strong duality","text":"This page was generated using Literate.jl.","category":"page"},{"location":"guides/add_integrality/","page":"Integrality","title":"Integrality","text":"CurrentModule = SDDP","category":"page"},{"location":"guides/add_integrality/#Integrality","page":"Integrality","title":"Integrality","text":"","category":"section"},{"location":"guides/add_integrality/","page":"Integrality","title":"Integrality","text":"There's nothing special about binary and integer variables in SDDP.jl. Your models may contain a mix of binary, integer, or continuous state and control variables. Use the standard JuMP syntax to add binary or integer variables.","category":"page"},{"location":"guides/add_integrality/","page":"Integrality","title":"Integrality","text":"For example:","category":"page"},{"location":"guides/add_integrality/","page":"Integrality","title":"Integrality","text":"using SDDP, HiGHS\nmodel = SDDP.LinearPolicyGraph(\n   stages = 3,\n   lower_bound = 0.0,\n   optimizer = HiGHS.Optimizer,\n) do sp, t\n   @variable(sp, 0 <= x <= 100, Int, SDDP.State, initial_value = 0)\n   @variable(sp, 0 <= u <= 200, integer = true)\n   @variable(sp, v >= 0)\n   @constraint(sp, x.out == x.in + u + v - 150)\n   @stageobjective(sp, 2u + 6v + x.out)\nend","category":"page"},{"location":"guides/add_integrality/","page":"Integrality","title":"Integrality","text":"If you want finer control over how SDDP.jl computes subgradients in the backward pass, you can pass an SDDP.AbstractDualityHandler to the duality_handler argument of SDDP.train.","category":"page"},{"location":"guides/add_integrality/","page":"Integrality","title":"Integrality","text":"See Duality handlers for the list of handlers you can pass.","category":"page"},{"location":"guides/add_integrality/#Convergence","page":"Integrality","title":"Convergence","text":"","category":"section"},{"location":"guides/add_integrality/","page":"Integrality","title":"Integrality","text":"SDDP.jl cannot guarantee that it will find a globally optimal policy when some of the variables are discrete. However, in most cases we find that it can still find an integer feasible policy that performs well in simulation.","category":"page"},{"location":"guides/add_integrality/","page":"Integrality","title":"Integrality","text":"Moreover, when the number of nodes in the graph is large, or there is uncertainty, we are not aware of another algorithm that can claim to find a globally optimal policy.","category":"page"},{"location":"guides/add_integrality/#Does-SDDP.jl-implement-the-SDDiP-algorithm?","page":"Integrality","title":"Does SDDP.jl implement the SDDiP algorithm?","text":"","category":"section"},{"location":"guides/add_integrality/","page":"Integrality","title":"Integrality","text":"Most discussions of SDDiP in the literature confuse two unrelated things.","category":"page"},{"location":"guides/add_integrality/","page":"Integrality","title":"Integrality","text":"First, how to compute dual variables\nSecond, when the algorithm will converge to a globally optimal policy.","category":"page"},{"location":"guides/add_integrality/#Computing-dual-variables","page":"Integrality","title":"Computing dual variables","text":"","category":"section"},{"location":"guides/add_integrality/","page":"Integrality","title":"Integrality","text":"The stochastic dual dynamic programming algorithm requires a subgradient of the objective with respect to the incoming state variable. ","category":"page"},{"location":"guides/add_integrality/","page":"Integrality","title":"Integrality","text":"One way to obtain a valid subgradient is to compute an optimal value of the dual variable lambda in the following subproblem:","category":"page"},{"location":"guides/add_integrality/","page":"Integrality","title":"Integrality","text":"beginaligned\nV_i(x omega) = minlimits_barx x^prime u   C_i(barx u omega) + mathbbE_j in i^+ varphi in Omega_jV_j(x^prime varphi)\n x^prime = T_i(barx u omega) \n u in U_i(barx omega) \n barx = x quad lambda\nendaligned","category":"page"},{"location":"guides/add_integrality/","page":"Integrality","title":"Integrality","text":"The easiest option is to relax integrality of the discrete variables to form a linear program and then use linear programming duality to obtain the dual. But we could also use Lagrangian duality without needing to relax the integrality constraints.","category":"page"},{"location":"guides/add_integrality/","page":"Integrality","title":"Integrality","text":"To compute the Lagrangian dual lambda, we penalize lambda^top(barx - x) in the objective instead of enforcing the constraint:","category":"page"},{"location":"guides/add_integrality/","page":"Integrality","title":"Integrality","text":"beginaligned\nmaxlimits_lambdaminlimits_barx x^prime u   C_i(barx u omega) + mathbbE_j in i^+ varphi in Omega_jV_j(x^prime varphi) - lambda^top(barx - x)\n x^prime = T_i(barx u omega) \n u in U_i(barx omega)\nendaligned","category":"page"},{"location":"guides/add_integrality/","page":"Integrality","title":"Integrality","text":"You can use Lagrangian duality in SDDP.jl by passing SDDP.LagrangianDuality to the duality_handler argument of SDDP.train.","category":"page"},{"location":"guides/add_integrality/","page":"Integrality","title":"Integrality","text":"Compared with linear programming duality, the Lagrangian problem is difficult to solve because it requires the solution of many mixed-integer programs instead of a single linear program. This is one reason why \"SDDiP\" has poor performance.","category":"page"},{"location":"guides/add_integrality/#Convergence-2","page":"Integrality","title":"Convergence","text":"","category":"section"},{"location":"guides/add_integrality/","page":"Integrality","title":"Integrality","text":"The second part to SDDiP is a very tightly scoped claim: if all of the state variables are binary and the algorithm uses Lagrangian duality to compute a subgradient, then it will converge to an optimal policy.","category":"page"},{"location":"guides/add_integrality/","page":"Integrality","title":"Integrality","text":"In many cases, papers claim to \"do SDDiP,\" but they have state variables which are not binary. In these cases, the algorithm is not guaranteed to converge to a globally optimal policy.","category":"page"},{"location":"guides/add_integrality/","page":"Integrality","title":"Integrality","text":"One work-around that has been suggested is to discretize the state variables into a set of binary state variables. However, this leads to a large number of binary state variables, which is another reason why \"SDDiP\" has poor performance.","category":"page"},{"location":"guides/add_integrality/","page":"Integrality","title":"Integrality","text":"In general, we recommend that you introduce integer variables into your model without fear of the consequences, and that you treat the resulting policy as a good heuristic, rather than an attempt to find a globally optimal policy.","category":"page"},{"location":"examples/StructDualDynProg.jl_prob5.2_2stages/","page":"StructDualDynProg: Problem 5.2, 2 stages","title":"StructDualDynProg: Problem 5.2, 2 stages","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/examples/StructDualDynProg.jl_prob5.2_2stages.jl\"","category":"page"},{"location":"examples/StructDualDynProg.jl_prob5.2_2stages/#StructDualDynProg:-Problem-5.2,-2-stages","page":"StructDualDynProg: Problem 5.2, 2 stages","title":"StructDualDynProg: Problem 5.2, 2 stages","text":"","category":"section"},{"location":"examples/StructDualDynProg.jl_prob5.2_2stages/","page":"StructDualDynProg: Problem 5.2, 2 stages","title":"StructDualDynProg: Problem 5.2, 2 stages","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/StructDualDynProg.jl_prob5.2_2stages/","page":"StructDualDynProg: Problem 5.2, 2 stages","title":"StructDualDynProg: Problem 5.2, 2 stages","text":"This example comes from StochasticDualDynamicProgramming.jl","category":"page"},{"location":"examples/StructDualDynProg.jl_prob5.2_2stages/","page":"StructDualDynProg: Problem 5.2, 2 stages","title":"StructDualDynProg: Problem 5.2, 2 stages","text":"using SDDP, HiGHS, Test\n\nfunction test_prob52_2stages()\n    model = SDDP.LinearPolicyGraph(\n        stages = 2,\n        lower_bound = 0.0,\n        optimizer = HiGHS.Optimizer,\n    ) do subproblem, stage\n        # ========== Problem data ==========\n        n = 4\n        m = 3\n        i_c = [16, 5, 32, 2]\n        C = [25, 80, 6.5, 160]\n        T = [8760, 7000, 1500] / 8760\n        D2 = [diff([0, 3919, 7329, 10315]) diff([0, 7086, 9004, 11169])]\n        p2 = [0.9, 0.1]\n        # ========== State Variables ==========\n        @variable(subproblem, x[i = 1:n] >= 0, SDDP.State, initial_value = 0.0)\n        # ========== Variables ==========\n        @variables(subproblem, begin\n            y[1:n, 1:m] >= 0\n            v[1:n] >= 0\n            penalty >= 0\n            rhs_noise[1:m]  # Dummy variable for RHS noise term.\n        end)\n        # ========== Constraints ==========\n        @constraints(\n            subproblem,\n            begin\n                [i = 1:n], x[i].out == x[i].in + v[i]\n                [i = 1:n], sum(y[i, :]) <= x[i].in\n                [j = 1:m], sum(y[:, j]) + penalty >= rhs_noise[j]\n            end\n        )\n        if stage == 2\n            # No investment in last stage.\n            @constraint(subproblem, sum(v) == 0)\n        end\n        # ========== Uncertainty ==========\n        if stage != 1 # no uncertainty in first stage\n            SDDP.parameterize(subproblem, 1:size(D2, 2), p2) do ω\n                for j in 1:m\n                    JuMP.fix(rhs_noise[j], D2[j, ω])\n                end\n            end\n        end\n        # ========== Stage objective ==========\n        @stageobjective(subproblem, i_c' * v + C' * y * T + 1e6 * penalty)\n        return\n    end\n    SDDP.train(model; log_frequency = 10)\n    @test SDDP.calculate_bound(model) ≈ 340315.52 atol = 0.1\n    return\nend\n\ntest_prob52_2stages()","category":"page"},{"location":"examples/StructDualDynProg.jl_prob5.2_2stages/","page":"StructDualDynProg: Problem 5.2, 2 stages","title":"StructDualDynProg: Problem 5.2, 2 stages","text":"","category":"page"},{"location":"examples/StructDualDynProg.jl_prob5.2_2stages/","page":"StructDualDynProg: Problem 5.2, 2 stages","title":"StructDualDynProg: Problem 5.2, 2 stages","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/stochastic_all_blacks/","page":"Stochastic All Blacks","title":"Stochastic All Blacks","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/examples/stochastic_all_blacks.jl\"","category":"page"},{"location":"examples/stochastic_all_blacks/#Stochastic-All-Blacks","page":"Stochastic All Blacks","title":"Stochastic All Blacks","text":"","category":"section"},{"location":"examples/stochastic_all_blacks/","page":"Stochastic All Blacks","title":"Stochastic All Blacks","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/stochastic_all_blacks/","page":"Stochastic All Blacks","title":"Stochastic All Blacks","text":"using SDDP, HiGHS, Test\n\nfunction stochastic_all_blacks()\n    # Number of time periods\n    T = 3\n    # Number of seats\n    N = 2\n    # R_ij = price of seat i at time j\n    R = [3 3 6; 3 3 6]\n    # Number of noises\n    s = 3\n    offers = [\n        [[1, 1], [0, 0], [1, 1]],\n        [[1, 0], [0, 0], [0, 0]],\n        [[0, 1], [1, 0], [1, 1]],\n    ]\n\n    model = SDDP.LinearPolicyGraph(\n        stages = T,\n        sense = :Max,\n        upper_bound = 100.0,\n        optimizer = HiGHS.Optimizer,\n    ) do sp, stage\n        # Seat remaining?\n        @variable(sp, 0 <= x[1:N] <= 1, SDDP.State, Bin, initial_value = 1)\n        # Action: accept offer, or don't accept offer\n        # We are allowed to accept some of the seats offered but not others\n        @variable(sp, accept_offer[1:N], Bin)\n        @variable(sp, offers_made[1:N])\n        # Balance on seats\n        @constraint(\n            sp,\n            balance[i in 1:N],\n            x[i].in - x[i].out == accept_offer[i]\n        )\n        @stageobjective(sp, sum(R[i, stage] * accept_offer[i] for i in 1:N))\n        SDDP.parameterize(sp, offers[stage]) do o\n            return JuMP.fix.(offers_made, o)\n        end\n        @constraint(sp, accept_offer .<= offers_made)\n    end\n\n    SDDP.train(model; duality_handler = SDDP.LagrangianDuality())\n    @test SDDP.calculate_bound(model) ≈ 8.0\n    return\nend\n\nstochastic_all_blacks()","category":"page"},{"location":"examples/stochastic_all_blacks/","page":"Stochastic All Blacks","title":"Stochastic All Blacks","text":"","category":"page"},{"location":"examples/stochastic_all_blacks/","page":"Stochastic All Blacks","title":"Stochastic All Blacks","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/tutorial/example_milk_producer.jl\"","category":"page"},{"location":"tutorial/example_milk_producer/#Example:-the-milk-producer","page":"Example: the milk producer","title":"Example: the milk producer","text":"","category":"section"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"The purpose of this tutorial is to demonstrate how to fit a Markovian policy graph to a univariate stochastic process.","category":"page"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"This tutorial uses the following packages:","category":"page"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"using SDDP\nimport HiGHS\nimport Plots","category":"page"},{"location":"tutorial/example_milk_producer/#Background","page":"Example: the milk producer","title":"Background","text":"","category":"section"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"A company produces milk for sale on a spot market each month. The quantity of milk they produce is uncertain, and so too is the price on the spot market.","category":"page"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"The company can store the milk, but, over time, some milk spoils and must be discarded. Eventually the milk expires and is worthless.","category":"page"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"The spot price is determined by an auction system, and so varies from month to month, but demonstrates serial correlation. In each auction, there is sufficient demand that the milk producer finds a buyer for all their widgets, regardless of the quantity they supply. Furthermore, the spot price is independent of the milk producer (they are a small player in the market).","category":"page"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"The spot price is highly volatile, and is the result of a process that is out of the control of the company. To counteract their price risk, the company engages in a forward contracting programme.","category":"page"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"The forward contracting programme is a deal for physical milk at a future date in time, up to four months in the future.","category":"page"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"The futures price is the current spot price, plus some forward contango (the buyers gain certainty that they will receive the milk in the future).","category":"page"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"In general, the milk company should forward contract (since they reduce their price risk), however they also have production risk. Therefore, it may be the case that they forward contract a fixed amount, but find that they do not produce enough milk to meet the fixed demand. They are then forced to buy additional milk on the spot market.","category":"page"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"The goal of the milk company is to choose the extent to which they forward contract in order to maximise (risk-adjusted) revenues, whilst managing their production risk.","category":"page"},{"location":"tutorial/example_milk_producer/#A-stochastic-process-for-price","page":"Example: the milk producer","title":"A stochastic process for price","text":"","category":"section"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"It is outside the scope of this tutorial, but assume that we have gone away and analysed historical data to fit a stochastic process to the sequence of monthly auction spot prices.","category":"page"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"One plausible model is a multiplicative auto-regressive model of order one, where the white noise term is modeled by a finite distribution of empirical residuals. We can simulate this stochastic process as follows:","category":"page"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"function simulator()\n    residuals = [0.0987, 0.199, 0.303, 0.412, 0.530, 0.661, 0.814, 1.010, 1.290]\n    residuals = 0.1 * vcat(-residuals, 0.0, residuals)\n    scenario = zeros(12)\n    y, μ, α = 4.5, 6.0, 0.05\n    for t in 1:12\n        y = exp((1 - α) * log(y) + α * log(μ) + rand(residuals))\n        scenario[t] = clamp(y, 3.0, 9.0)\n    end\n    return scenario\nend\n\nsimulator()","category":"page"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"It may be helpful to visualize a number of simulations of the price process:","category":"page"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"plot = Plots.plot(\n    [simulator() for _ in 1:500];\n    color = \"gray\",\n    opacity = 0.2,\n    legend = false,\n    xlabel = \"Month\",\n    ylabel = \"Price [\\$/kg]\",\n    xlims = (1, 12),\n    ylims = (3, 9),\n)","category":"page"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"The prices gradually revert to the mean of $6/kg, and there is high volatility.","category":"page"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"We can't incorporate this price process directly into SDDP.jl, but we can fit a SDDP.MarkovianGraph directly from the simulator:","category":"page"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"graph = SDDP.MarkovianGraph(simulator; budget = 60, scenarios = 10_000);\nnothing  # hide","category":"page"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"Here budget is the number of nodes in the policy graph, and scenarios is the number of simulations to use when estimating the transition probabilities.","category":"page"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"The graph contains too many nodes to be show, but we can plot it:","category":"page"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"for ((t, price), edges) in graph.nodes\n    for ((t′, price′), probability) in edges\n        Plots.plot!(\n            plot,\n            [t, t′],\n            [price, price′];\n            color = \"red\",\n            width = 3 * probability,\n        )\n    end\nend\n\nplot","category":"page"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"That looks okay. Try changing budget and scenarios to see how different Markovian policy graphs can be created.","category":"page"},{"location":"tutorial/example_milk_producer/#Model","page":"Example: the milk producer","title":"Model","text":"","category":"section"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"Now that we have a Markovian graph, we can build the model. See if you can work out how we arrived at this formulation by reading the background description. Do all the variables and constraints make sense?","category":"page"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"model = SDDP.PolicyGraph(\n    graph;\n    sense = :Max,\n    upper_bound = 1e4,\n    optimizer = HiGHS.Optimizer,\n) do sp, node\n    t, price = node\n    c_contango = [1.0, 1.025, 1.05, 1.075]\n    c_transaction, c_perish_factor, c_buy_premium = 0.01, 0.95, 1.5\n    F, P = length(c_contango), 5\n    @variable(sp, 0 <= x_forward[1:F], SDDP.State, initial_value = 0)\n    @variable(sp, 0 <= x_stock[p = 1:P], SDDP.State, initial_value = 0)\n    @variable(sp, 0 <= u_spot_sell[1:P])\n    @variable(sp, 0 <= u_spot_buy)\n    @variable(sp, 0 <= u_forward_deliver[1:P])\n    @variable(sp, 0 <= u_forward_sell[1:F] <= 10)\n    @variable(sp, 0 <= u_production)\n    for f in 1:F\n        if t + f >= 12\n            fix(u_forward_sell[f], 0.0; force = true)\n        end\n    end\n    @constraint(\n        sp,\n        [i = 1:F-1],\n        x_forward[i].out == x_forward[i+1].in + u_forward_sell[i],\n    )\n    @constraint(sp, x_forward[F].out == u_forward_sell[F])\n    @constraint(sp, x_forward[1].in == sum(u_forward_deliver))\n    @constraint(\n        sp,\n        x_stock[1].out ==\n        u_production - u_forward_deliver[1] - u_spot_sell[1] + u_spot_buy\n    )\n    @constraint(\n        sp,\n        [i = 2:P],\n        x_stock[i].out ==\n        c_perish_factor * x_stock[i-1].in - u_forward_deliver[i] -\n        u_spot_sell[i]\n    )\n    Ω = [(price, (production = p,)) for p in range(0.1, 0.2; length = 5)]\n    SDDP.parameterize(sp, Ω) do (price, ω)\n        set_upper_bound(u_production, ω.production)\n        @stageobjective(\n            sp,\n            price * sum(u_spot_sell) +\n            price * sum(c_contango[f] * u_forward_sell[f] for f in 1:F) -\n            price * c_buy_premium * u_spot_buy -\n            c_transaction * sum(u_forward_sell)\n        )\n    end\nend","category":"page"},{"location":"tutorial/example_milk_producer/#Training-a-policy","page":"Example: the milk producer","title":"Training a policy","text":"","category":"section"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"Now we have a model, we train a policy. The SDDP.SimulatorSamplingScheme is used in the forward pass. It generates an out-of-sample sequence of prices using simulator and traverses the closest sequence of nodes in the policy graph. When calling SDDP.parameterize for each subproblem, it uses the new out-of-sample price instead of the price associated with the Markov node.","category":"page"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"SDDP.train(\n    model;\n    time_limit = 20,\n    risk_measure = SDDP.EAVaR(; lambda = 0.5, beta = 0.25),\n    sampling_scheme = SDDP.SimulatorSamplingScheme(simulator),\n)","category":"page"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"warning: Warning\nWe're intentionally terminating the training early so that the documentation doesn't take too long to build. If you run this example locally, increase the time limit.","category":"page"},{"location":"tutorial/example_milk_producer/#Simulating-the-policy","page":"Example: the milk producer","title":"Simulating the policy","text":"","category":"section"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"When simulating the policy, we can also use the SDDP.SimulatorSamplingScheme.","category":"page"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"simulations = SDDP.simulate(\n    model,\n    200,\n    Symbol[:x_forward, :x_stock, :u_spot_sell, :u_spot_buy];\n    sampling_scheme = SDDP.SimulatorSamplingScheme(simulator),\n);\nnothing  # hide","category":"page"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"To show how the sampling scheme uses the new out-of-sample price instead of the price associated with the Markov node, compare the index of the Markov state visited in stage 12 of the first simulation:","category":"page"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"simulations[1][12][:node_index]","category":"page"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"to the realization of the noise (price, ω) passed to SDDP.parameterize:","category":"page"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"simulations[1][12][:noise_term]","category":"page"},{"location":"tutorial/example_milk_producer/#Visualizing-the-policy","page":"Example: the milk producer","title":"Visualizing the policy","text":"","category":"section"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"Finally, we can plot the policy to gain insight (although note that we terminated the training early, so we should run the re-train the policy for more iterations before making too many judgements).","category":"page"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"Plots.plot(\n    SDDP.publication_plot(simulations; title = \"sum(x_stock.out)\") do data\n        return sum(y.out for y in data[:x_stock])\n    end,\n    SDDP.publication_plot(simulations; title = \"sum(x_forward.out)\") do data\n        return sum(y.out for y in data[:x_forward])\n    end,\n    SDDP.publication_plot(simulations; title = \"u_spot_buy\") do data\n        return data[:u_spot_buy]\n    end,\n    SDDP.publication_plot(simulations; title = \"sum(u_spot_sell)\") do data\n        return sum(data[:u_spot_sell])\n    end;\n    layout = (2, 2),\n)","category":"page"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"","category":"page"},{"location":"tutorial/example_milk_producer/","page":"Example: the milk producer","title":"Example: the milk producer","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/FAST_production_management/","page":"FAST: the production management problem","title":"FAST: the production management problem","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/examples/FAST_production_management.jl\"","category":"page"},{"location":"examples/FAST_production_management/#FAST:-the-production-management-problem","page":"FAST: the production management problem","title":"FAST: the production management problem","text":"","category":"section"},{"location":"examples/FAST_production_management/","page":"FAST: the production management problem","title":"FAST: the production management problem","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/FAST_production_management/","page":"FAST: the production management problem","title":"FAST: the production management problem","text":"An implementation of the Production Management example from FAST","category":"page"},{"location":"examples/FAST_production_management/","page":"FAST: the production management problem","title":"FAST: the production management problem","text":"using SDDP, HiGHS, Test\n\nfunction fast_production_management(; cut_type)\n    DEMAND = [2, 10]\n    H = 3\n    N = 2\n    C = [0.2, 0.7]\n    S = 2 .+ [0.33, 0.54]\n    model = SDDP.LinearPolicyGraph(;\n        stages = H,\n        lower_bound = -50.0,\n        optimizer = HiGHS.Optimizer,\n    ) do sp, t\n        @variable(sp, x[1:N] >= 0, SDDP.State, initial_value = 0.0)\n        @variables(sp, begin\n            s[i = 1:N] >= 0\n            d\n        end)\n        @constraints(sp, begin\n            [i = 1:N], s[i] <= x[i].in\n            sum(s) <= d\n        end)\n        SDDP.parameterize(sp, t == 1 ? [0] : DEMAND) do ω\n            return JuMP.fix(d, ω)\n        end\n        @stageobjective(sp, sum(C[i] * x[i].out for i in 1:N) - S's)\n    end\n    SDDP.train(model; cut_type = cut_type, print_level = 2, log_frequency = 5)\n    @test SDDP.calculate_bound(model) ≈ -23.96 atol = 1e-2\nend\n\nfast_production_management(cut_type = SDDP.SINGLE_CUT)\nfast_production_management(cut_type = SDDP.MULTI_CUT)","category":"page"},{"location":"examples/FAST_production_management/","page":"FAST: the production management problem","title":"FAST: the production management problem","text":"","category":"page"},{"location":"examples/FAST_production_management/","page":"FAST: the production management problem","title":"FAST: the production management problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/tutorial/example_reservoir.jl\"","category":"page"},{"location":"tutorial/example_reservoir/#Example:-deterministic-to-stochastic","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"","category":"section"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"This tutorial was written by Oscar Dowson and Andy Philpott for the 2023 Winter School \"Planning under Uncertainty in Energy Markets,\" held March 26 to 31 in Geilo, Norway.","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"Download this tutorial as a notebook.","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"The purpose of this tutorial is to explain how we can go from a deterministic time-staged optimal control model in JuMP to a multistage stochastic optimization model in SDDP.jl. As a motivating problem, we consider the hydro-thermal problem with a single reservoir.","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"For variations on this problem, see the examples and tutorials:","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"An introduction to SDDP.jl\nHydro-thermal scheduling\nHydro valleys\nInfinite horizon hydro-thermal","category":"page"},{"location":"tutorial/example_reservoir/#Packages","page":"Example: deterministic to stochastic","title":"Packages","text":"","category":"section"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"This tutorial requires the following packages:","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"using JuMP\nusing SDDP\nimport CSV\nimport DataFrames\nimport HiGHS\nimport Plots","category":"page"},{"location":"tutorial/example_reservoir/#Data","page":"Example: deterministic to stochastic","title":"Data","text":"","category":"section"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"The data for this tutorial is contained in the example_reservoir.csv file in the SDDP.jl repository. To run locally, download the CSV file, then change filename to point to the location where you downloaded it to.","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"filename = joinpath(@__DIR__, \"example_reservoir.csv\")\ndata = CSV.read(filename, DataFrames.DataFrame)","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"It's easier to visualize the data if we plot it:","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"Plots.plot(\n    Plots.plot(data[!, :inflow], ylabel = \"Inflow\"),\n    Plots.plot(data[!, :demand], ylabel = \"Demand\"),\n    Plots.plot(data[!, :cost], ylabel = \"Cost\", xlabel = \"Week\");\n    layout = (3, 1),\n    legend = false,\n)","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"The number of weeks will be useful later:","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"T = size(data, 1)","category":"page"},{"location":"tutorial/example_reservoir/#Deterministic-JuMP-model","page":"Example: deterministic to stochastic","title":"Deterministic JuMP model","text":"","category":"section"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"To start, we construct a deterministic model in pure JuMP.","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"Create a JuMP model, using HiGHS as the optimizer:","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"model = Model(HiGHS.Optimizer)\nset_silent(model)","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"x[t]: the amount of water in the reservoir at the start of stage t:","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"reservoir_max = 320.0\n@variable(model, 0 <= x[1:T+1] <= reservoir_max)","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"We need an initial condition for x[1]. Fix it to 300 units:","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"reservoir_initial = 300\nfix(x[1], reservoir_initial; force = true)","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"u[t]: the amount of water to flow through the turbine in stage t:","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"flow_max = 12\n@variable(model, 0 <= u[i = 1:T] <= flow_max)","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"s[t]: the amount of water to spill from the reservoir in stage t, bypassing the turbine:","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"@variable(model, 0 <= s[1:T])","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"r[t]: the amount of thermal generation in stage t:","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"@variable(model, 0 <= r[1:T])","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"i[t]: the amount of inflow to the reservoir in stage t:","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"@variable(model, i[1:T])","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"For this model, our inflow is fixed, so we fix it to the data we have:","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"for t in 1:T\n    fix(i[t], data[t, :inflow])\nend","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"The water balance constraint says that the water in the reservoir at the start of stage t+1 is the water in the reservoir at the start of stage t, less the amount flowed through the turbine, u[t], less the amount spilled, s[t], plus the amount of inflow, i[t], into the reservoir:","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"@constraint(model, [t = 1:T], x[t+1] == x[t] - u[t] - s[t] + i[t])","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"We also need a supply = demand constraint. In practice, the units of this would be in MWh, and there would be a conversion factor between the amount of water flowing through the turbine and the power output. To simplify, we assume that power and water have the same units, so that one \"unit\" of demand is equal to one \"unit\" of the reservoir x[t]:","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"@constraint(model, [t = 1:T], u[t] + r[t] == data[t, :demand])","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"Our objective is to minimize the cost of thermal generation:","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"@objective(model, Min, sum(data[t, :cost] * r[t] for t in 1:T))","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"Let's optimize and check the solution","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"optimize!(model)\nsolution_summary(model)","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"The total cost is:","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"objective_value(model)","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"Here's a plot of demand and generation:","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"Plots.plot(data[!, :demand]; label = \"Demand\", xlabel = \"Week\")\nPlots.plot!(value.(r), label = \"Thermal\")\nPlots.plot!(value.(u), label = \"Hydro\")","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"And here's the storage over time:","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"Plots.plot(value.(x); label = \"Storage\", xlabel = \"Week\")","category":"page"},{"location":"tutorial/example_reservoir/#Deterministic-SDDP-model","page":"Example: deterministic to stochastic","title":"Deterministic SDDP model","text":"","category":"section"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"For the next step, we show how to decompose our JuMP model into SDDP.jl. It should obtain the same solution!","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"model = SDDP.LinearPolicyGraph(\n    stages = T,\n    sense = :Min,\n    lower_bound = 0.0,\n    optimizer = HiGHS.Optimizer,\n) do subproblem, t\n    @variable(\n        subproblem,\n        0 <= x <= reservoir_max,\n        SDDP.State,\n        initial_value = reservoir_initial,\n    )\n    @variable(subproblem, 0 <= u <= flow_max)\n    @variable(subproblem, 0 <= r)\n    @variable(subproblem, 0 <= s)\n    @variable(subproblem, i)\n    fix(i, data[t, :inflow])\n    @constraint(subproblem, x.out == x.in - u - s + i)\n    @constraint(subproblem, u + r == data[t, :demand])\n    @stageobjective(subproblem, data[t, :cost] * r)\nend","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"Can you see how the JuMP model maps to this syntax? We have created a SDDP.LinearPolicyGraph with T stages, we're minimizing, and we're using HiGHS.Optimizer as the optimizer.","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"A few bits might be non-obvious:","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"We need to provide a lower bound for the objective function. Since our costs are always positive, a valid lower bound for the total cost is 0.0.\nWe define x as a state variable using SDDP.State. A state variable is any variable that flows through time, and for which we need to know the value of it in stage t-1 to compute the best action in stage t. The state variable x is actually two decision variables, x.in and x.out, which represent x[t] and x[t+1] respectively.\nWe need to use @stageobjective instead of @objective.","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"Instead of calling JuMP.optimize!, SDDP.jl uses a train method. With our machine learning hat on, you can think of SDDP.jl as training a function for each stage that accepts the current reservoir state as input and returns the optimal actions as output. It is also an iterative algorithm, so we need to specify when it should terminate:","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"SDDP.train(model; iteration_limit = 10)","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"As a quick sanity check, did we get the same cost as our JuMP model?","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"SDDP.calculate_bound(model)","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"That's good. Next, to check the value of the decision variables. This isn't as straight forward as our JuMP model. Instead, we need to simulate the policy, and then extract the values of the decision variables from the results of the simulation.","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"Since our model is deterministic, we need only 1 replication of the simulation, and we want to record the values of the x, u, and r variables:","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"n_replications = 1\nsimulations = SDDP.simulate(model, n_replications, [:x, :u, :r]);\n","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"The simulations vector is too big to show. But it contains one element for each replication, and each replication contains one dictionary for each stage.","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"For example, the data corresponding to the tenth stage in the first replication is:","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"simulations[1][10]","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"Let's grab the trace of the r and u variables in the first replication, and then plot them:","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"r_sim = [sim[:r] for sim in simulations[1]]\nu_sim = [sim[:u] for sim in simulations[1]]\n\nPlots.plot(data[!, :demand]; label = \"Demand\", xlabel = \"Week\")\nPlots.plot!(r_sim, label = \"Thermal\")\nPlots.plot!(u_sim, label = \"Hydro\")","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"Perfect. That's the same as we got before.","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"Now let's look at x. This is a little more complicated, because we need to grab the outgoing value of the state variable in each stage:","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"x_sim = [sim[:x].out for sim in simulations[1]]\n\nPlots.plot(x_sim; label = \"Storage\", xlabel = \"Week\")","category":"page"},{"location":"tutorial/example_reservoir/#Stochastic-SDDP-model","page":"Example: deterministic to stochastic","title":"Stochastic SDDP model","text":"","category":"section"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"Now we add some randomness to our model. In each stage, we assume that the inflow could be: 2 units lower, with 30% probability; the same as before, with 40% probability; or 5 units higher, with 30% probability.","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"model = SDDP.LinearPolicyGraph(\n    stages = T,\n    sense = :Min,\n    lower_bound = 0.0,\n    optimizer = HiGHS.Optimizer,\n) do sp, t\n    @variable(\n        sp,\n        0 <= x <= reservoir_max,\n        SDDP.State,\n        initial_value = reservoir_initial,\n    )\n    @variable(sp, 0 <= u <= flow_max)\n    @variable(sp, 0 <= r)\n    @variable(sp, 0 <= s)\n    @variable(sp, i)\n    # <--- This bit is new\n    Ω = [data[t, :inflow] - 2, data[t, :inflow], data[t, :inflow] + 5]\n    P = [0.3, 0.4, 0.3]\n    SDDP.parameterize(sp, Ω, P) do ω\n        fix(i, ω)\n        return\n    end\n    # --->\n    @constraint(sp, x.out == x.in - u - s + i)\n    @constraint(sp, u + r == data[t, :demand])\n    @stageobjective(sp, data[t, :cost] * r)\n    return\nend","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"Can you see the differences?","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"Let's train our new model. We need more iterations because of the stochasticity:","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"SDDP.train(model; iteration_limit = 100)","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"Now simulate the policy. This time we do 100 replications because the policy is now stochastic instead of deterministic:","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"n_replications = 100\nsimulations = SDDP.simulate(model, n_replications, [:x, :u, :r, :i]);\n","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"And let's plot the use of thermal generation in each replication:","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"plot = Plots.plot(data[!, :demand]; label = \"Demand\", xlabel = \"Week\")\nfor simulation in simulations\n    Plots.plot!(plot, [sim[:r] for sim in simulation], label = \"\")\nend\nplot","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"Viewing an interpreting static plots like this is difficult, particularly as the number of simulations grows. SDDP.jl includes an interactive SpaghettiPlot that makes things easier:","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"plot = SDDP.SpaghettiPlot(simulations)\nSDDP.add_spaghetti(plot; title = \"Storage\") do sim\n    return sim[:x].out\nend\nSDDP.add_spaghetti(plot; title = \"Hydro\") do sim\n    return sim[:u]\nend\nSDDP.add_spaghetti(plot; title = \"Inflow\") do sim\n    return sim[:i]\nend\nSDDP.plot(\n    plot,\n    \"spaghetti_plot.html\";\n    # We need this to build the documentation. Set to true if running locally.\n    open = false,\n)","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"<iframe src=\"../spaghetti_plot.html\" style=\"width:100%;height:500px;\"></iframe>","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"info: Info\nIf you have trouble viewing the plot, you can open it in a new window.","category":"page"},{"location":"tutorial/example_reservoir/#Next-steps","page":"Example: deterministic to stochastic","title":"Next steps","text":"","category":"section"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"Take this model and modify it following the suggestions below. The SDDP.jl documentation has a range of similar examples and hints for how to achieve them.","category":"page"},{"location":"tutorial/example_reservoir/#Terminal-value-functions","page":"Example: deterministic to stochastic","title":"Terminal value functions","text":"","category":"section"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"The model ends with an empty reservoir. That isn't ideal for the following year. Can you modify the objective in the final stage to encourage ending the year with a full reservoir?","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"You might write some variation of:","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"if t == 52\n    @variable(sp, terminal_cost_function >= 0)\n    @constraint(sp, terminal_cost_function >= reservoir_initial - x.out)\n    @stageobjective(sp, data[t, :cost] * r + terminal_cost_function)\nelse\n    @stageobjective(sp, data[t, :cost] * r)\nend","category":"page"},{"location":"tutorial/example_reservoir/#Higher-fidelity-modeling","page":"Example: deterministic to stochastic","title":"Higher fidelity modeling","text":"","category":"section"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"Our model is very basic. There are many aspects that we could improve:","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"Instead of hard-coding a terminal value function, can you solve an infinite horizon model? What are the differences?\nCan you add a second reservoir to make a river chain?\nCan you modify the problem and data to use proper units, including a conversion between the volume of water flowing through the turbine and the electrical power output?\nCan you add random demand or cost data as well as inflows?","category":"page"},{"location":"tutorial/example_reservoir/#Algorithmic-considerations","page":"Example: deterministic to stochastic","title":"Algorithmic considerations","text":"","category":"section"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"The algorithm implemented by SDDP.jl has a number of tuneable parameters:","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"Try using a different lower bound. What happens if it is too low, or too high?\nWas our stopping rule correct? What happens if we use fewer or more iterations? What other stopping rules could you try?\nCan you add a risk measure to make the policy risk-averse?","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"","category":"page"},{"location":"tutorial/example_reservoir/","page":"Example: deterministic to stochastic","title":"Example: deterministic to stochastic","text":"This page was generated using Literate.jl.","category":"page"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"CurrentModule = SDDP","category":"page"},{"location":"changelog/#Release-notes","page":"Release notes","title":"Release notes","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.","category":"page"},{"location":"changelog/#v1.6.0-(July-3,-2023)","page":"Release notes","title":"v1.6.0 (July 3, 2023)","text":"","category":"section"},{"location":"changelog/#Added","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added RegularizedForwardPass (#624)\nAdded FirstStageStoppingRule (#634)","category":"page"},{"location":"changelog/#Other","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Removed an unbound type parameter (#632)\nFixed typo in docstring (#633)\nAdded Here-and-now and hazard-decision tutorial (#635)","category":"page"},{"location":"changelog/#v1.5.1-(June-30,-2023)","page":"Release notes","title":"v1.5.1 (June 30, 2023)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"This release contains a number of minor code changes, but it has a large impact on the content that is printed to screen. In particular, we now log periodically, instead of each iteration, and a \"good\" stopping rule is used as the default if none are specified. Try using SDDP.train(model) to see the difference.","category":"page"},{"location":"changelog/#Other-2","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed various typos in the documentation (#617)\nFixed printing test after changes in JuMP (#618)\nSet SimulationStoppingRule as the default stopping rule (#619)\nChanged the default logging frequency. Pass log_every_seconds = 0.0 to train to revert to the old behavior. (#620)\nAdded example usage with Distributions.jl (@slwu89) (#622)\nRemoved the numerical issue @warn (#627)\nImproved the quality of docstrings (#630)","category":"page"},{"location":"changelog/#v1.5.0-(May-14,-2023)","page":"Release notes","title":"v1.5.0 (May 14, 2023)","text":"","category":"section"},{"location":"changelog/#Added-2","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added the ability to use a different model for the forward pass. This is a novel feature that lets you train better policies when the model is non-convex or does not have a well-defined dual. See the Alternative forward models tutorial in which we train convex and non-convex formulations of the optimal power flow problem. (#611)","category":"page"},{"location":"changelog/#Other-3","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Updated missing changelog entries (#608)\nRemoved global variables (#610)\nConverted the Options struct to keyword arguments. This struct was a private implementation detail, but the change is breaking if you developed an extension to SDDP that touched these internals. (#612)\nFixed some typos (#613)","category":"page"},{"location":"changelog/#v1.4.0-(May-8,-2023)","page":"Release notes","title":"v1.4.0 (May 8, 2023)","text":"","category":"section"},{"location":"changelog/#Added-3","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added SDDP.SimulationStoppingRule (#598)\nAdded sampling_scheme argument to SDDP.write_to_file (#607)","category":"page"},{"location":"changelog/#Fixed","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed parsing of some MSPFormat files (#602) (#604)\nFixed printing in header (#605)","category":"page"},{"location":"changelog/#v1.3.0-(May-3,-2023)","page":"Release notes","title":"v1.3.0 (May 3, 2023)","text":"","category":"section"},{"location":"changelog/#Added-4","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added experimental support for SDDP.MSPFormat.read_from_file (#593)","category":"page"},{"location":"changelog/#Other-4","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Updated to StochOptFormat v0.3 (#600)","category":"page"},{"location":"changelog/#v1.2.1-(May-1,-2023)","page":"Release notes","title":"v1.2.1 (May 1, 2023)","text":"","category":"section"},{"location":"changelog/#Fixed-2","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed log_every_seconds (#597)","category":"page"},{"location":"changelog/#v1.2.0-(May-1,-2023)","page":"Release notes","title":"v1.2.0 (May 1, 2023)","text":"","category":"section"},{"location":"changelog/#Added-5","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added SDDP.SimulatorSamplingScheme (#594)\nAdded log_every_seconds argument to SDDP.train (#595)","category":"page"},{"location":"changelog/#Other-5","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Tweaked how the log is printed (#588)\nUpdated to StochOptFormat v0.2 (#592)","category":"page"},{"location":"changelog/#v1.1.4-(April-10,-2023)","page":"Release notes","title":"v1.1.4 (April 10, 2023)","text":"","category":"section"},{"location":"changelog/#Fixed-3","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Logs are now flushed every iteration (#584)","category":"page"},{"location":"changelog/#Other-6","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added docstrings to various functions (#581)\nMinor documentation updates (#580)\nClarified integrality documentation (#582)\nUpdated the README (#585)\nNumber of numerical issues is now printed to the log (#586)","category":"page"},{"location":"changelog/#v1.1.3-(April-2,-2023)","page":"Release notes","title":"v1.1.3 (April 2, 2023)","text":"","category":"section"},{"location":"changelog/#Other-7","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed typo in Example: deterministic to stochastic tutorial (#578)\nFixed typo in documentation of SDDP.simulate (#577)","category":"page"},{"location":"changelog/#v1.1.2-(March-18,-2023)","page":"Release notes","title":"v1.1.2 (March 18, 2023)","text":"","category":"section"},{"location":"changelog/#Other-8","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added Example: deterministic to stochastic tutorial (#572)","category":"page"},{"location":"changelog/#v1.1.1-(March-16,-2023)","page":"Release notes","title":"v1.1.1 (March 16, 2023)","text":"","category":"section"},{"location":"changelog/#Other-9","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed email in Project.toml\nAdded notebook to documentation tutorials (#571)","category":"page"},{"location":"changelog/#v1.1.0-(January-12,-2023)","page":"Release notes","title":"v1.1.0 (January 12, 2023)","text":"","category":"section"},{"location":"changelog/#Added-6","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added the node_name_parser argument to SDDP.write_cuts_to_file and added the option to skip nodes in SDDP.read_cuts_from_file (#565)","category":"page"},{"location":"changelog/#v1.0.0-(January-3,-2023)","page":"Release notes","title":"v1.0.0 (January 3, 2023)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Although we're bumping MAJOR version, this is a non-breaking release. Going forward:","category":"page"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"New features will bump the MINOR version\nBug fixes, maintenance, and documentation updates will bump the PATCH version\nWe will support only the Long Term Support (currently v1.6.7) and the latest patch (currently v1.8.4) releases of Julia. Updates to the LTS version will bump the MINOR version\nUpdates to the compat bounds of package dependencies will bump the PATCH version.","category":"page"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"We do not intend any breaking changes to the public API, which would require a new MAJOR release. The public API is everything defined in the documentation. Anything not in the documentation is considered private and may change in any PATCH release.","category":"page"},{"location":"changelog/#Added-7","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added num_nodes argument to SDDP.UnicyclicGraph (#562)\nAdded support for passing an optimizer to SDDP.Asynchronous (#545)","category":"page"},{"location":"changelog/#Other-10","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Updated Plotting tools to use live plots (#563)\nAdded vale as a linter (#565)\nImproved documentation for initializing a parallel scheme (#566)","category":"page"},{"location":"changelog/#v0.4.9-(January-3,-2023)","page":"Release notes","title":"v0.4.9 (January 3, 2023)","text":"","category":"section"},{"location":"changelog/#Added-8","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added SDDP.UnicyclicGraph (#556)","category":"page"},{"location":"changelog/#Other-11","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added tutorial on Markov Decision Processes (#556)\nAdded two-stage newsvendor tutorial (#557)\nRefactored the layout of the documentation (#554) (#555)\nUpdated copyright to 2023 (#558)\nFixed errors in the documentation (#561)","category":"page"},{"location":"changelog/#v0.4.8-(December-19,-2022)","page":"Release notes","title":"v0.4.8 (December 19, 2022)","text":"","category":"section"},{"location":"changelog/#Added-9","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added terminate_on_cycle option to SDDP.Historical (#549)\nAdded include_last_node option to SDDP.DefaultForwardPass (#547)","category":"page"},{"location":"changelog/#Fixed-4","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Reverted then fixed (#531) because it failed to account for problems with integer variables (#546) (#551)","category":"page"},{"location":"changelog/#v0.4.7-(December-17,-2022)","page":"Release notes","title":"v0.4.7 (December 17, 2022)","text":"","category":"section"},{"location":"changelog/#Added-10","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added initial_node support to InSampleMonteCarlo and OutOfSampleMonteCarlo (#535)","category":"page"},{"location":"changelog/#Fixed-5","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Rethrow InterruptException when solver is interrupted (#534)\nFixed numerical recovery when we need dual solutions (#531) (Thanks @bfpc)\nFixed re-using the dashboard = true option between solves (#538)\nFixed bug when no @stageobjective is set (now defaults to 0.0) (#539)\nFixed errors thrown when invalid inputs are provided to add_objective_state (#540)","category":"page"},{"location":"changelog/#Other-12","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Drop support for Julia versions prior to 1.6 (#533)\nUpdated versions of dependencies (#522) (#533)\nSwitched to HiGHS in the documentation and tests (#533)\nAdded license headers (#519)\nFixed link in air conditioning example (#521) (Thanks @conema)\nClarified variable naming in deterministic equivalent (#525) (Thanks @lucasprocessi)\nAdded this change log (#536)\nCuts are now written to model.cuts.json when numerical instability is discovered. This can aid debugging because it allows to you reload the cuts as of the iteration that caused the numerical issue (#537)","category":"page"},{"location":"changelog/#v0.4.6-(March-25,-2022)","page":"Release notes","title":"v0.4.6 (March 25, 2022)","text":"","category":"section"},{"location":"changelog/#Other-13","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Updated to JuMP v1.0 (#517)","category":"page"},{"location":"changelog/#v0.4.5-(March-9,-2022)","page":"Release notes","title":"v0.4.5 (March 9, 2022)","text":"","category":"section"},{"location":"changelog/#Fixed-6","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed issue with set_silent in a subproblem (#510)","category":"page"},{"location":"changelog/#Other-14","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed many typos (#500) (#501) (#506) (#511) (Thanks @bfpc)\nUpdate to JuMP v0.23 (#514)\nAdded auto-regressive tutorial (#507)","category":"page"},{"location":"changelog/#v0.4.4-(December-11,-2021)","page":"Release notes","title":"v0.4.4 (December 11, 2021)","text":"","category":"section"},{"location":"changelog/#Added-11","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added BanditDuality (#471)\nAdded benchmark scripts (#475) (#476) (#490)\nwrite_cuts_to_file now saves visited states (#468)","category":"page"},{"location":"changelog/#Fixed-7","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed BoundStalling in a deterministic policy (#470) (#474)\nFixed magnitude warning with zero coefficients (#483)","category":"page"},{"location":"changelog/#Other-15","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Improvements to LagrangianDuality (#481) (#482) (#487)\nImprovements to StrengthenedConicDuality (#486)\nSwitch to functional form for the tests (#478)\nFixed typos (#472) (Thanks @vfdev-5)\nUpdate to JuMP v0.22 (#498)","category":"page"},{"location":"changelog/#v0.4.3-(August-31,-2021)","page":"Release notes","title":"v0.4.3 (August 31, 2021)","text":"","category":"section"},{"location":"changelog/#Added-12","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added biobjective solver (#462)\nAdded forward_pass_callback (#466)","category":"page"},{"location":"changelog/#Other-16","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Update tutorials and documentation (#459) (#465)\nOrganize how paper materials are stored (#464)","category":"page"},{"location":"changelog/#v0.4.2-(August-24,-2021)","page":"Release notes","title":"v0.4.2 (August 24, 2021)","text":"","category":"section"},{"location":"changelog/#Fixed-8","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed a bug in Lagrangian duality (#457)","category":"page"},{"location":"changelog/#v0.4.1-(August-23,-2021)","page":"Release notes","title":"v0.4.1 (August 23, 2021)","text":"","category":"section"},{"location":"changelog/#Other-17","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Minor changes to our implementation of LagrangianDuality (#454) (#455)","category":"page"},{"location":"changelog/#v0.4.0-(August-17,-2021)","page":"Release notes","title":"v0.4.0 (August 17, 2021)","text":"","category":"section"},{"location":"changelog/#Breaking","page":"Release notes","title":"Breaking","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"A large refactoring for how we handle stochastic integer programs. This added support for things like SDDP.ContinuousConicDuality and SDDP.LagrangianDuality. It was breaking because we removed the integrality_handler argument to PolicyGraph. (#499) (#453)","category":"page"},{"location":"changelog/#Other-18","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Documentation improvements (#447) (#448) (#450)","category":"page"},{"location":"changelog/#v0.3.17-(July-6,-2021)","page":"Release notes","title":"v0.3.17 (July 6, 2021)","text":"","category":"section"},{"location":"changelog/#Added-13","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added SDDP.PSRSamplingScheme (#426)","category":"page"},{"location":"changelog/#Other-19","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Display more model attributes (#438)\nDocumentation improvements (#433) (#437) (#439)","category":"page"},{"location":"changelog/#v0.3.16-(June-17,-2021)","page":"Release notes","title":"v0.3.16 (June 17, 2021)","text":"","category":"section"},{"location":"changelog/#Added-14","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added SDDP.RiskAdjustedForwardPass (#413)\nAllow SDDP.Historical to sample sequentially (#420)","category":"page"},{"location":"changelog/#Other-20","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Update risk measure docstrings (#418)","category":"page"},{"location":"changelog/#v0.3.15-(June-1,-2021)","page":"Release notes","title":"v0.3.15 (June 1, 2021)","text":"","category":"section"},{"location":"changelog/#Added-15","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added SDDP.StoppingChain","category":"page"},{"location":"changelog/#Fixed-9","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed scoping bug in SDDP.@stageobjective (#407)\nFixed a bug when the initial point is infeasible (#411)\nSet subproblems to silent by default (#409)","category":"page"},{"location":"changelog/#Other-21","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Add JuliaFormatter (#412)\nDocumentation improvements (#406) (#408)","category":"page"},{"location":"changelog/#v0.3.14-(March-30,-2021)","page":"Release notes","title":"v0.3.14 (March 30, 2021)","text":"","category":"section"},{"location":"changelog/#Fixed-10","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed O(N^2) behavior in get_same_children (#393)","category":"page"},{"location":"changelog/#v0.3.13-(March-27,-2021)","page":"Release notes","title":"v0.3.13 (March 27, 2021)","text":"","category":"section"},{"location":"changelog/#Fixed-11","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed bug in print.jl\nFixed compat of Reexport (#388)","category":"page"},{"location":"changelog/#v0.3.12-(March-22,-2021)","page":"Release notes","title":"v0.3.12 (March 22, 2021)","text":"","category":"section"},{"location":"changelog/#Added-16","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added problem statistics to header (#385) (#386)","category":"page"},{"location":"changelog/#Fixed-12","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed subtypes in visualization (#384)","category":"page"},{"location":"changelog/#v0.3.11-(March-22,-2021)","page":"Release notes","title":"v0.3.11 (March 22, 2021)","text":"","category":"section"},{"location":"changelog/#Fixed-13","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed constructor in direct mode (#383)","category":"page"},{"location":"changelog/#Other-22","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fix documentation (#379)","category":"page"},{"location":"changelog/#v0.3.10-(February-23,-2021)","page":"Release notes","title":"v0.3.10 (February 23, 2021)","text":"","category":"section"},{"location":"changelog/#Fixed-14","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed seriescolor in publication plot (#376)","category":"page"},{"location":"changelog/#v0.3.9-(February-20,-2021)","page":"Release notes","title":"v0.3.9 (February 20, 2021)","text":"","category":"section"},{"location":"changelog/#Added-17","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Add option to simulate with different incoming state (#372)\nAdded warning for cuts with high dynamic range (#373)","category":"page"},{"location":"changelog/#Fixed-15","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed seriesalpha in publication plot (#375)","category":"page"},{"location":"changelog/#v0.3.8-(January-19,-2021)","page":"Release notes","title":"v0.3.8 (January 19, 2021)","text":"","category":"section"},{"location":"changelog/#Other-23","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Documentation improvements (#367) (#369) (#370)","category":"page"},{"location":"changelog/#v0.3.7-(January-8,-2021)","page":"Release notes","title":"v0.3.7 (January 8, 2021)","text":"","category":"section"},{"location":"changelog/#Other-24","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Documentation improvements (#362) (#363) (#365) (#366)\nBump copyright (#364)","category":"page"},{"location":"changelog/#v0.3.6-(December-17,-2020)","page":"Release notes","title":"v0.3.6 (December 17, 2020)","text":"","category":"section"},{"location":"changelog/#Other-25","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fix typos (#358)\nCollapse navigation bar in docs (#359)\nUpdate TagBot.yml (#361)","category":"page"},{"location":"changelog/#v0.3.5-(November-18,-2020)","page":"Release notes","title":"v0.3.5 (November 18, 2020)","text":"","category":"section"},{"location":"changelog/#Other-26","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Update citations (#348)\nSwitch to GitHub actions (#355)","category":"page"},{"location":"changelog/#v0.3.4-(August-25,-2020)","page":"Release notes","title":"v0.3.4 (August 25, 2020)","text":"","category":"section"},{"location":"changelog/#Added-18","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added non-uniform distributionally robust risk measure (#328)\nAdded numerical recovery functions (#330)\nAdded experimental StochOptFormat (#332) (#336) (#337) (#341) (#343) (#344)\nAdded entropic risk measure (#347)","category":"page"},{"location":"changelog/#Other-27","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Documentation improvements (#327) (#333) (#339) (#340)","category":"page"},{"location":"changelog/#v0.3.3-(June-19,-2020)","page":"Release notes","title":"v0.3.3 (June 19, 2020)","text":"","category":"section"},{"location":"changelog/#Added-19","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added asynchronous support for price and belief states (#325)\nAdded ForwardPass plug-in system (#320)","category":"page"},{"location":"changelog/#Fixed-16","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fix check for probabilities in Markovian graph (#322)","category":"page"},{"location":"changelog/#v0.3.2-(April-6,-2020)","page":"Release notes","title":"v0.3.2 (April 6, 2020)","text":"","category":"section"},{"location":"changelog/#Added-20","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added log_frequency argument to SDDP.train (#307)","category":"page"},{"location":"changelog/#Other-28","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Improve error message in deterministic equivalent (#312)\nUpdate to RecipesBase 1.0 (#313)","category":"page"},{"location":"changelog/#v0.3.1-(February-26,-2020)","page":"Release notes","title":"v0.3.1 (February 26, 2020)","text":"","category":"section"},{"location":"changelog/#Fixed-17","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed filename in integrality_handlers.jl (#304)","category":"page"},{"location":"changelog/#v0.3.0-(February-20,-2020)","page":"Release notes","title":"v0.3.0 (February 20, 2020)","text":"","category":"section"},{"location":"changelog/#Breaking-2","page":"Release notes","title":"Breaking","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Breaking changes to update to JuMP v0.21 (#300).","category":"page"},{"location":"changelog/#v0.2.4-(February-7,-2020)","page":"Release notes","title":"v0.2.4 (February 7, 2020)","text":"","category":"section"},{"location":"changelog/#Added-21","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added a counter for the number of total subproblem solves (#301)","category":"page"},{"location":"changelog/#Other-29","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Update formatter (#298)\nAdded tests (#299)","category":"page"},{"location":"changelog/#v0.2.3-(January-24,-2020)","page":"Release notes","title":"v0.2.3 (January 24, 2020)","text":"","category":"section"},{"location":"changelog/#Added-22","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added support for convex risk measures (#294)","category":"page"},{"location":"changelog/#Fixed-18","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed bug when subproblem is infeasible (#296)\nFixed bug in deterministic equivalent (#297)","category":"page"},{"location":"changelog/#Other-30","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added example from IJOC paper (#293)","category":"page"},{"location":"changelog/#v0.2.2-(January-10,-2020)","page":"Release notes","title":"v0.2.2 (January 10, 2020)","text":"","category":"section"},{"location":"changelog/#Fixed-19","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed flakey time limit in tests (#291)","category":"page"},{"location":"changelog/#Other-31","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Removed MathOptFormat.jl (#289)\nUpdate copyright (#290)","category":"page"},{"location":"changelog/#v0.2.1-(December-19,-2019)","page":"Release notes","title":"v0.2.1 (December 19, 2019)","text":"","category":"section"},{"location":"changelog/#Added-23","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added support for approximating a Markov lattice (#282) (#285)\nAdd tools for visualizing the value function (#272) (#286)\nWrite .mof.json files on error (#284)","category":"page"},{"location":"changelog/#Other-32","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Improve documentation (#281) (#283)\nUpdate tests for Julia 1.3 (#287)","category":"page"},{"location":"changelog/#v0.2.0-(December-16,-2019)","page":"Release notes","title":"v0.2.0 (December 16, 2019)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"This version added the asynchronous parallel implementation with a few minor breaking changes in how we iterated internally. It didn't break basic user-facing models, only implementations that implemented some of the extension features. It probably could have been a v1.1 release.","category":"page"},{"location":"changelog/#Added-24","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added asynchronous parallel implementation (#277)\nAdded roll-out algorithm for cyclic graphs (#279)","category":"page"},{"location":"changelog/#Other-33","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Improved error messages in PolicyGraph (#271)\nAdded JuliaFormatter (#273) (#276)\nFixed compat bounds (#274) (#278)\nAdded documentation for simulating non-standard graphs (#280)","category":"page"},{"location":"changelog/#v0.1.0-(October-17,-2019)","page":"Release notes","title":"v0.1.0 (October 17, 2019)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"A complete rewrite of SDDP.jl based on the policy graph framework. This was essentially a new package. It has minimal code in common with the previous implementation.","category":"page"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Development started on September 28, 2018 in Kokako.jl, and the code was merged into SDDP.jl on March 14, 2019.","category":"page"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"The pull request SDDP.jl#180 lists the 29 issues that the rewrite closed.","category":"page"},{"location":"changelog/#v0.0.1-(April-18,-2018)","page":"Release notes","title":"v0.0.1 (April 18, 2018)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Initial release. Development had been underway since January 22, 2016 in the StochDualDynamicProgram.jl repository. The last development commit there was April 5, 2017. Work then continued in this repository for a year before the first tagged release.","category":"page"},{"location":"tutorial/example_newsvendor/","page":"Example: Two-stage Newsvendor","title":"Example: Two-stage Newsvendor","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/tutorial/example_newsvendor.jl\"","category":"page"},{"location":"tutorial/example_newsvendor/#Example:-Two-stage-Newsvendor","page":"Example: Two-stage Newsvendor","title":"Example: Two-stage Newsvendor","text":"","category":"section"},{"location":"tutorial/example_newsvendor/","page":"Example: Two-stage Newsvendor","title":"Example: Two-stage Newsvendor","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorial/example_newsvendor/","page":"Example: Two-stage Newsvendor","title":"Example: Two-stage Newsvendor","text":"This example is based on the classical newsvendor problem.","category":"page"},{"location":"tutorial/example_newsvendor/","page":"Example: Two-stage Newsvendor","title":"Example: Two-stage Newsvendor","text":"using SDDP\nimport HiGHS\nimport Plots","category":"page"},{"location":"tutorial/example_newsvendor/","page":"Example: Two-stage Newsvendor","title":"Example: Two-stage Newsvendor","text":"First, we need some discretized distribution of demand. For simplicity, we're going to sample 10 points from the uniform [0, 1) distribution three times and add them together. This is a rough approximation of a normal distribution.","category":"page"},{"location":"tutorial/example_newsvendor/","page":"Example: Two-stage Newsvendor","title":"Example: Two-stage Newsvendor","text":"Ω = rand(10) .+ rand(10) .+ rand(10)","category":"page"},{"location":"tutorial/example_newsvendor/","page":"Example: Two-stage Newsvendor","title":"Example: Two-stage Newsvendor","text":"We also need some price data. We assume the agent can buy a newspaper for $1 and sell it for $1.20.","category":"page"},{"location":"tutorial/example_newsvendor/","page":"Example: Two-stage Newsvendor","title":"Example: Two-stage Newsvendor","text":"buy_price, sales_price = 1.0, 1.2","category":"page"},{"location":"tutorial/example_newsvendor/","page":"Example: Two-stage Newsvendor","title":"Example: Two-stage Newsvendor","text":"Now we can formulate and train a policy for the two-stage newsvendor problem:","category":"page"},{"location":"tutorial/example_newsvendor/","page":"Example: Two-stage Newsvendor","title":"Example: Two-stage Newsvendor","text":"model = SDDP.LinearPolicyGraph(\n    stages = 2,\n    sense = :Max,\n    upper_bound = maximum(Ω) * sales_price,\n    optimizer = HiGHS.Optimizer,\n) do subproblem, stage\n    @variable(subproblem, inventory >= 0, SDDP.State, initial_value = 0)\n    if stage == 1\n        @variable(subproblem, buy >= 0)\n        @constraint(subproblem, inventory.out == inventory.in + buy)\n        @stageobjective(subproblem, -buy_price * buy)\n    else\n        @variable(subproblem, sell >= 0)\n        @constraint(subproblem, sell <= inventory.in)\n        SDDP.parameterize(subproblem, Ω) do ω\n            return JuMP.set_upper_bound(sell, ω)\n        end\n        @stageobjective(subproblem, sales_price * sell)\n    end\nend\n\nSDDP.train(model)","category":"page"},{"location":"tutorial/example_newsvendor/","page":"Example: Two-stage Newsvendor","title":"Example: Two-stage Newsvendor","text":"To check the first-stage buy decision, we need to obtain a decision rule for the first-stage node 1:","category":"page"},{"location":"tutorial/example_newsvendor/","page":"Example: Two-stage Newsvendor","title":"Example: Two-stage Newsvendor","text":"first_stage_rule = SDDP.DecisionRule(model, node = 1)","category":"page"},{"location":"tutorial/example_newsvendor/","page":"Example: Two-stage Newsvendor","title":"Example: Two-stage Newsvendor","text":"Then we can evaluate it, passing in a starting point for the incoming state:","category":"page"},{"location":"tutorial/example_newsvendor/","page":"Example: Two-stage Newsvendor","title":"Example: Two-stage Newsvendor","text":"solution = SDDP.evaluate(\n    first_stage_rule;\n    incoming_state = Dict(:inventory => 0.0),\n    controls_to_record = [:buy],\n)","category":"page"},{"location":"tutorial/example_newsvendor/","page":"Example: Two-stage Newsvendor","title":"Example: Two-stage Newsvendor","text":"The optimal value of the buy variable is stored here:","category":"page"},{"location":"tutorial/example_newsvendor/","page":"Example: Two-stage Newsvendor","title":"Example: Two-stage Newsvendor","text":"solution.controls[:buy]","category":"page"},{"location":"tutorial/example_newsvendor/#Introducing-risk","page":"Example: Two-stage Newsvendor","title":"Introducing risk","text":"","category":"section"},{"location":"tutorial/example_newsvendor/","page":"Example: Two-stage Newsvendor","title":"Example: Two-stage Newsvendor","text":"The solution of a single newsvendor problem offers little insight about how a decision-maker should act. In particular, they may be averse to bad outcomes, such as when they purchase a larger number of newspapers only for there to be little demand.","category":"page"},{"location":"tutorial/example_newsvendor/","page":"Example: Two-stage Newsvendor","title":"Example: Two-stage Newsvendor","text":"We can explore how the optimal decision changes with risk by creating a function:","category":"page"},{"location":"tutorial/example_newsvendor/","page":"Example: Two-stage Newsvendor","title":"Example: Two-stage Newsvendor","text":"function solve_risk_averse_newsvendor(Ω, risk_measure)\n    model = SDDP.LinearPolicyGraph(\n        stages = 2,\n        sense = :Max,\n        upper_bound = maximum(Ω) * sales_price,\n        optimizer = HiGHS.Optimizer,\n    ) do subproblem, stage\n        @variable(subproblem, inventory >= 0, SDDP.State, initial_value = 0)\n        if stage == 1\n            @variable(subproblem, buy >= 0)\n            @constraint(subproblem, inventory.out == inventory.in + buy)\n            @stageobjective(subproblem, -buy_price * buy)\n        else\n            @variable(subproblem, sell >= 0)\n            @constraint(subproblem, sell <= inventory.in)\n            SDDP.parameterize(subproblem, Ω) do ω\n                return JuMP.set_upper_bound(sell, ω)\n            end\n            @stageobjective(subproblem, sales_price * sell)\n        end\n    end\n    SDDP.train(model; risk_measure = risk_measure, print_level = 0)\n    first_stage_rule = SDDP.DecisionRule(model, node = 1)\n    solution = SDDP.evaluate(\n        first_stage_rule;\n        incoming_state = Dict(:inventory => 0.0),\n        controls_to_record = [:buy],\n    )\n    return solution.controls[:buy]\nend","category":"page"},{"location":"tutorial/example_newsvendor/","page":"Example: Two-stage Newsvendor","title":"Example: Two-stage Newsvendor","text":"Now we can see how many units a risk-neutral decision maker would order:","category":"page"},{"location":"tutorial/example_newsvendor/","page":"Example: Two-stage Newsvendor","title":"Example: Two-stage Newsvendor","text":"solve_risk_averse_newsvendor(Ω, SDDP.Expectation())","category":"page"},{"location":"tutorial/example_newsvendor/","page":"Example: Two-stage Newsvendor","title":"Example: Two-stage Newsvendor","text":"as well as a decision-maker who cares only about the worst-case outcome:","category":"page"},{"location":"tutorial/example_newsvendor/","page":"Example: Two-stage Newsvendor","title":"Example: Two-stage Newsvendor","text":"solve_risk_averse_newsvendor(Ω, SDDP.WorstCase())","category":"page"},{"location":"tutorial/example_newsvendor/","page":"Example: Two-stage Newsvendor","title":"Example: Two-stage Newsvendor","text":"In general, the decision-maker will be somewhere between the two extremes. The SDDP.Entropic risk measure is a risk measure that has a single parameter that lets us explore the space of policies between the two extremes. When the parameter is small, the measure acts like SDDP.Expectation, and when it is large, it acts like SDDP.WorstCase.","category":"page"},{"location":"tutorial/example_newsvendor/","page":"Example: Two-stage Newsvendor","title":"Example: Two-stage Newsvendor","text":"Here is what we get if we solve our problem multiple times for different values of the risk aversion parameter gamma:","category":"page"},{"location":"tutorial/example_newsvendor/","page":"Example: Two-stage Newsvendor","title":"Example: Two-stage Newsvendor","text":"Γ = [10^i for i in -3:0.2:3]\nbuy = [solve_risk_averse_newsvendor(Ω, SDDP.Entropic(γ)) for γ in Γ]\nPlots.plot(\n    Γ,\n    buy;\n    xaxis = :log,\n    xlabel = \"Risk aversion parameter γ\",\n    ylabel = \"First-stage buy decision\",\n    legend = false,\n)","category":"page"},{"location":"tutorial/example_newsvendor/#Things-to-try","page":"Example: Two-stage Newsvendor","title":"Things to try","text":"","category":"section"},{"location":"tutorial/example_newsvendor/","page":"Example: Two-stage Newsvendor","title":"Example: Two-stage Newsvendor","text":"There are a number of things you can try next:","category":"page"},{"location":"tutorial/example_newsvendor/","page":"Example: Two-stage Newsvendor","title":"Example: Two-stage Newsvendor","text":"Experiment with different buy and sales prices\nExperiment with different distributions of demand\nExplore how the optimal policy changes if you use a different risk measure\nWhat happens if you can only buy and sell integer numbers of newspapers? Try this by adding Int to the variable definitions: @variable(subproblem, buy >= 0, Int)","category":"page"},{"location":"tutorial/example_newsvendor/","page":"Example: Two-stage Newsvendor","title":"Example: Two-stage Newsvendor","text":"","category":"page"},{"location":"tutorial/example_newsvendor/","page":"Example: Two-stage Newsvendor","title":"Example: Two-stage Newsvendor","text":"This page was generated using Literate.jl.","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/explanation/theory_intro.jl\"","category":"page"},{"location":"explanation/theory_intro/#Introductory-theory","page":"Introductory theory","title":"Introductory theory","text":"","category":"section"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"(Image: ) (Image: )","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"note: Note\nThis tutorial is aimed at advanced undergraduates or early-stage graduate students. You don't need prior exposure to stochastic programming! (Indeed, it may be better if you don't, because our approach is non-standard in the literature.)This tutorial is also a living document. If parts are unclear, please open an issue so it can be improved!","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"This tutorial will teach you how the stochastic dual dynamic programming algorithm works by implementing a simplified version of the algorithm.","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"Our implementation is very much a \"vanilla\" version of SDDP; it doesn't have (m)any fancy computational tricks (e.g., the ones included in SDDP.jl) that you need to code a performant or stable version that will work on realistic instances. However, our simplified implementation will work on arbitrary policy graphs, including those with cycles such as infinite horizon problems!","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"Packages","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"This tutorial uses the following packages. For clarity, we call import PackageName so that we must prefix PackageName. to all functions and structs provided by that package. Everything not prefixed is either part of base Julia, or we wrote it.","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"import ForwardDiff\nimport HiGHS\nimport JuMP\nimport Statistics","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"tip: Tip\nYou can follow along by installing the above packages, and copy-pasting the code we will write into a Julia REPL. Alternatively, you can download the Julia .jl file which created this tutorial from GitHub.","category":"page"},{"location":"explanation/theory_intro/#Preliminaries:-background-theory","page":"Introductory theory","title":"Preliminaries: background theory","text":"","category":"section"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"Start this tutorial by reading An introduction to SDDP.jl, which introduces the necessary notation and vocabulary that we need for this tutorial.","category":"page"},{"location":"explanation/theory_intro/#Preliminaries:-Kelley's-cutting-plane-algorithm","page":"Introductory theory","title":"Preliminaries: Kelley's cutting plane algorithm","text":"","category":"section"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"Kelley's cutting plane algorithm is an iterative method for minimizing convex functions. Given a convex function f(x), Kelley's constructs an under-approximation of the function at the minimum by a set of first-order Taylor series approximations (called cuts) constructed at a set of points k = 1ldotsK:","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"beginaligned\nf^K = minlimits_theta in mathbbR x in mathbbR^N   theta\n theta ge f(x_k) + fracddxf(x_k)^top (x - x_k)quad k=1ldotsK\n theta ge M\nendaligned","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"where M is a sufficiently large negative number that is a lower bound for f over the domain of x.","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"Kelley's cutting plane algorithm is a structured way of choosing points x_k to visit, so that as more cuts are added:","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"lim_K rightarrow infty f^K = minlimits_x in mathbbR^N f(x)","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"However, before we introduce the algorithm, we need to introduce some bounds.","category":"page"},{"location":"explanation/theory_intro/#Bounds","page":"Introductory theory","title":"Bounds","text":"","category":"section"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"By convexity, f^K le f(x) for all x. Thus, if x^* is a minimizer of f, then at any point in time we can construct a lower bound for f(x^*) by solving f^K.","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"Moreover, we can use the primal solutions x_k^* returned by solving f^k to evaluate f(x_k^*) to generate an upper bound.","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"Therefore, f^K le f(x^*) le minlimits_k=1ldotsK f(x_k^*).","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"When the lower bound is sufficiently close to the upper bound, we can terminate the algorithm and declare that we have found an solution that is close to optimal.","category":"page"},{"location":"explanation/theory_intro/#Implementation","page":"Introductory theory","title":"Implementation","text":"","category":"section"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"Here is pseudo-code fo the Kelley algorithm:","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"Take as input a convex function f(x) and a iteration limit K_max. Set K = 0, and initialize f^K. Set lb = -infty and ub = infty.\nSolve f^K to obtain a candidate solution x_K+1.\nUpdate lb = f^K and ub = minub f(x_K+1).\nAdd a cut theta ge f(x_K+1) + fracddxfleft(x_K+1right)^top (x - x_K+1) to form f^K+1.\nIncrement K.\nIf K = K_max or ub - lb  epsilon, STOP, otherwise, go to step 2.","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"And here's a complete implementation:","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"function kelleys_cutting_plane(\n    # The function to be minimized.\n    f::Function,\n    # The gradient of `f`. By default, we use automatic differentiation to\n    # compute the gradient of f so the user doesn't have to!\n    dfdx::Function = x -> ForwardDiff.gradient(f, x);\n    # The number of arguments to `f`.\n    input_dimension::Int,\n    # A lower bound for the function `f` over its domain.\n    lower_bound::Float64,\n    # The number of iterations to run Kelley's algorithm for before stopping.\n    iteration_limit::Int,\n    # The absolute tolerance ϵ to use for convergence.\n    tolerance::Float64 = 1e-6,\n)\n    # Step (1):\n    K = 0\n    model = JuMP.Model(HiGHS.Optimizer)\n    JuMP.set_silent(model)\n    JuMP.@variable(model, θ >= lower_bound)\n    JuMP.@variable(model, x[1:input_dimension])\n    JuMP.@objective(model, Min, θ)\n    x_k = fill(NaN, input_dimension)\n    lower_bound, upper_bound = -Inf, Inf\n    while true\n        # Step (2):\n        JuMP.optimize!(model)\n        x_k .= JuMP.value.(x)\n        # Step (3):\n        lower_bound = JuMP.objective_value(model)\n        upper_bound = min(upper_bound, f(x_k))\n        println(\"K = $K : $(lower_bound) <= f(x*) <= $(upper_bound)\")\n        # Step (4):\n        JuMP.@constraint(model, θ >= f(x_k) + dfdx(x_k)' * (x .- x_k))\n        # Step (5):\n        K = K + 1\n        # Step (6):\n        if K == iteration_limit\n            println(\"-- Termination status: iteration limit --\")\n            break\n        elseif abs(upper_bound - lower_bound) < tolerance\n            println(\"-- Termination status: converged --\")\n            break\n        end\n    end\n    println(\"Found solution: x_K = \", x_k)\n    return\nend","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"Let's run our algorithm to see what happens:","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"kelleys_cutting_plane(\n    input_dimension = 2,\n    lower_bound = 0.0,\n    iteration_limit = 20,\n) do x\n    return (x[1] - 1)^2 + (x[2] + 2)^2 + 1.0\nend","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"warning: Warning\nIt's hard to choose a valid lower bound! If you choose one too loose, the algorithm can take a long time to converge. However, if you choose one so tight that M  f(x^*), then you can obtain a suboptimal solution. For a deeper discussion of the implications for SDDP.jl, see Choosing an initial bound.","category":"page"},{"location":"explanation/theory_intro/#Preliminaries:-approximating-the-cost-to-go-term","page":"Introductory theory","title":"Preliminaries: approximating the cost-to-go term","text":"","category":"section"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"In the background theory section, we discussed how you could formulate an optimal policy to a multistage stochastic program using the dynamic programming recursion:","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"beginaligned\nV_i(x omega) = minlimits_barx x^prime u   C_i(barx u omega) + mathbbE_j in i^+ varphi in Omega_jV_j(x^prime varphi)\n x^prime = T_i(barx u omega) \n u in U_i(barx omega) \n barx = x\nendaligned","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"where our decision rule, pi_i(x omega), solves this optimization problem and returns a u^* corresponding to an optimal solution. Moreover, we alluded to the fact that the cost-to-go term (the nasty recursive expectation) makes this problem intractable to solve.","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"However, if, excluding the cost-to-go term (i.e., the SP formulation), V_i(x omega) can be formulated as a linear program (this also works for convex programs, but the math is more involved), then we can make some progress by noticing that x only appears as a right-hand side term of the fishing constraint barx = x.","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"Therefore, V_i(x cdot) is convex with respect to x for fixed omega. Moreover, if we implement the constraint barx = x by setting the lower- and upper bounds of barx to x, then the reduced cost of the decision variable barx is a subgradient of the function V_i with respect to x! (This is the algorithmic simplification that leads us to add barx and the fishing constraint barx = x.)","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"tip: Tip\nThe subproblem can have binary and integer variables, but you'll need to use Lagrangian duality to compute a subgradient!","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"Stochastic dual dynamic programming converts this problem into a tractable form by applying Kelley's cutting plane algorithm to the V_j functions in the cost-to-go term:","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"beginaligned\nV_i^K(x omega) = minlimits_barx x^prime u   C_i(barx u omega) + theta\n x^prime = T_i(barx u omega) \n u in U_i(barx omega) \n barx = x \n theta ge mathbbE_j in i^+ varphi in Omega_jleftV_j^k(x^prime_k varphi) + fracddx^primeV_j^k(x^prime_k varphi)^top (x^prime - x^prime_k)rightquad k=1ldotsK \n theta ge M\nendaligned","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"All we need now is a way of generating these cutting planes in an iterative manner. Before we get to that though, let's start writing some code.","category":"page"},{"location":"explanation/theory_intro/#Implementation:-modeling","page":"Introductory theory","title":"Implementation: modeling","text":"","category":"section"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"Let's make a start by defining the problem structure. Like SDDP.jl, we need a few things:","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"A description of the structure of the policy graph: how many nodes there are, and the arcs linking the nodes together with their corresponding probabilities.\nA JuMP model for each node in the policy graph.\nA way to identify the incoming and outgoing state variables of each node.\nA description of the random variable, as well as a function that we can call that will modify the JuMP model to reflect the realization of the random variable.\nA decision variable to act as the approximated cost-to-go term.","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"warning: Warning\nIn the interests of brevity, there is minimal error checking. Think about all the different ways you could break the code!","category":"page"},{"location":"explanation/theory_intro/#Structs","page":"Introductory theory","title":"Structs","text":"","category":"section"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"The first struct we are going to use is a State struct that will wrap an incoming and outgoing state variable:","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"struct State\n    in::JuMP.VariableRef\n    out::JuMP.VariableRef\nend","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"Next, we need a struct to wrap all of the uncertainty within a node:","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"struct Uncertainty\n    parameterize::Function\n    Ω::Vector{Any}\n    P::Vector{Float64}\nend","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"parameterize is a function which takes a realization of the random variable omegainOmega and updates the subproblem accordingly. The finite discrete random variable is defined by the vectors Ω and P, so that the random variable takes the value Ω[i] with probability P[i]. As such, P should sum to 1. (We don't check this here, but we should; we do in SDDP.jl.)","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"Now we have two building blocks, we can declare the structure of each node:","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"struct Node\n    subproblem::JuMP.Model\n    states::Dict{Symbol,State}\n    uncertainty::Uncertainty\n    cost_to_go::JuMP.VariableRef\nend","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"subproblem is going to be the JuMP model that we build at each node.\nstates is a dictionary that maps a symbolic name of a state variable to a State object wrapping the incoming and outgoing state variables in subproblem.\nuncertainty is an Uncertainty object described above.\ncost_to_go is a JuMP variable that approximates the cost-to-go term.","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"Finally, we define a simplified policy graph as follows:","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"struct PolicyGraph\n    nodes::Vector{Node}\n    arcs::Vector{Dict{Int,Float64}}\nend","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"There is a vector of nodes, as well as a data structure for the arcs. arcs is a vector of dictionaries, where arcs[i][j] gives the probability of transitioning from node i to node j, if an arc exists.","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"To simplify things, we will assume that the root node transitions to node 1 with probability 1, and there are no other incoming arcs to node 1. Notably, we can still define cyclic graphs though!","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"We also define a nice show method so that we don't accidentally print a large amount of information to the screen when creating a model:","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"function Base.show(io::IO, model::PolicyGraph)\n    println(io, \"A policy graph with $(length(model.nodes)) nodes\")\n    println(io, \"Arcs:\")\n    for (from, arcs) in enumerate(model.arcs)\n        for (to, probability) in arcs\n            println(io, \"  $(from) => $(to) w.p. $(probability)\")\n        end\n    end\n    return\nend","category":"page"},{"location":"explanation/theory_intro/#Functions","page":"Introductory theory","title":"Functions","text":"","category":"section"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"Now we have some basic types, let's implement some functions so that the user can create a model.","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"First, we need an example of a function that the user will provide. Like SDDP.jl, this takes an empty subproblem, and a node index, in this case t::Int. You could change this function to change the model, or define a new one later in the code.","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"We're going to copy the example from An introduction to SDDP.jl, with some minor adjustments for the fact we don't have many of the bells and whistles of SDDP.jl. You can probably see how some of the SDDP.jl functionality like @stageobjective and SDDP.parameterize help smooth some of the usability issues like needing to construct both the incoming and outgoing state variables, or needing to explicitly declare return states, uncertainty.","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"function subproblem_builder(subproblem::JuMP.Model, t::Int)\n    # Define the state variables. Note how we fix the incoming state to the\n    # initial state variable regardless of `t`! This isn't strictly necessary;\n    # it only matters that we do it for the first node.\n    JuMP.@variable(subproblem, volume_in == 200)\n    JuMP.@variable(subproblem, 0 <= volume_out <= 200)\n    states = Dict(:volume => State(volume_in, volume_out))\n    # Define the control variables.\n    JuMP.@variables(subproblem, begin\n        thermal_generation >= 0\n        hydro_generation >= 0\n        hydro_spill >= 0\n        inflow\n    end)\n    # Define the constraints\n    JuMP.@constraints(\n        subproblem,\n        begin\n            volume_out == volume_in + inflow - hydro_generation - hydro_spill\n            demand_constraint, thermal_generation + hydro_generation == 150.0\n        end\n    )\n    # Define the objective for each stage `t`. Note that we can use `t` as an\n    # index for t = 1, 2, 3.\n    fuel_cost = [50.0, 100.0, 150.0]\n    JuMP.@objective(subproblem, Min, fuel_cost[t] * thermal_generation)\n    # Finally, we define the uncertainty object. Because this is a simplified\n    # implementation of SDDP, we shall politely ask the user to only modify the\n    # constraints, and not the objective function! (Not that it changes the\n    # algorithm, we just have to add more information to keep track of things.)\n    uncertainty = Uncertainty([0.0, 50.0, 100.0], [1 / 3, 1 / 3, 1 / 3]) do ω\n        return JuMP.fix(inflow, ω)\n    end\n    return states, uncertainty\nend","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"The next function we need to define is the analog of SDDP.PolicyGraph. It should be pretty readable.","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"function PolicyGraph(\n    subproblem_builder::Function;\n    graph::Vector{Dict{Int,Float64}},\n    lower_bound::Float64,\n    optimizer,\n)\n    nodes = Node[]\n    for t in 1:length(graph)\n        # Create a model.\n        model = JuMP.Model(optimizer)\n        JuMP.set_silent(model)\n        # Use the provided function to build out each subproblem. The user's\n        # function returns a dictionary mapping `Symbol`s to `State` objects,\n        # and an `Uncertainty` object.\n        states, uncertainty = subproblem_builder(model, t)\n        # Now add the cost-to-go terms:\n        JuMP.@variable(model, cost_to_go >= lower_bound)\n        obj = JuMP.objective_function(model)\n        JuMP.@objective(model, Min, obj + cost_to_go)\n        # If there are no outgoing arcs, the cost-to-go is 0.0.\n        if length(graph[t]) == 0\n            JuMP.fix(cost_to_go, 0.0; force = true)\n        end\n        push!(nodes, Node(model, states, uncertainty, cost_to_go))\n    end\n    return PolicyGraph(nodes, graph)\nend","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"Then, we can create a model using the subproblem_builder function we defined earlier:","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"model = PolicyGraph(\n    subproblem_builder;\n    graph = [Dict(2 => 1.0), Dict(3 => 1.0), Dict{Int,Float64}()],\n    lower_bound = 0.0,\n    optimizer = HiGHS.Optimizer,\n)","category":"page"},{"location":"explanation/theory_intro/#Implementation:-helpful-samplers","page":"Introductory theory","title":"Implementation: helpful samplers","text":"","category":"section"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"Before we get properly coding the solution algorithm, it's also going to be useful to have a function that samples a realization of the random variable defined by Ω and P.","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"function sample_uncertainty(uncertainty::Uncertainty)\n    r = rand()\n    for (p, ω) in zip(uncertainty.P, uncertainty.Ω)\n        r -= p\n        if r < 0.0\n            return ω\n        end\n    end\n    return error(\"We should never get here because P should sum to 1.0.\")\nend","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"note: Note\nrand() samples a uniform random variable in [0, 1).","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"For example:","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"for i in 1:3\n    println(\"ω = \", sample_uncertainty(model.nodes[1].uncertainty))\nend","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"It's also going to be useful to define a function that generates a random walk through the nodes of the graph:","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"function sample_next_node(model::PolicyGraph, current::Int)\n    if length(model.arcs[current]) == 0\n        # No outgoing arcs!\n        return nothing\n    else\n        r = rand()\n        for (to, probability) in model.arcs[current]\n            r -= probability\n            if r < 0.0\n                return to\n            end\n        end\n        # We looped through the outgoing arcs and still have probability left\n        # over! This means we've hit an implicit \"zero\" node.\n        return nothing\n    end\nend","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"For example:","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"for i in 1:3\n    # We use `repr` to print the next node, because `sample_next_node` can\n    # return `nothing`.\n    println(\"Next node from $(i) = \", repr(sample_next_node(model, i)))\nend","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"This is a little boring, because our graph is simple. However, more complicated graphs will generate more interesting trajectories!","category":"page"},{"location":"explanation/theory_intro/#Implementation:-the-forward-pass","page":"Introductory theory","title":"Implementation: the forward pass","text":"","category":"section"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"Recall that, after approximating the cost-to-go term, we need a way of generating the cuts. As the first step, we need a way of generating candidate solutions x_k^prime. However, unlike the Kelley's example, our functions V_j^k(x^prime varphi) need two inputs: an outgoing state variable and a realization of the random variable.","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"One way of getting these inputs is just to pick a random (feasible) value. However, in doing so, we might pick outgoing state variables that we will never see in practice, or we might infrequently pick outgoing state variables that we will often see in practice. Therefore, a better way of generating the inputs is to use a simulation of the policy, which we call the forward pass.","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"The forward pass walks the policy graph from start to end, transitioning randomly along the arcs. At each node, it observes a realization of the random variable and solves the approximated subproblem to generate a candidate outgoing state variable x_k^prime. The outgoing state variable is passed as the incoming state variable to the next node in the trajectory.","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"function forward_pass(model::PolicyGraph, io::IO = stdout)\n    println(io, \"| Forward Pass\")\n    # First, get the value of the state at the root node (e.g., x_R).\n    incoming_state =\n        Dict(k => JuMP.fix_value(v.in) for (k, v) in model.nodes[1].states)\n    # `simulation_cost` is an accumlator that is going to sum the stage-costs\n    # incurred over the forward pass.\n    simulation_cost = 0.0\n    # We also need to record the nodes visited and resultant outgoing state\n    # variables so we can pass them to the backward pass.\n    trajectory = Tuple{Int,Dict{Symbol,Float64}}[]\n    # Now's the meat of the forward pass: beginning at the first node:\n    t = 1\n    while t !== nothing\n        node = model.nodes[t]\n        println(io, \"| | Visiting node $(t)\")\n        # Sample the uncertainty:\n        ω = sample_uncertainty(node.uncertainty)\n        println(io, \"| | | ω = \", ω)\n        # Parameterizing the subproblem using the user-provided function:\n        node.uncertainty.parameterize(ω)\n        println(io, \"| | | x = \", incoming_state)\n        # Update the incoming state variable:\n        for (k, v) in incoming_state\n            JuMP.fix(node.states[k].in, v; force = true)\n        end\n        # Now solve the subproblem and check we found an optimal solution:\n        JuMP.optimize!(node.subproblem)\n        if JuMP.termination_status(node.subproblem) != JuMP.MOI.OPTIMAL\n            error(\"Something went terribly wrong!\")\n        end\n        # Compute the outgoing state variables:\n        outgoing_state = Dict(k => JuMP.value(v.out) for (k, v) in node.states)\n        println(io, \"| | | x′ = \", outgoing_state)\n        # We also need to compute the stage cost to add to our\n        # `simulation_cost` accumulator:\n        stage_cost =\n            JuMP.objective_value(node.subproblem) - JuMP.value(node.cost_to_go)\n        simulation_cost += stage_cost\n        println(io, \"| | | C(x, u, ω) = \", stage_cost)\n        # As a penultimate step, set the outgoing state of stage t and the\n        # incoming state of stage t + 1, and add the node to the trajectory.\n        incoming_state = outgoing_state\n        push!(trajectory, (t, outgoing_state))\n        # Finally, sample a new node to step to. If `t === nothing`, the\n        # `while` loop will break.\n        t = sample_next_node(model, t)\n    end\n    return trajectory, simulation_cost\nend","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"Let's take a look at one forward pass:","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"trajectory, simulation_cost = forward_pass(model);\n","category":"page"},{"location":"explanation/theory_intro/#Implementation:-the-backward-pass","page":"Introductory theory","title":"Implementation: the backward pass","text":"","category":"section"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"From the forward pass, we obtained a vector of nodes visited and their corresponding outgoing state variables. Now we need to refine the approximation for each node at the candidate solution for the outgoing state variable. That is, we need to add a new cut:","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"theta ge mathbbE_j in i^+ varphi in Omega_jleftV_j^k(x^prime_k varphi) + fracddx^primeV_j^k(x^prime_k varphi)^top (x^prime - x^prime_k)right","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"or alternatively:","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"theta ge sumlimits_j in i^+ sumlimits_varphi in Omega_j p_ij p_varphileftV_j^k(x^prime_k varphi) + fracddx^primeV_j^k(x^prime_k varphi)^top (x^prime - x^prime_k)right","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"It doesn't matter what order we visit the nodes to generate these cuts for. For example, we could compute them all in parallel, using the current approximations of V^K_i.","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"However, we can be smarter than that.","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"If we traverse the list of nodes visited in the forward pass in reverse, then we come to refine the i^th node in the trajectory, we will already have improved the approximation of the (i+1)^th node in the trajectory as well! Therefore, our refinement of the i^th node will be better than if we improved node i first, and then refined node (i+1).","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"Because we walk the nodes in reverse, we call this the backward pass.","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"info: Info\nIf you're into deep learning, you could view this as the equivalent of back-propagation: the forward pass pushes primal information through the graph (outgoing state variables), and the backward pass pulls dual information (cuts) back through the graph to improve our decisions on the next forward pass.","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"function backward_pass(\n    model::PolicyGraph,\n    trajectory::Vector{Tuple{Int,Dict{Symbol,Float64}}},\n    io::IO = stdout,\n)\n    println(io, \"| Backward pass\")\n    # For the backward pass, we walk back up the nodes.\n    for i in reverse(1:length(trajectory))\n        index, outgoing_states = trajectory[i]\n        node = model.nodes[index]\n        println(io, \"| | Visiting node $(index)\")\n        if length(model.arcs[index]) == 0\n            # If there are no children, the cost-to-go is 0.\n            println(io, \"| | | Skipping node because the cost-to-go is 0\")\n            continue\n        end\n        # Create an empty affine expression that we will use to build up the\n        # right-hand side of the cut expression.\n        cut_expression = JuMP.AffExpr(0.0)\n        # For each node j ∈ i⁺\n        for (j, P_ij) in model.arcs[index]\n            next_node = model.nodes[j]\n            # Set the incoming state variables of node j to the outgoing state\n            # variables of node i\n            for (k, v) in outgoing_states\n                JuMP.fix(next_node.states[k].in, v; force = true)\n            end\n            # Then for each realization of φ ∈ Ωⱼ\n            for (pφ, φ) in zip(next_node.uncertainty.P, next_node.uncertainty.Ω)\n                # Setup and solve for the realization of φ\n                println(io, \"| | | Solving φ = \", φ)\n                next_node.uncertainty.parameterize(φ)\n                JuMP.optimize!(next_node.subproblem)\n                # Then prepare the cut `P_ij * pφ * [V + dVdxᵀ(x - x_k)]``\n                V = JuMP.objective_value(next_node.subproblem)\n                println(io, \"| | | | V = \", V)\n                dVdx = Dict(\n                    k => JuMP.reduced_cost(v.in) for (k, v) in next_node.states\n                )\n                println(io, \"| | | | dVdx′ = \", dVdx)\n                cut_expression += JuMP.@expression(\n                    node.subproblem,\n                    P_ij *\n                    pφ *\n                    (\n                        V + sum(\n                            dVdx[k] * (x.out - outgoing_states[k]) for\n                            (k, x) in node.states\n                        )\n                    ),\n                )\n            end\n        end\n        # And then refine the cost-to-go variable by adding the cut:\n        c = JuMP.@constraint(node.subproblem, node.cost_to_go >= cut_expression)\n        println(io, \"| | | Adding cut : \", c)\n    end\n    return nothing\nend","category":"page"},{"location":"explanation/theory_intro/#Implementation:-bounds","page":"Introductory theory","title":"Implementation: bounds","text":"","category":"section"},{"location":"explanation/theory_intro/#Lower-bounds","page":"Introductory theory","title":"Lower bounds","text":"","category":"section"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"Recall from Kelley's that we can obtain a lower bound for f(x^*) be evaluating f^K. The analogous lower bound for a multistage stochastic program is:","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"mathbbE_i in R^+ omega in Omega_iV_i^K(x_R omega) le min_pi mathbbE_i in R^+ omega in Omega_iV_i^pi(x_R omega)","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"Here's how we compute the lower bound:","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"function lower_bound(model::PolicyGraph)\n    node = model.nodes[1]\n    bound = 0.0\n    for (p, ω) in zip(node.uncertainty.P, node.uncertainty.Ω)\n        node.uncertainty.parameterize(ω)\n        JuMP.optimize!(node.subproblem)\n        bound += p * JuMP.objective_value(node.subproblem)\n    end\n    return bound\nend","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"note: Note\nThe implementation is simplified because we assumed that there is only one arc from the root node, and that it pointed to the first node in the vector.","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"Because we haven't trained a policy yet, the lower bound is going to be very bad:","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"lower_bound(model)","category":"page"},{"location":"explanation/theory_intro/#Upper-bounds","page":"Introductory theory","title":"Upper bounds","text":"","category":"section"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"With Kelley's algorithm, we could easily construct an upper bound by evaluating f(x_K). However, it is almost always intractable to evaluate an upper bound for multistage stochastic programs due to the large number of nodes and the nested expectations. Instead, we can perform a Monte Carlo simulation of the policy to build a statistical estimate for the value of mathbbE_i in R^+ omega in Omega_iV_i^pi(x_R omega), where pi is the policy defined by the current approximations V^K_i.","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"function upper_bound(model::PolicyGraph; replications::Int)\n    # Pipe the output to `devnull` so we don't print too much!\n    simulations = [forward_pass(model, devnull) for i in 1:replications]\n    z = [s[2] for s in simulations]\n    μ = Statistics.mean(z)\n    tσ = 1.96 * Statistics.std(z) / sqrt(replications)\n    return μ, tσ\nend","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"note: Note\nThe width of the confidence interval is incorrect if there are cycles in the graph, because the distribution of simulation costs z is not symmetric. The mean is correct, however.","category":"page"},{"location":"explanation/theory_intro/#Termination-criteria","page":"Introductory theory","title":"Termination criteria","text":"","category":"section"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"In Kelley's algorithm, the upper bound was deterministic. Therefore, we could terminate the algorithm when the lower bound was sufficiently close to the upper bound. However, our upper bound for SDDP is not deterministic; it is a confidence interval!","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"Some people suggest terminating SDDP when the lower bound is contained within the confidence interval. However, this is a poor choice because it is too easy to generate a false positive. For example, if we use a small number of replications then the width of the confidence will be large, and we are more likely to terminate!","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"In a future tutorial (not yet written...) we will discuss termination criteria in more depth. For now, pick a large number of iterations and train for as long as possible.","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"tip: Tip\nFor a rule of thumb, pick a large number of iterations to train the policy for (e.g., 10 times mathcalN times maxlimits_iinmathcalN Omega_i)","category":"page"},{"location":"explanation/theory_intro/#Implementation:-the-training-loop","page":"Introductory theory","title":"Implementation: the training loop","text":"","category":"section"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"The train loop of SDDP just applies the forward and backward passes iteratively, followed by a final simulation to compute the upper bound confidence interval:","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"function train(\n    model::PolicyGraph;\n    iteration_limit::Int,\n    replications::Int,\n    io::IO = stdout,\n)\n    for i in 1:iteration_limit\n        println(io, \"Starting iteration $(i)\")\n        outgoing_states, _ = forward_pass(model, io)\n        backward_pass(model, outgoing_states, io)\n        println(io, \"| Finished iteration\")\n        println(io, \"| | lower_bound = \", lower_bound(model))\n    end\n    println(io, \"Termination status: iteration limit\")\n    μ, tσ = upper_bound(model; replications = replications)\n    println(io, \"Upper bound = $(μ) ± $(tσ)\")\n    return\nend","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"Using our model we defined earlier, we can go:","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"train(model; iteration_limit = 3, replications = 100)","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"Success! We trained a policy for a finite horizon multistage stochastic program using stochastic dual dynamic programming.","category":"page"},{"location":"explanation/theory_intro/#Implementation:-evaluating-the-policy","page":"Introductory theory","title":"Implementation: evaluating the policy","text":"","category":"section"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"A final step is the ability to evaluate the policy at a given point.","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"function evaluate_policy(\n    model::PolicyGraph;\n    node::Int,\n    incoming_state::Dict{Symbol,Float64},\n    random_variable,\n)\n    the_node = model.nodes[node]\n    the_node.uncertainty.parameterize(random_variable)\n    for (k, v) in incoming_state\n        JuMP.fix(the_node.states[k].in, v; force = true)\n    end\n    JuMP.optimize!(the_node.subproblem)\n    return Dict(\n        k => JuMP.value.(v) for\n        (k, v) in JuMP.object_dictionary(the_node.subproblem)\n    )\nend\n\nevaluate_policy(\n    model;\n    node = 1,\n    incoming_state = Dict(:volume => 150.0),\n    random_variable = 75,\n)","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"note: Note\nThe random variable can be out-of-sample, i.e., it doesn't have to be in the vector Omega we created when defining the model! This is a notable difference to other multistage stochastic solution methods like progressive hedging or using the deterministic equivalent.","category":"page"},{"location":"explanation/theory_intro/#Example:-infinite-horizon","page":"Introductory theory","title":"Example: infinite horizon","text":"","category":"section"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"As promised earlier, our implementation is actually pretty general. It can solve any multistage stochastic (linear) program defined by a policy graph, including infinite horizon problems!","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"Here's an example, where we have extended our earlier problem with an arc from node 3 to node 2 with probability 0.5. You can interpret the 0.5 as a discount factor.","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"model = PolicyGraph(\n    subproblem_builder;\n    graph = [Dict(2 => 1.0), Dict(3 => 1.0), Dict(2 => 0.5)],\n    lower_bound = 0.0,\n    optimizer = HiGHS.Optimizer,\n)","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"Then, train a policy:","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"train(model; iteration_limit = 3, replications = 100)","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"Success! We trained a policy for an infinite horizon multistage stochastic program using stochastic dual dynamic programming. Note how some of the forward passes are different lengths!","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"evaluate_policy(\n    model;\n    node = 3,\n    incoming_state = Dict(:volume => 100.0),\n    random_variable = 10.0,\n)","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"","category":"page"},{"location":"explanation/theory_intro/","page":"Introductory theory","title":"Introductory theory","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/generation_expansion/","page":"Generation expansion","title":"Generation expansion","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/examples/generation_expansion.jl\"","category":"page"},{"location":"examples/generation_expansion/#Generation-expansion","page":"Generation expansion","title":"Generation expansion","text":"","category":"section"},{"location":"examples/generation_expansion/","page":"Generation expansion","title":"Generation expansion","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/generation_expansion/","page":"Generation expansion","title":"Generation expansion","text":"using SDDP\nimport HiGHS\nimport Test\n\nfunction generation_expansion(duality_handler)\n    build_cost = 1e4\n    use_cost = 4\n    num_units = 5\n    capacities = ones(num_units)\n    demand_vals =\n        0.5 * [\n            5 5 5 5 5 5 5 5\n            4 3 1 3 0 9 8 17\n            0 9 4 2 19 19 13 7\n            25 11 4 14 4 6 15 12\n            6 7 5 3 8 4 17 13\n        ]\n    # Cost of unmet demand\n    penalty = 5e5\n    # Discounting rate\n    rho = 0.99\n    model = SDDP.LinearPolicyGraph(\n        stages = 5,\n        lower_bound = 0.0,\n        optimizer = HiGHS.Optimizer,\n    ) do sp, stage\n        @variable(\n            sp,\n            0 <= invested[1:num_units] <= 1,\n            SDDP.State,\n            Int,\n            initial_value = 0\n        )\n        @variables(sp, begin\n            generation >= 0\n            unmet >= 0\n            demand\n        end)\n\n        @constraints(\n            sp,\n            begin\n                # Can't un-invest\n                investment[i in 1:num_units], invested[i].out >= invested[i].in\n                # Generation capacity\n                sum(capacities[i] * invested[i].out for i in 1:num_units) >=\n                generation\n                # Meet demand or pay a penalty\n                unmet >= demand - sum(generation)\n                # For fewer iterations order the units to break symmetry, units are identical (tougher numerically)\n                [j in 1:(num_units-1)], invested[j].out <= invested[j+1].out\n            end\n        )\n        # Demand is uncertain\n        SDDP.parameterize(ω -> JuMP.fix(demand, ω), sp, demand_vals[stage, :])\n\n        @expression(\n            sp,\n            investment_cost,\n            build_cost *\n            sum(invested[i].out - invested[i].in for i in 1:num_units)\n        )\n        @stageobjective(\n            sp,\n            (investment_cost + generation * use_cost) * rho^(stage - 1) +\n            penalty * unmet\n        )\n    end\n    if get(ARGS, 1, \"\") == \"--write\"\n        # Run `$ julia generation_expansion.jl --write` to update the benchmark\n        # model directory\n        model_dir = joinpath(@__DIR__, \"..\", \"..\", \"..\", \"benchmarks\", \"models\")\n        SDDP.write_to_file(\n            model,\n            joinpath(model_dir, \"generation_expansion.sof.json.gz\");\n            test_scenarios = 100,\n        )\n        exit(0)\n    end\n    SDDP.train(model; log_frequency = 10, duality_handler = duality_handler)\n    Test.@test SDDP.calculate_bound(model) ≈ 2.078860e6 atol = 1e3\n    return\nend\n\ngeneration_expansion(SDDP.ContinuousConicDuality())\ngeneration_expansion(SDDP.LagrangianDuality())","category":"page"},{"location":"examples/generation_expansion/","page":"Generation expansion","title":"Generation expansion","text":"","category":"page"},{"location":"examples/generation_expansion/","page":"Generation expansion","title":"Generation expansion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/biobjective_hydro/","page":"Biobjective hydro-thermal","title":"Biobjective hydro-thermal","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/examples/biobjective_hydro.jl\"","category":"page"},{"location":"examples/biobjective_hydro/#Biobjective-hydro-thermal","page":"Biobjective hydro-thermal","title":"Biobjective hydro-thermal","text":"","category":"section"},{"location":"examples/biobjective_hydro/","page":"Biobjective hydro-thermal","title":"Biobjective hydro-thermal","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/biobjective_hydro/","page":"Biobjective hydro-thermal","title":"Biobjective hydro-thermal","text":"using SDDP, HiGHS, Statistics, Test\n\nfunction biobjective_example()\n    model = SDDP.LinearPolicyGraph(\n        stages = 3,\n        lower_bound = 0.0,\n        optimizer = HiGHS.Optimizer,\n    ) do subproblem, _\n        @variable(subproblem, 0 <= v <= 200, SDDP.State, initial_value = 50)\n        @variables(subproblem, begin\n            0 <= g[i = 1:2] <= 100\n            0 <= u <= 150\n            s >= 0\n            shortage_cost >= 0\n        end)\n        @expressions(subproblem, begin\n            objective_1, g[1] + 10 * g[2]\n            objective_2, shortage_cost\n        end)\n        @constraints(subproblem, begin\n                inflow_constraint, v.out == v.in - u - s\n                g[1] + g[2] + u == 150\n                shortage_cost >= 40 - v.out\n                shortage_cost >= 60 - 2 * v.out\n                shortage_cost >= 80 - 4 * v.out\n            end)\n        # You must call this for a biobjective problem!\n        SDDP.initialize_biobjective_subproblem(subproblem)\n        SDDP.parameterize(subproblem, 0.0:5:50.0) do ω\n            JuMP.set_normalized_rhs(inflow_constraint, ω)\n            # You must call `set_biobjective_functions` from within\n            # `SDDP.parameterize`.\n            return SDDP.set_biobjective_functions(\n                subproblem,\n                objective_1,\n                objective_2,\n            )\n        end\n    end\n    pareto_weights =\n        SDDP.train_biobjective(model, solution_limit = 10, iteration_limit = 10)\n    solutions = [(k, v) for (k, v) in pareto_weights]\n    sort!(solutions; by = x -> x[1])\n    @test length(solutions) == 10\n    # Test for convexity! The gradient must be decreasing as we move from left\n    # to right.\n    gradient(a, b) = (b[2] - a[2]) / (b[1] - a[1])\n    grad = Inf\n    for i in 1:9\n        new_grad = gradient(solutions[i], solutions[i+1])\n        @test new_grad < grad\n        grad = new_grad\n    end\n    return\nend\n\nbiobjective_example()","category":"page"},{"location":"examples/biobjective_hydro/","page":"Biobjective hydro-thermal","title":"Biobjective hydro-thermal","text":"","category":"page"},{"location":"examples/biobjective_hydro/","page":"Biobjective hydro-thermal","title":"Biobjective hydro-thermal","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/asset_management_simple/","page":"Asset management","title":"Asset management","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/examples/asset_management_simple.jl\"","category":"page"},{"location":"examples/asset_management_simple/#Asset-management","page":"Asset management","title":"Asset management","text":"","category":"section"},{"location":"examples/asset_management_simple/","page":"Asset management","title":"Asset management","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/asset_management_simple/","page":"Asset management","title":"Asset management","text":"Taken from the book J.R. Birge, F. Louveaux, Introduction to Stochastic Programming, Springer Series in Operations Research and Financial Engineering, Springer New York, New York, NY, 2011","category":"page"},{"location":"examples/asset_management_simple/","page":"Asset management","title":"Asset management","text":"using SDDP, HiGHS, Test\n\nfunction asset_management_simple()\n    model = SDDP.PolicyGraph(\n        SDDP.MarkovianGraph(\n            Array{Float64,2}[\n                [1.0]',\n                [0.5 0.5],\n                [0.5 0.5; 0.5 0.5],\n                [0.5 0.5; 0.5 0.5],\n            ],\n        ),\n        lower_bound = -1_000.0,\n        optimizer = HiGHS.Optimizer,\n    ) do subproblem, index\n        (stage, markov_state) = index\n        r_stock = [1.25, 1.06]\n        r_bonds = [1.14, 1.12]\n        @variable(subproblem, stocks >= 0, SDDP.State, initial_value = 0.0)\n        @variable(subproblem, bonds >= 0, SDDP.State, initial_value = 0.0)\n        if stage == 1\n            @constraint(subproblem, stocks.out + bonds.out == 55)\n            @stageobjective(subproblem, 0)\n        elseif 1 < stage < 4\n            @constraint(\n                subproblem,\n                r_stock[markov_state] * stocks.in +\n                r_bonds[markov_state] * bonds.in == stocks.out + bonds.out\n            )\n            @stageobjective(subproblem, 0)\n        else\n            @variable(subproblem, over >= 0)\n            @variable(subproblem, short >= 0)\n            @constraint(\n                subproblem,\n                r_stock[markov_state] * stocks.in +\n                r_bonds[markov_state] * bonds.in - over + short == 80\n            )\n            @stageobjective(subproblem, -over + 4 * short)\n        end\n    end\n    SDDP.train(model; log_frequency = 5)\n    @test SDDP.calculate_bound(model) ≈ 1.514 atol = 1e-4\n    return\nend\n\nasset_management_simple()","category":"page"},{"location":"examples/asset_management_simple/","page":"Asset management","title":"Asset management","text":"","category":"page"},{"location":"examples/asset_management_simple/","page":"Asset management","title":"Asset management","text":"This page was generated using Literate.jl.","category":"page"},{"location":"guides/access_previous_variables/#Access-variables-from-a-previous-stage","page":"Access variables from a previous stage","title":"Access variables from a previous stage","text":"","category":"section"},{"location":"guides/access_previous_variables/","page":"Access variables from a previous stage","title":"Access variables from a previous stage","text":"A common question is \"how do I use a variable from a previous stage in a constraint?\"","category":"page"},{"location":"guides/access_previous_variables/","page":"Access variables from a previous stage","title":"Access variables from a previous stage","text":"info: Info\nIf you want to use a variable from a previous stage, it must be a state variable.","category":"page"},{"location":"guides/access_previous_variables/","page":"Access variables from a previous stage","title":"Access variables from a previous stage","text":"Here are some examples:","category":"page"},{"location":"guides/access_previous_variables/#Access-a-first-stage-decision-in-a-future-stage","page":"Access variables from a previous stage","title":"Access a first-stage decision in a future stage","text":"","category":"section"},{"location":"guides/access_previous_variables/","page":"Access variables from a previous stage","title":"Access variables from a previous stage","text":"This is often useful if your first-stage decisions are capacity-expansion type decisions (e.g., you choose first how much capacity to add, but because it takes time to build, it only shows up in some future stage).","category":"page"},{"location":"guides/access_previous_variables/","page":"Access variables from a previous stage","title":"Access variables from a previous stage","text":"using SDDP, HiGHS\nSDDP.LinearPolicyGraph(\n    stages = 10,\n    sense = :Max,\n    upper_bound = 100.0,\n    optimizer = HiGHS.Optimizer,\n) do sp, t\n    # Capacity of the generator. Decided in the first stage.\n    @variable(sp, capacity >= 0, SDDP.State, initial_value = 0)\n    # Quantity of water stored.\n    @variable(sp, reservoir >= 0, SDDP.State, initial_value = 0)\n    # Quantity of water to use for electricity generation in current stage.\n    @variable(sp, generation >= 0)\n    if t == 1\n        # There are no constraints in the first stage, but we need to push the\n        # initial value of the reservoir to the next stage.\n        @constraint(sp, reservoir.out == reservoir.in)\n        # Since we're maximizing profit, subtract cost of capacity.\n        @stageobjective(sp, -capacity.out)\n    else\n        # Water balance constraint.\n        @constraint(sp, balance, reservoir.out - reservoir.in + generation == 0)\n        # Generation limit.\n        @constraint(sp, generation <= capacity.in)\n        # Push capacity to the next stage.\n        @constraint(sp, capacity.out == capacity.in)\n        # Maximize generation.\n        @stageobjective(sp, generation)\n        # Random inflow in balance constraint.\n        SDDP.parameterize(sp, rand(4)) do w\n            set_normalized_rhs(balance, w)\n        end\n    end\nend","category":"page"},{"location":"guides/access_previous_variables/#Access-a-decision-from-N-stages-ago","page":"Access variables from a previous stage","title":"Access a decision from N stages ago","text":"","category":"section"},{"location":"guides/access_previous_variables/","page":"Access variables from a previous stage","title":"Access variables from a previous stage","text":"This is often useful if have some inventory problem with a lead-time on orders.","category":"page"},{"location":"guides/access_previous_variables/","page":"Access variables from a previous stage","title":"Access variables from a previous stage","text":"using SDDP, HiGHS\nSDDP.LinearPolicyGraph(\n    stages = 10,\n    sense = :Max,\n    upper_bound = 100,\n    optimizer = HiGHS.Optimizer,\n) do sp, t\n    # Current inventory on hand.\n    @variable(sp, inventory >= 0, SDDP.State, initial_value = 0)\n    # Inventory pipeline.\n    #   pipeline[1].out are orders placed today.\n    #   pipeline[5].in are orders that arrive today and can be added to the\n    #     current inventory.\n    #   Stock moves up one slot in the pipeline each stage.\n    @variable(sp, pipeline[1:5], SDDP.State, initial_value = 0)\n    # The number of units to order today.\n    @variable(sp, 0 <= buy <= 10)\n    # The number of units to sell today.\n    @variable(sp, sell >= 0)\n    # Buy orders get placed in the pipeline.\n    @constraint(sp, pipeline[1].out == buy)\n    # Stock moves up one slot in the pipeline each stage.\n    @constraint(sp, [i=2:5], pipeline[i].out == pipeline[i-1].in)\n    # Stock balance constraint.\n    @constraint(sp, inventory.out == inventory.in - sell + pipeline[5].in)\n    # Maximize quantity of sold items.\n    @stageobjective(sp, sell)\nend","category":"page"},{"location":"guides/access_previous_variables/","page":"Access variables from a previous stage","title":"Access variables from a previous stage","text":"warning: Warning\nYou must initialize the same number of state variables in every stage, even if they are not used in that stage.","category":"page"},{"location":"guides/create_a_belief_state/","page":"Create a belief state","title":"Create a belief state","text":"DocTestSetup = quote\n    using SDDP\nend","category":"page"},{"location":"guides/create_a_belief_state/#Create-a-belief-state","page":"Create a belief state","title":"Create a belief state","text":"","category":"section"},{"location":"guides/create_a_belief_state/","page":"Create a belief state","title":"Create a belief state","text":"SDDP.jl includes an implementation of the algorithm described in Dowson, O., Morton, D.P., & Pagnoncelli, B.K. (2020). Partially observable multistage stochastic optimization. Operations Research Letters, 48(4), 505–512.","category":"page"},{"location":"guides/create_a_belief_state/","page":"Create a belief state","title":"Create a belief state","text":"Given a SDDP.Graph object (see Create a general policy graph for details), we can define the ambiguity partition using SDDP.add_ambiguity_set.","category":"page"},{"location":"guides/create_a_belief_state/","page":"Create a belief state","title":"Create a belief state","text":"For example, first we create a Markovian graph:","category":"page"},{"location":"guides/create_a_belief_state/","page":"Create a belief state","title":"Create a belief state","text":"using SDDP\nG = SDDP.MarkovianGraph([[0.5 0.5], [0.2 0.8; 0.8 0.2]])","category":"page"},{"location":"guides/create_a_belief_state/","page":"Create a belief state","title":"Create a belief state","text":"Then we add an ambiguity set over the nodes in the each stage:","category":"page"},{"location":"guides/create_a_belief_state/","page":"Create a belief state","title":"Create a belief state","text":"for t in 1:2\n    SDDP.add_ambiguity_set(G, [(t, 1), (t, 2)])\nend","category":"page"},{"location":"guides/create_a_belief_state/","page":"Create a belief state","title":"Create a belief state","text":"This results in the graph:","category":"page"},{"location":"guides/create_a_belief_state/","page":"Create a belief state","title":"Create a belief state","text":"G","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"CurrentModule = SDDP","category":"page"},{"location":"release_notes/#Release-notes","page":"Release notes","title":"Release notes","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.","category":"page"},{"location":"release_notes/#[v1.6.0](https://github.com/odow/SDDP.jl/releases/tag/v1.6.0)-(July-3,-2023)","page":"Release notes","title":"v1.6.0 (July 3, 2023)","text":"","category":"section"},{"location":"release_notes/#Added","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added RegularizedForwardPass (#624)\nAdded FirstStageStoppingRule (#634)","category":"page"},{"location":"release_notes/#Other","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Removed an unbound type parameter (#632)\nFixed typo in docstring (#633)\nAdded Here-and-now and hazard-decision tutorial (#635)","category":"page"},{"location":"release_notes/#[v1.5.1](https://github.com/odow/SDDP.jl/releases/tag/v1.5.1)-(June-30,-2023)","page":"Release notes","title":"v1.5.1 (June 30, 2023)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"This release contains a number of minor code changes, but it has a large impact on the content that is printed to screen. In particular, we now log periodically, instead of each iteration, and a \"good\" stopping rule is used as the default if none are specified. Try using SDDP.train(model) to see the difference.","category":"page"},{"location":"release_notes/#Other-2","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed various typos in the documentation (#617)\nFixed printing test after changes in JuMP (#618)\nSet SimulationStoppingRule as the default stopping rule (#619)\nChanged the default logging frequency. Pass log_every_seconds = 0.0 to train to revert to the old behavior. (#620)\nAdded example usage with Distributions.jl (@slwu89) (#622)\nRemoved the numerical issue @warn (#627)\nImproved the quality of docstrings (#630)","category":"page"},{"location":"release_notes/#[v1.5.0](https://github.com/odow/SDDP.jl/releases/tag/v1.5.0)-(May-14,-2023)","page":"Release notes","title":"v1.5.0 (May 14, 2023)","text":"","category":"section"},{"location":"release_notes/#Added-2","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added the ability to use a different model for the forward pass. This is a novel feature that lets you train better policies when the model is non-convex or does not have a well-defined dual. See the Alternative forward models tutorial in which we train convex and non-convex formulations of the optimal power flow problem. (#611)","category":"page"},{"location":"release_notes/#Other-3","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Updated missing changelog entries (#608)\nRemoved global variables (#610)\nConverted the Options struct to keyword arguments. This struct was a private implementation detail, but the change is breaking if you developed an extension to SDDP that touched these internals. (#612)\nFixed some typos (#613)","category":"page"},{"location":"release_notes/#[v1.4.0](https://github.com/odow/SDDP.jl/releases/tag/v1.4.0)-(May-8,-2023)","page":"Release notes","title":"v1.4.0 (May 8, 2023)","text":"","category":"section"},{"location":"release_notes/#Added-3","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added SDDP.SimulationStoppingRule (#598)\nAdded sampling_scheme argument to SDDP.write_to_file (#607)","category":"page"},{"location":"release_notes/#Fixed","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed parsing of some MSPFormat files (#602) (#604)\nFixed printing in header (#605)","category":"page"},{"location":"release_notes/#[v1.3.0](https://github.com/odow/SDDP.jl/releases/tag/v1.3.0)-(May-3,-2023)","page":"Release notes","title":"v1.3.0 (May 3, 2023)","text":"","category":"section"},{"location":"release_notes/#Added-4","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added experimental support for SDDP.MSPFormat.read_from_file (#593)","category":"page"},{"location":"release_notes/#Other-4","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Updated to StochOptFormat v0.3 (#600)","category":"page"},{"location":"release_notes/#[v1.2.1](https://github.com/odow/SDDP.jl/releases/tag/v1.2.1)-(May-1,-2023)","page":"Release notes","title":"v1.2.1 (May 1, 2023)","text":"","category":"section"},{"location":"release_notes/#Fixed-2","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed log_every_seconds (#597)","category":"page"},{"location":"release_notes/#[v1.2.0](https://github.com/odow/SDDP.jl/releases/tag/v1.2.0)-(May-1,-2023)","page":"Release notes","title":"v1.2.0 (May 1, 2023)","text":"","category":"section"},{"location":"release_notes/#Added-5","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added SDDP.SimulatorSamplingScheme (#594)\nAdded log_every_seconds argument to SDDP.train (#595)","category":"page"},{"location":"release_notes/#Other-5","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Tweaked how the log is printed (#588)\nUpdated to StochOptFormat v0.2 (#592)","category":"page"},{"location":"release_notes/#[v1.1.4](https://github.com/odow/SDDP.jl/releases/tag/v1.1.4)-(April-10,-2023)","page":"Release notes","title":"v1.1.4 (April 10, 2023)","text":"","category":"section"},{"location":"release_notes/#Fixed-3","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Logs are now flushed every iteration (#584)","category":"page"},{"location":"release_notes/#Other-6","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added docstrings to various functions (#581)\nMinor documentation updates (#580)\nClarified integrality documentation (#582)\nUpdated the README (#585)\nNumber of numerical issues is now printed to the log (#586)","category":"page"},{"location":"release_notes/#[v1.1.3](https://github.com/odow/SDDP.jl/releases/tag/v1.1.3)-(April-2,-2023)","page":"Release notes","title":"v1.1.3 (April 2, 2023)","text":"","category":"section"},{"location":"release_notes/#Other-7","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed typo in Example: deterministic to stochastic tutorial (#578)\nFixed typo in documentation of SDDP.simulate (#577)","category":"page"},{"location":"release_notes/#[v1.1.2](https://github.com/odow/SDDP.jl/releases/tag/v1.1.2)-(March-18,-2023)","page":"Release notes","title":"v1.1.2 (March 18, 2023)","text":"","category":"section"},{"location":"release_notes/#Other-8","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added Example: deterministic to stochastic tutorial (#572)","category":"page"},{"location":"release_notes/#[v1.1.1](https://github.com/odow/SDDP.jl/releases/tag/v1.1.1)-(March-16,-2023)","page":"Release notes","title":"v1.1.1 (March 16, 2023)","text":"","category":"section"},{"location":"release_notes/#Other-9","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed email in Project.toml\nAdded notebook to documentation tutorials (#571)","category":"page"},{"location":"release_notes/#[v1.1.0](https://github.com/odow/SDDP.jl/releases/tag/v1.1.0)-(January-12,-2023)","page":"Release notes","title":"v1.1.0 (January 12, 2023)","text":"","category":"section"},{"location":"release_notes/#Added-6","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added the node_name_parser argument to SDDP.write_cuts_to_file and added the option to skip nodes in SDDP.read_cuts_from_file (#565)","category":"page"},{"location":"release_notes/#[v1.0.0](https://github.com/odow/SDDP.jl/releases/tag/v1.0.0)-(January-3,-2023)","page":"Release notes","title":"v1.0.0 (January 3, 2023)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Although we're bumping MAJOR version, this is a non-breaking release. Going forward:","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"New features will bump the MINOR version\nBug fixes, maintenance, and documentation updates will bump the PATCH version\nWe will support only the Long Term Support (currently v1.6.7) and the latest patch (currently v1.8.4) releases of Julia. Updates to the LTS version will bump the MINOR version\nUpdates to the compat bounds of package dependencies will bump the PATCH version.","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"We do not intend any breaking changes to the public API, which would require a new MAJOR release. The public API is everything defined in the documentation. Anything not in the documentation is considered private and may change in any PATCH release.","category":"page"},{"location":"release_notes/#Added-7","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added num_nodes argument to SDDP.UnicyclicGraph (#562)\nAdded support for passing an optimizer to SDDP.Asynchronous (#545)","category":"page"},{"location":"release_notes/#Other-10","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Updated Plotting tools to use live plots (#563)\nAdded vale as a linter (#565)\nImproved documentation for initializing a parallel scheme (#566)","category":"page"},{"location":"release_notes/#[v0.4.9](https://github.com/odow/SDDP.jl/releases/tag/v0.4.9)-(January-3,-2023)","page":"Release notes","title":"v0.4.9 (January 3, 2023)","text":"","category":"section"},{"location":"release_notes/#Added-8","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added SDDP.UnicyclicGraph (#556)","category":"page"},{"location":"release_notes/#Other-11","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added tutorial on Markov Decision Processes (#556)\nAdded two-stage newsvendor tutorial (#557)\nRefactored the layout of the documentation (#554) (#555)\nUpdated copyright to 2023 (#558)\nFixed errors in the documentation (#561)","category":"page"},{"location":"release_notes/#[v0.4.8](https://github.com/odow/SDDP.jl/releases/tag/v0.4.8)-(December-19,-2022)","page":"Release notes","title":"v0.4.8 (December 19, 2022)","text":"","category":"section"},{"location":"release_notes/#Added-9","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added terminate_on_cycle option to SDDP.Historical (#549)\nAdded include_last_node option to SDDP.DefaultForwardPass (#547)","category":"page"},{"location":"release_notes/#Fixed-4","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Reverted then fixed (#531) because it failed to account for problems with integer variables (#546) (#551)","category":"page"},{"location":"release_notes/#[v0.4.7](https://github.com/odow/SDDP.jl/releases/tag/v0.4.7)-(December-17,-2022)","page":"Release notes","title":"v0.4.7 (December 17, 2022)","text":"","category":"section"},{"location":"release_notes/#Added-10","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added initial_node support to InSampleMonteCarlo and OutOfSampleMonteCarlo (#535)","category":"page"},{"location":"release_notes/#Fixed-5","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Rethrow InterruptException when solver is interrupted (#534)\nFixed numerical recovery when we need dual solutions (#531) (Thanks @bfpc)\nFixed re-using the dashboard = true option between solves (#538)\nFixed bug when no @stageobjective is set (now defaults to 0.0) (#539)\nFixed errors thrown when invalid inputs are provided to add_objective_state (#540)","category":"page"},{"location":"release_notes/#Other-12","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Drop support for Julia versions prior to 1.6 (#533)\nUpdated versions of dependencies (#522) (#533)\nSwitched to HiGHS in the documentation and tests (#533)\nAdded license headers (#519)\nFixed link in air conditioning example (#521) (Thanks @conema)\nClarified variable naming in deterministic equivalent (#525) (Thanks @lucasprocessi)\nAdded this change log (#536)\nCuts are now written to model.cuts.json when numerical instability is discovered. This can aid debugging because it allows to you reload the cuts as of the iteration that caused the numerical issue (#537)","category":"page"},{"location":"release_notes/#[v0.4.6](https://github.com/odow/SDDP.jl/releases/tag/v0.4.6)-(March-25,-2022)","page":"Release notes","title":"v0.4.6 (March 25, 2022)","text":"","category":"section"},{"location":"release_notes/#Other-13","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Updated to JuMP v1.0 (#517)","category":"page"},{"location":"release_notes/#[v0.4.5](https://github.com/odow/SDDP.jl/releases/tag/v0.4.5)-(March-9,-2022)","page":"Release notes","title":"v0.4.5 (March 9, 2022)","text":"","category":"section"},{"location":"release_notes/#Fixed-6","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed issue with set_silent in a subproblem (#510)","category":"page"},{"location":"release_notes/#Other-14","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed many typos (#500) (#501) (#506) (#511) (Thanks @bfpc)\nUpdate to JuMP v0.23 (#514)\nAdded auto-regressive tutorial (#507)","category":"page"},{"location":"release_notes/#[v0.4.4](https://github.com/odow/SDDP.jl/releases/tag/v0.4.4)-(December-11,-2021)","page":"Release notes","title":"v0.4.4 (December 11, 2021)","text":"","category":"section"},{"location":"release_notes/#Added-11","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added BanditDuality (#471)\nAdded benchmark scripts (#475) (#476) (#490)\nwrite_cuts_to_file now saves visited states (#468)","category":"page"},{"location":"release_notes/#Fixed-7","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed BoundStalling in a deterministic policy (#470) (#474)\nFixed magnitude warning with zero coefficients (#483)","category":"page"},{"location":"release_notes/#Other-15","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Improvements to LagrangianDuality (#481) (#482) (#487)\nImprovements to StrengthenedConicDuality (#486)\nSwitch to functional form for the tests (#478)\nFixed typos (#472) (Thanks @vfdev-5)\nUpdate to JuMP v0.22 (#498)","category":"page"},{"location":"release_notes/#[v0.4.3](https://github.com/odow/SDDP.jl/releases/tag/v0.4.3)-(August-31,-2021)","page":"Release notes","title":"v0.4.3 (August 31, 2021)","text":"","category":"section"},{"location":"release_notes/#Added-12","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added biobjective solver (#462)\nAdded forward_pass_callback (#466)","category":"page"},{"location":"release_notes/#Other-16","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Update tutorials and documentation (#459) (#465)\nOrganize how paper materials are stored (#464)","category":"page"},{"location":"release_notes/#[v0.4.2](https://github.com/odow/SDDP.jl/releases/tag/v0.4.2)-(August-24,-2021)","page":"Release notes","title":"v0.4.2 (August 24, 2021)","text":"","category":"section"},{"location":"release_notes/#Fixed-8","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed a bug in Lagrangian duality (#457)","category":"page"},{"location":"release_notes/#[v0.4.1](https://github.com/odow/SDDP.jl/releases/tag/v0.4.1)-(August-23,-2021)","page":"Release notes","title":"v0.4.1 (August 23, 2021)","text":"","category":"section"},{"location":"release_notes/#Other-17","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Minor changes to our implementation of LagrangianDuality (#454) (#455)","category":"page"},{"location":"release_notes/#[v0.4.0](https://github.com/odow/SDDP.jl/releases/tag/v0.4.0)-(August-17,-2021)","page":"Release notes","title":"v0.4.0 (August 17, 2021)","text":"","category":"section"},{"location":"release_notes/#Breaking","page":"Release notes","title":"Breaking","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"A large refactoring for how we handle stochastic integer programs. This added support for things like SDDP.ContinuousConicDuality and SDDP.LagrangianDuality. It was breaking because we removed the integrality_handler argument to PolicyGraph. (#499) (#453)","category":"page"},{"location":"release_notes/#Other-18","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Documentation improvements (#447) (#448) (#450)","category":"page"},{"location":"release_notes/#[v0.3.17](https://github.com/odow/SDDP.jl/releases/tag/v0.3.17)-(July-6,-2021)","page":"Release notes","title":"v0.3.17 (July 6, 2021)","text":"","category":"section"},{"location":"release_notes/#Added-13","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added SDDP.PSRSamplingScheme (#426)","category":"page"},{"location":"release_notes/#Other-19","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Display more model attributes (#438)\nDocumentation improvements (#433) (#437) (#439)","category":"page"},{"location":"release_notes/#[v0.3.16](https://github.com/odow/SDDP.jl/releases/tag/v0.3.16)-(June-17,-2021)","page":"Release notes","title":"v0.3.16 (June 17, 2021)","text":"","category":"section"},{"location":"release_notes/#Added-14","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added SDDP.RiskAdjustedForwardPass (#413)\nAllow SDDP.Historical to sample sequentially (#420)","category":"page"},{"location":"release_notes/#Other-20","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Update risk measure docstrings (#418)","category":"page"},{"location":"release_notes/#[v0.3.15](https://github.com/odow/SDDP.jl/releases/tag/v0.3.15)-(June-1,-2021)","page":"Release notes","title":"v0.3.15 (June 1, 2021)","text":"","category":"section"},{"location":"release_notes/#Added-15","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added SDDP.StoppingChain","category":"page"},{"location":"release_notes/#Fixed-9","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed scoping bug in SDDP.@stageobjective (#407)\nFixed a bug when the initial point is infeasible (#411)\nSet subproblems to silent by default (#409)","category":"page"},{"location":"release_notes/#Other-21","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Add JuliaFormatter (#412)\nDocumentation improvements (#406) (#408)","category":"page"},{"location":"release_notes/#[v0.3.14](https://github.com/odow/SDDP.jl/releases/tag/v0.3.14)-(March-30,-2021)","page":"Release notes","title":"v0.3.14 (March 30, 2021)","text":"","category":"section"},{"location":"release_notes/#Fixed-10","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed O(N^2) behavior in get_same_children (#393)","category":"page"},{"location":"release_notes/#[v0.3.13](https://github.com/odow/SDDP.jl/releases/tag/v0.3.13)-(March-27,-2021)","page":"Release notes","title":"v0.3.13 (March 27, 2021)","text":"","category":"section"},{"location":"release_notes/#Fixed-11","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed bug in print.jl\nFixed compat of Reexport (#388)","category":"page"},{"location":"release_notes/#[v0.3.12](https://github.com/odow/SDDP.jl/releases/tag/v0.3.12)-(March-22,-2021)","page":"Release notes","title":"v0.3.12 (March 22, 2021)","text":"","category":"section"},{"location":"release_notes/#Added-16","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added problem statistics to header (#385) (#386)","category":"page"},{"location":"release_notes/#Fixed-12","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed subtypes in visualization (#384)","category":"page"},{"location":"release_notes/#[v0.3.11](https://github.com/odow/SDDP.jl/releases/tag/v0.3.11)-(March-22,-2021)","page":"Release notes","title":"v0.3.11 (March 22, 2021)","text":"","category":"section"},{"location":"release_notes/#Fixed-13","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed constructor in direct mode (#383)","category":"page"},{"location":"release_notes/#Other-22","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix documentation (#379)","category":"page"},{"location":"release_notes/#[v0.3.10](https://github.com/odow/SDDP.jl/releases/tag/v0.3.10)-(February-23,-2021)","page":"Release notes","title":"v0.3.10 (February 23, 2021)","text":"","category":"section"},{"location":"release_notes/#Fixed-14","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed seriescolor in publication plot (#376)","category":"page"},{"location":"release_notes/#[v0.3.9](https://github.com/odow/SDDP.jl/releases/tag/v0.3.9)-(February-20,-2021)","page":"Release notes","title":"v0.3.9 (February 20, 2021)","text":"","category":"section"},{"location":"release_notes/#Added-17","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Add option to simulate with different incoming state (#372)\nAdded warning for cuts with high dynamic range (#373)","category":"page"},{"location":"release_notes/#Fixed-15","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed seriesalpha in publication plot (#375)","category":"page"},{"location":"release_notes/#[v0.3.8](https://github.com/odow/SDDP.jl/releases/tag/v0.3.8)-(January-19,-2021)","page":"Release notes","title":"v0.3.8 (January 19, 2021)","text":"","category":"section"},{"location":"release_notes/#Other-23","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Documentation improvements (#367) (#369) (#370)","category":"page"},{"location":"release_notes/#[v0.3.7](https://github.com/odow/SDDP.jl/releases/tag/v0.3.7)-(January-8,-2021)","page":"Release notes","title":"v0.3.7 (January 8, 2021)","text":"","category":"section"},{"location":"release_notes/#Other-24","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Documentation improvements (#362) (#363) (#365) (#366)\nBump copyright (#364)","category":"page"},{"location":"release_notes/#[v0.3.6](https://github.com/odow/SDDP.jl/releases/tag/v0.3.6)-(December-17,-2020)","page":"Release notes","title":"v0.3.6 (December 17, 2020)","text":"","category":"section"},{"location":"release_notes/#Other-25","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix typos (#358)\nCollapse navigation bar in docs (#359)\nUpdate TagBot.yml (#361)","category":"page"},{"location":"release_notes/#[v0.3.5](https://github.com/odow/SDDP.jl/releases/tag/v0.3.5)-(November-18,-2020)","page":"Release notes","title":"v0.3.5 (November 18, 2020)","text":"","category":"section"},{"location":"release_notes/#Other-26","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Update citations (#348)\nSwitch to GitHub actions (#355)","category":"page"},{"location":"release_notes/#[v0.3.4](https://github.com/odow/SDDP.jl/releases/tag/v0.3.4)-(August-25,-2020)","page":"Release notes","title":"v0.3.4 (August 25, 2020)","text":"","category":"section"},{"location":"release_notes/#Added-18","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added non-uniform distributionally robust risk measure (#328)\nAdded numerical recovery functions (#330)\nAdded experimental StochOptFormat (#332) (#336) (#337) (#341) (#343) (#344)\nAdded entropic risk measure (#347)","category":"page"},{"location":"release_notes/#Other-27","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Documentation improvements (#327) (#333) (#339) (#340)","category":"page"},{"location":"release_notes/#[v0.3.3](https://github.com/odow/SDDP.jl/releases/tag/v0.3.3)-(June-19,-2020)","page":"Release notes","title":"v0.3.3 (June 19, 2020)","text":"","category":"section"},{"location":"release_notes/#Added-19","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added asynchronous support for price and belief states (#325)\nAdded ForwardPass plug-in system (#320)","category":"page"},{"location":"release_notes/#Fixed-16","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix check for probabilities in Markovian graph (#322)","category":"page"},{"location":"release_notes/#[v0.3.2](https://github.com/odow/SDDP.jl/releases/tag/v0.3.2)-(April-6,-2020)","page":"Release notes","title":"v0.3.2 (April 6, 2020)","text":"","category":"section"},{"location":"release_notes/#Added-20","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added log_frequency argument to SDDP.train (#307)","category":"page"},{"location":"release_notes/#Other-28","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Improve error message in deterministic equivalent (#312)\nUpdate to RecipesBase 1.0 (#313)","category":"page"},{"location":"release_notes/#[v0.3.1](https://github.com/odow/SDDP.jl/releases/tag/v0.3.1)-(February-26,-2020)","page":"Release notes","title":"v0.3.1 (February 26, 2020)","text":"","category":"section"},{"location":"release_notes/#Fixed-17","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed filename in integrality_handlers.jl (#304)","category":"page"},{"location":"release_notes/#[v0.3.0](https://github.com/odow/SDDP.jl/releases/tag/v0.3.0)-(February-20,-2020)","page":"Release notes","title":"v0.3.0 (February 20, 2020)","text":"","category":"section"},{"location":"release_notes/#Breaking-2","page":"Release notes","title":"Breaking","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Breaking changes to update to JuMP v0.21 (#300).","category":"page"},{"location":"release_notes/#[v0.2.4](https://github.com/odow/SDDP.jl/releases/tag/v0.2.4)-(February-7,-2020)","page":"Release notes","title":"v0.2.4 (February 7, 2020)","text":"","category":"section"},{"location":"release_notes/#Added-21","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added a counter for the number of total subproblem solves (#301)","category":"page"},{"location":"release_notes/#Other-29","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Update formatter (#298)\nAdded tests (#299)","category":"page"},{"location":"release_notes/#[v0.2.3](https://github.com/odow/SDDP.jl/releases/tag/v0.2.3)-(January-24,-2020)","page":"Release notes","title":"v0.2.3 (January 24, 2020)","text":"","category":"section"},{"location":"release_notes/#Added-22","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added support for convex risk measures (#294)","category":"page"},{"location":"release_notes/#Fixed-18","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed bug when subproblem is infeasible (#296)\nFixed bug in deterministic equivalent (#297)","category":"page"},{"location":"release_notes/#Other-30","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added example from IJOC paper (#293)","category":"page"},{"location":"release_notes/#[v0.2.2](https://github.com/odow/SDDP.jl/releases/tag/v0.2.2)-(January-10,-2020)","page":"Release notes","title":"v0.2.2 (January 10, 2020)","text":"","category":"section"},{"location":"release_notes/#Fixed-19","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed flakey time limit in tests (#291)","category":"page"},{"location":"release_notes/#Other-31","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Removed MathOptFormat.jl (#289)\nUpdate copyright (#290)","category":"page"},{"location":"release_notes/#[v0.2.1](https://github.com/odow/SDDP.jl/releases/tag/v0.2.1)-(December-19,-2019)","page":"Release notes","title":"v0.2.1 (December 19, 2019)","text":"","category":"section"},{"location":"release_notes/#Added-23","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added support for approximating a Markov lattice (#282) (#285)\nAdd tools for visualizing the value function (#272) (#286)\nWrite .mof.json files on error (#284)","category":"page"},{"location":"release_notes/#Other-32","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Improve documentation (#281) (#283)\nUpdate tests for Julia 1.3 (#287)","category":"page"},{"location":"release_notes/#[v0.2.0](https://github.com/odow/SDDP.jl/releases/tag/v0.2.0)-(December-16,-2019)","page":"Release notes","title":"v0.2.0 (December 16, 2019)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"This version added the asynchronous parallel implementation with a few minor breaking changes in how we iterated internally. It didn't break basic user-facing models, only implementations that implemented some of the extension features. It probably could have been a v1.1 release.","category":"page"},{"location":"release_notes/#Added-24","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added asynchronous parallel implementation (#277)\nAdded roll-out algorithm for cyclic graphs (#279)","category":"page"},{"location":"release_notes/#Other-33","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Improved error messages in PolicyGraph (#271)\nAdded JuliaFormatter (#273) (#276)\nFixed compat bounds (#274) (#278)\nAdded documentation for simulating non-standard graphs (#280)","category":"page"},{"location":"release_notes/#[v0.1.0](https://github.com/odow/SDDP.jl/releases/tag/v0.1.0)-(October-17,-2019)","page":"Release notes","title":"v0.1.0 (October 17, 2019)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"A complete rewrite of SDDP.jl based on the policy graph framework. This was essentially a new package. It has minimal code in common with the previous implementation.","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Development started on September 28, 2018 in Kokako.jl, and the code was merged into SDDP.jl on March 14, 2019.","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"The pull request SDDP.jl#180 lists the 29 issues that the rewrite closed.","category":"page"},{"location":"release_notes/#[v0.0.1](https://github.com/odow/SDDP.jl/releases/tag/v0.0.1)-(April-18,-2018)","page":"Release notes","title":"v0.0.1 (April 18, 2018)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Initial release. Development had been underway since January 22, 2016 in the StochDualDynamicProgram.jl repository. The last development commit there was April 5, 2017. Work then continued in this repository for a year before the first tagged release.","category":"page"},{"location":"examples/asset_management_stagewise/","page":"Asset management with modifications","title":"Asset management with modifications","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/examples/asset_management_stagewise.jl\"","category":"page"},{"location":"examples/asset_management_stagewise/#Asset-management-with-modifications","page":"Asset management with modifications","title":"Asset management with modifications","text":"","category":"section"},{"location":"examples/asset_management_stagewise/","page":"Asset management with modifications","title":"Asset management with modifications","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/asset_management_stagewise/","page":"Asset management with modifications","title":"Asset management with modifications","text":"A modified version of the Asset Management Problem Taken from the book J.R. Birge, F. Louveaux, Introduction to Stochastic Programming, Springer Series in Operations Research and Financial Engineering, Springer New York, New York, NY, 2011","category":"page"},{"location":"examples/asset_management_stagewise/","page":"Asset management with modifications","title":"Asset management with modifications","text":"using SDDP, HiGHS, Test\n\nfunction asset_management_stagewise(; cut_type)\n    w_s = [1.25, 1.06]\n    w_b = [1.14, 1.12]\n    Phi = [-1, 5]\n    Psi = [0.02, 0.0]\n\n    model = SDDP.MarkovianPolicyGraph(\n        sense = :Max,\n        transition_matrices = Array{Float64,2}[\n            [1.0]',\n            [0.5 0.5],\n            [0.5 0.5; 0.5 0.5],\n            [0.5 0.5; 0.5 0.5],\n        ],\n        upper_bound = 1000.0,\n        optimizer = HiGHS.Optimizer,\n    ) do subproblem, node\n        t, i = node\n        @variable(subproblem, xs >= 0, SDDP.State, initial_value = 0)\n        @variable(subproblem, xb >= 0, SDDP.State, initial_value = 0)\n        if t == 1\n            @constraint(subproblem, xs.out + xb.out == 55 + xs.in + xb.in)\n            @stageobjective(subproblem, 0)\n        elseif t == 2 || t == 3\n            @variable(subproblem, phi)\n            @constraint(\n                subproblem,\n                w_s[i] * xs.in + w_b[i] * xb.in + phi == xs.out + xb.out\n            )\n            SDDP.parameterize(subproblem, [1, 2], [0.6, 0.4]) do ω\n                JuMP.fix(phi, Phi[ω])\n                @stageobjective(subproblem, Psi[ω] * xs.out)\n            end\n        else\n            @variable(subproblem, u >= 0)\n            @variable(subproblem, v >= 0)\n            @constraint(\n                subproblem,\n                w_s[i] * xs.in + w_b[i] * xb.in + u - v == 80,\n            )\n            @stageobjective(subproblem, -4u + v)\n        end\n    end\n    SDDP.train(\n        model;\n        cut_type = cut_type,\n        log_frequency = 10,\n        risk_measure = (node) -> begin\n            if node[1] != 3\n                SDDP.Expectation()\n            else\n                SDDP.EAVaR(lambda = 0.5, beta = 0.5)\n            end\n        end,\n    )\n    @test SDDP.calculate_bound(model) ≈ 1.278 atol = 1e-3\n    return\nend\n\nasset_management_stagewise(cut_type = SDDP.SINGLE_CUT)\n\nasset_management_stagewise(cut_type = SDDP.MULTI_CUT)","category":"page"},{"location":"examples/asset_management_stagewise/","page":"Asset management with modifications","title":"Asset management with modifications","text":"","category":"page"},{"location":"examples/asset_management_stagewise/","page":"Asset management with modifications","title":"Asset management with modifications","text":"This page was generated using Literate.jl.","category":"page"},{"location":"guides/choose_a_stopping_rule/#Choose-a-stopping-rule","page":"Choose a stopping rule","title":"Choose a stopping rule","text":"","category":"section"},{"location":"guides/choose_a_stopping_rule/","page":"Choose a stopping rule","title":"Choose a stopping rule","text":"The theory of SDDP tells us that the algorithm converges to an optimal policy almost surely in a finite number of iterations. In practice, this number is very large. Therefore, we need some way of pre-emptively terminating SDDP when the solution is “good enough.” We call heuristics for pre-emptively terminating SDDP stopping rules.","category":"page"},{"location":"guides/choose_a_stopping_rule/#Basic-limits","page":"Choose a stopping rule","title":"Basic limits","text":"","category":"section"},{"location":"guides/choose_a_stopping_rule/","page":"Choose a stopping rule","title":"Choose a stopping rule","text":"The training of an SDDP policy can be terminated after a fixed number of iterations using the iteration_limit keyword.","category":"page"},{"location":"guides/choose_a_stopping_rule/","page":"Choose a stopping rule","title":"Choose a stopping rule","text":"SDDP.train(model, iteration_limit = 10)","category":"page"},{"location":"guides/choose_a_stopping_rule/","page":"Choose a stopping rule","title":"Choose a stopping rule","text":"The training of an SDDP policy can be terminated after a fixed number of seconds using the time_limit keyword.","category":"page"},{"location":"guides/choose_a_stopping_rule/","page":"Choose a stopping rule","title":"Choose a stopping rule","text":"SDDP.train(model, time_limit = 2.0)","category":"page"},{"location":"guides/choose_a_stopping_rule/#Stopping-rules","page":"Choose a stopping rule","title":"Stopping rules","text":"","category":"section"},{"location":"guides/choose_a_stopping_rule/","page":"Choose a stopping rule","title":"Choose a stopping rule","text":"In addition to the limits provided as keyword arguments, a variety of other stopping rules are available. These can be passed to SDDP.train as a vector to the stopping_rules keyword. For example:","category":"page"},{"location":"guides/choose_a_stopping_rule/","page":"Choose a stopping rule","title":"Choose a stopping rule","text":"SDDP.train(model, stopping_rules = [SDDP.BoundStalling(10, 1e-4)])","category":"page"},{"location":"guides/choose_a_stopping_rule/","page":"Choose a stopping rule","title":"Choose a stopping rule","text":"See Stopping rules for a list of stopping rules supported by SDDP.jl.","category":"page"},{"location":"examples/belief/","page":"Partially observable inventory management","title":"Partially observable inventory management","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/examples/belief.jl\"","category":"page"},{"location":"examples/belief/#Partially-observable-inventory-management","page":"Partially observable inventory management","title":"Partially observable inventory management","text":"","category":"section"},{"location":"examples/belief/","page":"Partially observable inventory management","title":"Partially observable inventory management","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/belief/","page":"Partially observable inventory management","title":"Partially observable inventory management","text":"using SDDP, HiGHS, Random, Statistics, Test\n\nfunction inventory_management_problem()\n    demand_values = [1.0, 2.0]\n    demand_prob = Dict(:Ah => [0.2, 0.8], :Bh => [0.8, 0.2])\n    graph = SDDP.Graph(\n        :root_node,\n        [:Ad, :Ah, :Bd, :Bh],\n        [\n            (:root_node => :Ad, 0.5),\n            (:root_node => :Bd, 0.5),\n            (:Ad => :Ah, 1.0),\n            (:Ah => :Ad, 0.8),\n            (:Ah => :Bd, 0.1),\n            (:Bd => :Bh, 1.0),\n            (:Bh => :Bd, 0.8),\n            (:Bh => :Ad, 0.1),\n        ],\n    )\n    SDDP.add_ambiguity_set(graph, [:Ad, :Bd], 1e2)\n    SDDP.add_ambiguity_set(graph, [:Ah, :Bh], 1e2)\n\n    model = SDDP.PolicyGraph(\n        graph,\n        lower_bound = 0.0,\n        optimizer = HiGHS.Optimizer,\n    ) do subproblem, node\n        @variables(\n            subproblem,\n            begin\n                0 <= inventory <= 2, (SDDP.State, initial_value = 0.0)\n                buy >= 0\n                demand\n            end\n        )\n        @constraint(subproblem, demand == inventory.in - inventory.out + buy)\n        if node == :Ad || node == :Bd || node == :D\n            JuMP.fix(demand, 0)\n            @stageobjective(subproblem, buy)\n        else\n            SDDP.parameterize(subproblem, demand_values, demand_prob[node]) do ω\n                return JuMP.fix(demand, ω)\n            end\n            @stageobjective(subproblem, 2 * buy + inventory.out)\n        end\n    end\n    # Train the policy.\n    Random.seed!(123)\n    SDDP.train(\n        model;\n        iteration_limit = 100,\n        cut_type = SDDP.SINGLE_CUT,\n        log_frequency = 10,\n    )\n    results = SDDP.simulate(model, 500)\n    objectives =\n        [sum(s[:stage_objective] for s in simulation) for simulation in results]\n    sample_mean = round(Statistics.mean(objectives); digits = 2)\n    sample_ci = round(1.96 * Statistics.std(objectives) / sqrt(500); digits = 2)\n    @test SDDP.calculate_bound(model) ≈ sample_mean atol = sample_ci\n    return\nend\n\ninventory_management_problem()","category":"page"},{"location":"examples/belief/","page":"Partially observable inventory management","title":"Partially observable inventory management","text":"","category":"page"},{"location":"examples/belief/","page":"Partially observable inventory management","title":"Partially observable inventory management","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorial/decision_hazard/","page":"Here-and-now and hazard-decision","title":"Here-and-now and hazard-decision","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/tutorial/decision_hazard.jl\"","category":"page"},{"location":"tutorial/decision_hazard/#Here-and-now-and-hazard-decision","page":"Here-and-now and hazard-decision","title":"Here-and-now and hazard-decision","text":"","category":"section"},{"location":"tutorial/decision_hazard/","page":"Here-and-now and hazard-decision","title":"Here-and-now and hazard-decision","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorial/decision_hazard/","page":"Here-and-now and hazard-decision","title":"Here-and-now and hazard-decision","text":"SDDP.jl assumes that the agent gets to make a decision after observing the realization of the random variable. This is called a wait-and-see or hazard-decision model. In contrast, you might want your agent to make decisions before observing the random variable. This is called a here-and-now or decision-hazard model.","category":"page"},{"location":"tutorial/decision_hazard/","page":"Here-and-now and hazard-decision","title":"Here-and-now and hazard-decision","text":"info: Info\nThe terms decision-hazard and hazard-decision from the French hasard, meaning chance. It could also have been translated as uncertainty-decision and decision-uncertainty, but the community seems to have settled on the transliteration hazard instead. We like the hazard-decision and decision-hazard terms because they clearly communicate the order of the decision and the uncertainty.","category":"page"},{"location":"tutorial/decision_hazard/","page":"Here-and-now and hazard-decision","title":"Here-and-now and hazard-decision","text":"The purpose of this tutorial is to demonstrate how to model here-and-how decisions in SDDP.jl.","category":"page"},{"location":"tutorial/decision_hazard/","page":"Here-and-now and hazard-decision","title":"Here-and-now and hazard-decision","text":"This tutorial uses the following packages:","category":"page"},{"location":"tutorial/decision_hazard/","page":"Here-and-now and hazard-decision","title":"Here-and-now and hazard-decision","text":"using SDDP\nimport HiGHS","category":"page"},{"location":"tutorial/decision_hazard/#Hazard-decision-formulation","page":"Here-and-now and hazard-decision","title":"Hazard-decision formulation","text":"","category":"section"},{"location":"tutorial/decision_hazard/","page":"Here-and-now and hazard-decision","title":"Here-and-now and hazard-decision","text":"As an example, we're going to build a standard hydro-thermal scheduling model, with a single hydro-reservoir and a single thermal generation plant. In each of the four stages, we need to choose some mix of u_thermal and u_hydro to meet a demand of 9 units, where unmet demand is penalized at a rate of $500/unit.","category":"page"},{"location":"tutorial/decision_hazard/","page":"Here-and-now and hazard-decision","title":"Here-and-now and hazard-decision","text":"hazard_decision = SDDP.LinearPolicyGraph(\n    stages = 4,\n    sense = :Min,\n    lower_bound = 0.0,\n    optimizer = HiGHS.Optimizer,\n) do sp, node\n    @variables(sp, begin\n        0 <= x_storage <= 8, (SDDP.State, initial_value = 6)\n        u_thermal >= 0\n        u_hydro >= 0\n        u_unmet_demand >= 0\n    end)\n    @constraint(sp, u_thermal + u_hydro == 9 - u_unmet_demand)\n    @constraint(sp, c_balance, x_storage.out == x_storage.in - u_hydro + 0)\n    SDDP.parameterize(sp, [2, 3]) do ω_inflow\n        return set_normalized_rhs(c_balance, ω_inflow)\n    end\n    @stageobjective(sp, 500 * u_unmet_demand + 20 * u_thermal)\nend","category":"page"},{"location":"tutorial/decision_hazard/#Decision-hazard-formulation","page":"Here-and-now and hazard-decision","title":"Decision-hazard formulation","text":"","category":"section"},{"location":"tutorial/decision_hazard/","page":"Here-and-now and hazard-decision","title":"Here-and-now and hazard-decision","text":"In the wait-and-see formulation, we get to decide the generation variables after observing the realization of ω_inflow. However, a common modeling situation is that we need to decide the level of thermal generation u_thermal before observing the inflow.","category":"page"},{"location":"tutorial/decision_hazard/","page":"Here-and-now and hazard-decision","title":"Here-and-now and hazard-decision","text":"SDDP.jl can model here-and-now decisions with a modeling trick: a wait-and-see decision in stage t-1 is equivalent to a here-and-now decision in stage t.","category":"page"},{"location":"tutorial/decision_hazard/","page":"Here-and-now and hazard-decision","title":"Here-and-now and hazard-decision","text":"In other words, we need to convert the u_thermal decision from a control variable that is decided in stage t, to a state variable that is decided in stage t-1. Here's our new model, with the three lines that have changed:","category":"page"},{"location":"tutorial/decision_hazard/","page":"Here-and-now and hazard-decision","title":"Here-and-now and hazard-decision","text":"decision_hazard = SDDP.LinearPolicyGraph(\n    stages = 4,\n    sense = :Min,\n    lower_bound = 0.0,\n    optimizer = HiGHS.Optimizer,\n) do sp, node\n    @variables(sp, begin\n        0 <= x_storage <= 8, (SDDP.State, initial_value = 6)\n        u_thermal >= 0, (SDDP.State, initial_value = 0)  # <-- changed\n        u_hydro >= 0\n        u_unmet_demand >= 0\n    end)\n    @constraint(sp, u_thermal.in + u_hydro == 9 - u_unmet_demand)  # <-- changed\n    @constraint(sp, c_balance, x_storage.out == x_storage.in - u_hydro + 0)\n    SDDP.parameterize(sp, [2, 3]) do ω\n        return set_normalized_rhs(c_balance, ω)\n    end\n    @stageobjective(sp, 500 * u_unmet_demand + 20 * u_thermal.in) # <-- changed\nend","category":"page"},{"location":"tutorial/decision_hazard/","page":"Here-and-now and hazard-decision","title":"Here-and-now and hazard-decision","text":"Can you understand the reformulation? In each stage, we now use the value of u_thermal.in instead of u_thermal, and the value of the outgoing u_thermal.out is the here-and-how decision for stage t+1.","category":"page"},{"location":"tutorial/decision_hazard/","page":"Here-and-now and hazard-decision","title":"Here-and-now and hazard-decision","text":"(If you can spot a \"mistake\" with this model, don't worry, we'll fix it below. Presenting it like this simplifies the exposition.)","category":"page"},{"location":"tutorial/decision_hazard/#Comparison","page":"Here-and-now and hazard-decision","title":"Comparison","text":"","category":"section"},{"location":"tutorial/decision_hazard/","page":"Here-and-now and hazard-decision","title":"Here-and-now and hazard-decision","text":"Let's compare the cost of operating the two models:","category":"page"},{"location":"tutorial/decision_hazard/","page":"Here-and-now and hazard-decision","title":"Here-and-now and hazard-decision","text":"function train_and_compute_cost(model)\n    SDDP.train(model; print_level = 0)\n    return println(\"Cost = \\$\", SDDP.calculate_bound(model))\nend\n\ntrain_and_compute_cost(hazard_decision)","category":"page"},{"location":"tutorial/decision_hazard/","page":"Here-and-now and hazard-decision","title":"Here-and-now and hazard-decision","text":"train_and_compute_cost(decision_hazard)","category":"page"},{"location":"tutorial/decision_hazard/","page":"Here-and-now and hazard-decision","title":"Here-and-now and hazard-decision","text":"This suggests that choosing the thermal generation before observing the inflow adds a cost of $250. But does this make sense?","category":"page"},{"location":"tutorial/decision_hazard/","page":"Here-and-now and hazard-decision","title":"Here-and-now and hazard-decision","text":"If we look carefully at our decision_hazard model, the incoming value of u_thermal.in in the first stage is fixed to the initial_value of 0. Therefore, we must always meet the full demand with u_hydro, which we cannot do without incurring unmet demand.","category":"page"},{"location":"tutorial/decision_hazard/","page":"Here-and-now and hazard-decision","title":"Here-and-now and hazard-decision","text":"To allow the model to choose an optimal level of u_thermal in the first-stage, we need to add an extra stage that is deterministic with no stage objective.","category":"page"},{"location":"tutorial/decision_hazard/#Fixing-the-decision-hazard","page":"Here-and-now and hazard-decision","title":"Fixing the decision-hazard","text":"","category":"section"},{"location":"tutorial/decision_hazard/","page":"Here-and-now and hazard-decision","title":"Here-and-now and hazard-decision","text":"In the following model, we now have five stages, so that stage t+1 in decision_hazard_2 corresponds to stage t in decision_hazard. We've also added an if-statement, which adds different constraints depending on the node. Note that we need to add an x_storage.out == x_storage.in constraint because the storage can't change in this new first-stage.","category":"page"},{"location":"tutorial/decision_hazard/","page":"Here-and-now and hazard-decision","title":"Here-and-now and hazard-decision","text":"decision_hazard_2 = SDDP.LinearPolicyGraph(\n    stages = 5,  # <-- changed\n    sense = :Min,\n    lower_bound = 0.0,\n    optimizer = HiGHS.Optimizer,\n) do sp, node\n    @variables(sp, begin\n        0 <= x_storage <= 8, (SDDP.State, initial_value = 6)\n        u_thermal >= 0, (SDDP.State, initial_value = 0)\n        u_hydro >= 0\n        u_unmet_demand >= 0\n    end)\n    if node == 1                                        # <-- new\n        @constraint(sp, x_storage.out == x_storage.in)  # <-- new\n        @stageobjective(sp, 0)                          # <-- new\n    else\n        @constraint(sp, u_thermal.in + u_hydro == 9 - u_unmet_demand)\n        @constraint(sp, c_balance, x_storage.out == x_storage.in - u_hydro + 0)\n        SDDP.parameterize(sp, [2, 3]) do ω\n            return set_normalized_rhs(c_balance, ω)\n        end\n        @stageobjective(sp, 500 * u_unmet_demand + 20 * u_thermal.in)\n    end\nend\n\ntrain_and_compute_cost(decision_hazard_2)","category":"page"},{"location":"tutorial/decision_hazard/","page":"Here-and-now and hazard-decision","title":"Here-and-now and hazard-decision","text":"Now we find that the cost of choosing the thermal generation before observing the inflow adds a much more reasonable cost of $10.","category":"page"},{"location":"tutorial/decision_hazard/#Summary","page":"Here-and-now and hazard-decision","title":"Summary","text":"","category":"section"},{"location":"tutorial/decision_hazard/","page":"Here-and-now and hazard-decision","title":"Here-and-now and hazard-decision","text":"To summarize, the difference between here-and-now and wait-and-see variables is a modeling choice.","category":"page"},{"location":"tutorial/decision_hazard/","page":"Here-and-now and hazard-decision","title":"Here-and-now and hazard-decision","text":"To create a here-and-now decision, add it as a state variable to the previous stage","category":"page"},{"location":"tutorial/decision_hazard/","page":"Here-and-now and hazard-decision","title":"Here-and-now and hazard-decision","text":"In some cases, you'll need to add an additional \"first-stage\" problem to enable the model to choose an optimal value for the here-and-now decision variable. You do not need to do this if the first stage is deterministic. You must make sure that the subproblem is feasible for all possible incoming values of the here-and-now decision variable.","category":"page"},{"location":"tutorial/decision_hazard/","page":"Here-and-now and hazard-decision","title":"Here-and-now and hazard-decision","text":"","category":"page"},{"location":"tutorial/decision_hazard/","page":"Here-and-now and hazard-decision","title":"Here-and-now and hazard-decision","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorial/pglib_opf/","page":"Alternative forward models","title":"Alternative forward models","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/tutorial/pglib_opf.jl\"","category":"page"},{"location":"tutorial/pglib_opf/#Alternative-forward-models","page":"Alternative forward models","title":"Alternative forward models","text":"","category":"section"},{"location":"tutorial/pglib_opf/","page":"Alternative forward models","title":"Alternative forward models","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorial/pglib_opf/","page":"Alternative forward models","title":"Alternative forward models","text":"This example demonstrates how to train convex and non-convex models.","category":"page"},{"location":"tutorial/pglib_opf/","page":"Alternative forward models","title":"Alternative forward models","text":"This example uses the following packages:","category":"page"},{"location":"tutorial/pglib_opf/","page":"Alternative forward models","title":"Alternative forward models","text":"using SDDP\nimport Ipopt\nimport PowerModels\nimport Test","category":"page"},{"location":"tutorial/pglib_opf/#Formulation","page":"Alternative forward models","title":"Formulation","text":"","category":"section"},{"location":"tutorial/pglib_opf/","page":"Alternative forward models","title":"Alternative forward models","text":"For our model, we build a simple optimal power flow model with a single hydro-electric generator.","category":"page"},{"location":"tutorial/pglib_opf/","page":"Alternative forward models","title":"Alternative forward models","text":"The formulation of our optimal power flow problem depends on model_type, which must be on of the PowerModels formulations.","category":"page"},{"location":"tutorial/pglib_opf/","page":"Alternative forward models","title":"Alternative forward models","text":"function build_model(model_type)\n    filename = joinpath(@__DIR__, \"pglib_opf_case5_pjm.m\")\n    data = PowerModels.parse_file(filename)\n    return SDDP.PolicyGraph(\n        SDDP.UnicyclicGraph(0.95);\n        sense = :Min,\n        lower_bound = 0.0,\n        optimizer = Ipopt.Optimizer,\n    ) do sp, t\n        power_model = PowerModels.instantiate_model(\n            data,\n            model_type,\n            PowerModels.build_opf;\n            jump_model = sp,\n        )\n        # Now add hydro power models. Assume that generator 5 is hydro, and the\n        # rest are thermal.\n        pg = power_model.var[:it][:pm][:nw][0][:pg][5]\n        sp[:pg] = pg\n        @variable(sp, x >= 0, SDDP.State, initial_value = 10.0)\n        @variable(sp, deficit >= 0)\n        @constraint(sp, balance, x.out == x.in - pg + deficit)\n        @stageobjective(sp, objective_function(sp) + 1e6 * deficit)\n        SDDP.parameterize(sp, [0, 2, 5]) do ω\n            return SDDP.set_normalized_rhs(balance, ω)\n        end\n        return\n    end\nend","category":"page"},{"location":"tutorial/pglib_opf/#Training-a-convex-model","page":"Alternative forward models","title":"Training a convex model","text":"","category":"section"},{"location":"tutorial/pglib_opf/","page":"Alternative forward models","title":"Alternative forward models","text":"We can build and train a convex approximation of the optimal power flow problem.","category":"page"},{"location":"tutorial/pglib_opf/","page":"Alternative forward models","title":"Alternative forward models","text":"The problem with the convex model is that it does not accurately simulate the true dynamics of the problem. Therefore, it under-estimates the true cost of operation.","category":"page"},{"location":"tutorial/pglib_opf/","page":"Alternative forward models","title":"Alternative forward models","text":"convex = build_model(PowerModels.DCPPowerModel)\nSDDP.train(convex; iteration_limit = 10)","category":"page"},{"location":"tutorial/pglib_opf/","page":"Alternative forward models","title":"Alternative forward models","text":"To more accurately simulate the dynamics of the problem, a common approach is to write the cuts representing the policy to a file, and then read them into a non-convex model:","category":"page"},{"location":"tutorial/pglib_opf/","page":"Alternative forward models","title":"Alternative forward models","text":"SDDP.write_cuts_to_file(convex, \"convex.cuts.json\")\nnon_convex = build_model(PowerModels.ACPPowerModel)\nSDDP.read_cuts_from_file(non_convex, \"convex.cuts.json\")","category":"page"},{"location":"tutorial/pglib_opf/","page":"Alternative forward models","title":"Alternative forward models","text":"Now we can simulate non_convex to evaluate the policy.","category":"page"},{"location":"tutorial/pglib_opf/","page":"Alternative forward models","title":"Alternative forward models","text":"result = SDDP.simulate(non_convex, 1)","category":"page"},{"location":"tutorial/pglib_opf/","page":"Alternative forward models","title":"Alternative forward models","text":"A problem with reading and writing the cuts to file is that the cuts have been generated from trial points of the convex model. Therefore, the policy may be arbitrarily bad at points visited by the non-convex model.","category":"page"},{"location":"tutorial/pglib_opf/#Training-a-non-convex-model","page":"Alternative forward models","title":"Training a non-convex model","text":"","category":"section"},{"location":"tutorial/pglib_opf/","page":"Alternative forward models","title":"Alternative forward models","text":"We can also build and train a non-convex formulation of the optimal power flow problem.","category":"page"},{"location":"tutorial/pglib_opf/","page":"Alternative forward models","title":"Alternative forward models","text":"The problem with the non-convex model is that because it is non-convex, SDDP.jl may find a sub-optimal policy. Therefore, it may over-estimate the true cost of operation.","category":"page"},{"location":"tutorial/pglib_opf/","page":"Alternative forward models","title":"Alternative forward models","text":"non_convex = build_model(PowerModels.ACPPowerModel)\nSDDP.train(non_convex; iteration_limit = 10)\nresult = SDDP.simulate(non_convex, 1)","category":"page"},{"location":"tutorial/pglib_opf/#Combining-convex-and-non-convex-models","page":"Alternative forward models","title":"Combining convex and non-convex models","text":"","category":"section"},{"location":"tutorial/pglib_opf/","page":"Alternative forward models","title":"Alternative forward models","text":"To summarize, training with the convex model constructs cuts at points that may never be visited by the non-convex model, and training with the non-convex model may construct arbitrarily poor cuts because a key assumption of SDDP is convexity.","category":"page"},{"location":"tutorial/pglib_opf/","page":"Alternative forward models","title":"Alternative forward models","text":"As a compromise, we can train a policy using a combination of the convex and non-convex models; we'll use the non-convex model to generate trial points on the forward pass, and we'll use the convex model to build cuts on the backward pass.","category":"page"},{"location":"tutorial/pglib_opf/","page":"Alternative forward models","title":"Alternative forward models","text":"convex = build_model(PowerModels.DCPPowerModel)","category":"page"},{"location":"tutorial/pglib_opf/","page":"Alternative forward models","title":"Alternative forward models","text":"non_convex = build_model(PowerModels.ACPPowerModel)","category":"page"},{"location":"tutorial/pglib_opf/","page":"Alternative forward models","title":"Alternative forward models","text":"To do so, we train convex using the SDDP.AlternativeForwardPass forward pass, which simulates the model using non_convex, and we use SDDP.AlternativePostIterationCallback as a post-iteration callback, which copies cuts from the convex model back into the non_convex model.","category":"page"},{"location":"tutorial/pglib_opf/","page":"Alternative forward models","title":"Alternative forward models","text":"SDDP.train(\n    convex;\n    forward_pass = SDDP.AlternativeForwardPass(non_convex),\n    post_iteration_callback = SDDP.AlternativePostIterationCallback(non_convex),\n    iteration_limit = 10,\n)","category":"page"},{"location":"tutorial/pglib_opf/","page":"Alternative forward models","title":"Alternative forward models","text":"In practice, if we were to simulate non_convex now, we should obtain a better policy than either of the two previous approaches.","category":"page"},{"location":"tutorial/pglib_opf/","page":"Alternative forward models","title":"Alternative forward models","text":"","category":"page"},{"location":"tutorial/pglib_opf/","page":"Alternative forward models","title":"Alternative forward models","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SDDP","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img src=\"assets/logo.png\" alt=\"logo\" width=\"150px\"/>","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for SDDP.jl, a package for solving large multistage convex stochastic programming problems using stochastic dual dynamic programming.","category":"page"},{"location":"","page":"Home","title":"Home","text":"SDDP.jl is built on JuMP, so it supports a number of open-source and commercial solvers, making it a powerful and flexible tool for stochastic optimization.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The implementation of the stochastic dual dynamic programming algorithm in SDDP.jl is state of the art, and it includes support for a number of advanced features not commonly found in other implementations. This includes support for:","category":"page"},{"location":"","page":"Home","title":"Home","text":"infinite horizon problems\nconvex risk measures\nmixed-integer state and control variables\npartially observable stochastic processes.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install SDDP.jl as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg\n\njulia> Pkg.add(\"SDDP\")","category":"page"},{"location":"#Resources-for-getting-started","page":"Home","title":"Resources for getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are a few ways to get started with SDDP.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Become familiar with JuMP by reading the JuMP documentation\nRead the introductory tutorial An introduction to SDDP.jl\nBrowse some of the examples, such as Example: deterministic to stochastic","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you need help, please open a GitHub issue.","category":"page"},{"location":"#How-the-documentation-is-structured","page":"Home","title":"How the documentation is structured","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Having a high-level overview of how this documentation is structured will help you know where to look for certain things.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Tutorials contains step-by-step explanations of how to use SDDP.jl. Once you've got SDDP.jl installed, start by reading An introduction to SDDP.jl.\nGuides contains \"how-to\" snippets that demonstrate specific topics within SDDP.jl. A good one to get started on is Debug a model.\nExplanation contains step-by-step explanations of the theory and algorithms that underpin SDDP.jl. If you want a basic understanding of the algorithm behind SDDP.jl, start with Introductory theory.\nExamples contain worked examples of various problems solved using SDDP.jl. A good one to get started on is the Hydro-thermal scheduling problem. In particular, it shows how to solve an infinite horizon problem.\nThe API Reference contains a complete list of the functions you can use in SDDP.jl. Look here if you want to know how to use a particular function.","category":"page"},{"location":"#Citing-SDDP.jl","page":"Home","title":"Citing SDDP.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use SDDP.jl, we ask that you please cite the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{dowson_sddp.jl,\n\ttitle = {{SDDP}.jl: a {Julia} package for stochastic dual dynamic programming},\n\tjournal = {INFORMS Journal on Computing},\n\tauthor = {Dowson, O. and Kapelevich, L.},\n\tdoi = {https://doi.org/10.1287/ijoc.2020.0987},\n\tyear = {2021},\n\tvolume = {33},\n\tissue = {1},\n\tpages = {27-33},\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here is an earlier preprint.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you use the infinite horizon functionality, we ask that you please cite the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{dowson_policy_graph,\n\ttitle = {The policy graph decomposition of multistage stochastic optimization problems},\n\tdoi = {https://doi.org/10.1002/net.21932},\n\tjournal = {Networks},\n\tauthor = {Dowson, O.},\n\tvolume = {76},\n\tissue = {1},\n\tpages = {3-23},\n\tyear = {2020}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here is an earlier preprint.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you use the partially observable functionality, we ask that you please cite the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{dowson_pomsp,\n\ttitle = {Partially observable multistage stochastic programming},\n\tdoi = {https://doi.org/10.1016/j.orl.2020.06.005},\n\tjournal = {Operations Research Letters},\n\tauthor = {Dowson, O. and Morton, D.P. and Pagnoncelli, B.K.},\n\tvolume = {48},\n\tissue = {4},\n\tpages = {505-512},\n\tyear = {2020}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here is an earlier preprint.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you use the objective state functionality, we ask that you please cite the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{downward_objective,\n\ttitle = {Stochastic dual dynamic programming with stagewise-dependent objective uncertainty},\n\tdoi = {https://doi.org/10.1016/j.orl.2019.11.002},\n\tjournal = {Operations Research Letters},\n\tauthor = {Downward, A. and Dowson, O. and Baucke, R.},\n\tvolume = {48},\n\tissue = {1},\n\tpages = {33-39},\n\tyear = {2020}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here is an earlier preprint.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you use the entropic risk measure, we ask that you please cite the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{dowson_entropic,\n\ttitle = {Incorporating convex risk measures into multistage stochastic programming algorithms},\n\tdoi = {https://doi.org/10.1007/s10479-022-04977-w},\n\tjournal = {Annals of Operations Research},\n\tauthor = {Dowson, O. and Morton, D.P. and Pagnoncelli, B.K.},\n\tyear = {2022},\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here is an earlier preprint.","category":"page"},{"location":"examples/all_blacks/","page":"Deterministic All Blacks","title":"Deterministic All Blacks","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/examples/all_blacks.jl\"","category":"page"},{"location":"examples/all_blacks/#Deterministic-All-Blacks","page":"Deterministic All Blacks","title":"Deterministic All Blacks","text":"","category":"section"},{"location":"examples/all_blacks/","page":"Deterministic All Blacks","title":"Deterministic All Blacks","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/all_blacks/","page":"Deterministic All Blacks","title":"Deterministic All Blacks","text":"using SDDP, HiGHS, Test\n\nfunction all_blacks()\n    # Number of time periods, number of seats, R_ij = revenue from selling seat\n    # i at time j, offer_ij = whether an offer for seat i will come at time j\n    (T, N, R, offer) = (3, 2, [3 3 6; 3 3 6], [1 1 0; 1 0 1])\n    model = SDDP.LinearPolicyGraph(\n        stages = T,\n        sense = :Max,\n        upper_bound = 100.0,\n        optimizer = HiGHS.Optimizer,\n    ) do sp, stage\n        # Seat remaining?\n        @variable(sp, 0 <= x[1:N] <= 1, SDDP.State, Bin, initial_value = 1)\n        # Action: accept offer, or don't accept offer\n        @variable(sp, accept_offer, Bin)\n        # Balance on seats\n        @constraint(\n            sp,\n            [i in 1:N],\n            x[i].out == x[i].in - offer[i, stage] * accept_offer\n        )\n        @stageobjective(\n            sp,\n            sum(R[i, stage] * offer[i, stage] * accept_offer for i in 1:N)\n        )\n    end\n    SDDP.train(model; duality_handler = SDDP.LagrangianDuality())\n    @test SDDP.calculate_bound(model) ≈ 9.0\n    return\nend\n\nall_blacks()","category":"page"},{"location":"examples/all_blacks/","page":"Deterministic All Blacks","title":"Deterministic All Blacks","text":"","category":"page"},{"location":"examples/all_blacks/","page":"Deterministic All Blacks","title":"Deterministic All Blacks","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/sldp_example_one/","page":"SLDP: example 1","title":"SLDP: example 1","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/examples/sldp_example_one.jl\"","category":"page"},{"location":"examples/sldp_example_one/#SLDP:-example-1","page":"SLDP: example 1","title":"SLDP: example 1","text":"","category":"section"},{"location":"examples/sldp_example_one/","page":"SLDP: example 1","title":"SLDP: example 1","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/sldp_example_one/","page":"SLDP: example 1","title":"SLDP: example 1","text":"This example is derived from Section 4.2 of the paper: Ahmed, S., Cabral, F. G., & da Costa, B. F. P. (2019). Stochastic Lipschitz Dynamic Programming. Optimization Online. PDF","category":"page"},{"location":"examples/sldp_example_one/","page":"SLDP: example 1","title":"SLDP: example 1","text":"using SDDP, HiGHS, Test\n\nfunction sldp_example_one()\n    model = SDDP.LinearPolicyGraph(\n        stages = 8,\n        lower_bound = 0.0,\n        optimizer = HiGHS.Optimizer,\n    ) do sp, t\n        @variable(sp, x, SDDP.State, initial_value = 2.0)\n        @variables(sp, begin\n            x⁺ >= 0\n            x⁻ >= 0\n            0 <= u <= 1, Bin\n            ω\n        end)\n        @stageobjective(sp, 0.9^(t - 1) * (x⁺ + x⁻))\n        @constraints(sp, begin\n            x.out == x.in + 2 * u - 1 + ω\n            x⁺ >= x.out\n            x⁻ >= -x.out\n        end)\n        points = [\n            -0.3089653673606697,\n            -0.2718277412744214,\n            -0.09611178608243474,\n            0.24645863921577763,\n            0.5204224537256875,\n        ]\n        return SDDP.parameterize(φ -> JuMP.fix(ω, φ), sp, [points; -points])\n    end\n    SDDP.train(model; log_frequency = 10)\n    @test SDDP.calculate_bound(model) <= 1.1675\n    return\nend\n\nsldp_example_one()","category":"page"},{"location":"examples/sldp_example_one/","page":"SLDP: example 1","title":"SLDP: example 1","text":"","category":"page"},{"location":"examples/sldp_example_one/","page":"SLDP: example 1","title":"SLDP: example 1","text":"This page was generated using Literate.jl.","category":"page"},{"location":"guides/simulate_using_a_different_sampling_scheme/#Simulate-using-a-different-sampling-scheme","page":"Simulate using a different sampling scheme","title":"Simulate using a different sampling scheme","text":"","category":"section"},{"location":"guides/simulate_using_a_different_sampling_scheme/","page":"Simulate using a different sampling scheme","title":"Simulate using a different sampling scheme","text":"DocTestSetup = quote\n    using SDDP, HiGHS\nend","category":"page"},{"location":"guides/simulate_using_a_different_sampling_scheme/","page":"Simulate using a different sampling scheme","title":"Simulate using a different sampling scheme","text":"By default, SDDP.simulate will simulate the policy using the distributions of noise terms that were defined when the model was created. We call these in-sample simulations. However, in general the in-sample distributions are an approximation of some underlying probability model which we term the true process. Therefore, SDDP.jl makes it easy to simulate the policy using different probability distributions.","category":"page"},{"location":"guides/simulate_using_a_different_sampling_scheme/","page":"Simulate using a different sampling scheme","title":"Simulate using a different sampling scheme","text":"To demonstrate the different ways of simulating the policy, we're going to use the model from the tutorial Markovian policy graphs.","category":"page"},{"location":"guides/simulate_using_a_different_sampling_scheme/","page":"Simulate using a different sampling scheme","title":"Simulate using a different sampling scheme","text":"using SDDP, HiGHS\n\nΩ = [\n    (inflow = 0.0, fuel_multiplier = 1.5),\n    (inflow = 50.0, fuel_multiplier = 1.0),\n    (inflow = 100.0, fuel_multiplier = 0.75)\n]\n\nmodel = SDDP.MarkovianPolicyGraph(\n    transition_matrices = Array{Float64, 2}[\n        [ 1.0 ]',\n        [ 0.75 0.25 ],\n        [ 0.75 0.25 ; 0.25 0.75 ]\n    ],\n    sense = :Min,\n    lower_bound = 0.0,\n    optimizer = HiGHS.Optimizer\n) do subproblem, node\n    # Unpack the stage and Markov index.\n    t, markov_state = node\n    # Define the state variable.\n    @variable(subproblem, 0 <= volume <= 200, SDDP.State, initial_value = 200)\n    # Define the control variables.\n    @variables(subproblem, begin\n        thermal_generation >= 0\n        hydro_generation   >= 0\n        hydro_spill        >= 0\n        inflow\n    end)\n    # Define the constraints\n    @constraints(subproblem, begin\n        volume.out == volume.in + inflow - hydro_generation - hydro_spill\n        thermal_generation + hydro_generation == 150.0\n    end)\n    # Note how we can use `markov_state` to dispatch an `if` statement.\n    probability = if markov_state == 1  # wet climate state\n        [1/6, 1/3, 1/2]\n    else  # dry climate state\n        [1/2, 1/3, 1/6]\n    end\n\n    fuel_cost = [50.0, 100.0, 150.0]\n    SDDP.parameterize(subproblem, Ω, probability) do ω\n        JuMP.fix(inflow, ω.inflow)\n        @stageobjective(subproblem,\n            ω.fuel_multiplier * fuel_cost[t] * thermal_generation)\n    end\nend\n\nSDDP.train(model; iteration_limit = 10, print_level = 0);\n\nmodel\n\n# output\n\nA policy graph with 5 nodes.\n Node indices: (1, 1), (2, 1), (2, 2), (3, 1), (3, 2)","category":"page"},{"location":"guides/simulate_using_a_different_sampling_scheme/#In-sample-Monte-Carlo-simulation","page":"Simulate using a different sampling scheme","title":"In-sample Monte Carlo simulation","text":"","category":"section"},{"location":"guides/simulate_using_a_different_sampling_scheme/","page":"Simulate using a different sampling scheme","title":"Simulate using a different sampling scheme","text":"To simulate the policy using the data defined when model was created, use SDDP.InSampleMonteCarlo.","category":"page"},{"location":"guides/simulate_using_a_different_sampling_scheme/","page":"Simulate using a different sampling scheme","title":"Simulate using a different sampling scheme","text":"simulations = SDDP.simulate(\n    model, 20, sampling_scheme = SDDP.InSampleMonteCarlo()\n)\n\nsort(unique(\n    [node[:noise_term] for simulation in simulations for node in simulation]\n))\n\n# output\n\n3-element Array{NamedTuple{(:inflow, :fuel_multiplier),Tuple{Float64,Float64}},1}:\n (inflow = 0.0, fuel_multiplier = 1.5)\n (inflow = 50.0, fuel_multiplier = 1.0)\n (inflow = 100.0, fuel_multiplier = 0.75)","category":"page"},{"location":"guides/simulate_using_a_different_sampling_scheme/#Out-of-sample-Monte-Carlo-simulation","page":"Simulate using a different sampling scheme","title":"Out-of-sample Monte Carlo simulation","text":"","category":"section"},{"location":"guides/simulate_using_a_different_sampling_scheme/","page":"Simulate using a different sampling scheme","title":"Simulate using a different sampling scheme","text":"Instead of using the in-sample data, we can perform an out-of-sample simulation of the policy using the SDDP.OutOfSampleMonteCarlo sampling scheme.","category":"page"},{"location":"guides/simulate_using_a_different_sampling_scheme/","page":"Simulate using a different sampling scheme","title":"Simulate using a different sampling scheme","text":"For each node, the SDDP.OutOfSampleMonteCarlo needs to define a new distribution for the transition probabilities between nodes in the policy graph, and a new distribution for the stagewise independent noise terms.","category":"page"},{"location":"guides/simulate_using_a_different_sampling_scheme/","page":"Simulate using a different sampling scheme","title":"Simulate using a different sampling scheme","text":"note: Note\nThe support of the distribution for the stagewise independent noise terms does not have to be the same as the in-sample distributions.","category":"page"},{"location":"guides/simulate_using_a_different_sampling_scheme/","page":"Simulate using a different sampling scheme","title":"Simulate using a different sampling scheme","text":"sampling_scheme = SDDP.OutOfSampleMonteCarlo(model) do node\n    stage, markov_state = node\n    if stage == 0\n        # Called from the root node. Transition to (1, 1) with probability 1.0.\n        # Only return the list of children, _not_ a list of noise terms.\n        return [SDDP.Noise((1, 1), 1.0)]\n    elseif stage == 3\n        # Called from the final node. Return an empty list for the children,\n        # and a single, deterministic realization for the noise terms.\n        children = SDDP.Noise[]\n        noise_terms = [SDDP.Noise((inflow = 75.0, fuel_multiplier = 1.2), 1.0)]\n        return children, noise_terms\n    else\n        # Called from a normal node. Return the in-sample distribution for the\n        # noise terms, but modify the transition probabilities so that the\n        # Markov switching probability is now 50%.\n        probability = markov_state == 1 ? [1/6, 1/3, 1/2] : [1/2, 1/3, 1/6]\n        noise_terms = [SDDP.Noise(ω, p) for (ω, p) in zip(Ω, probability)]\n        children = [\n            SDDP.Noise((stage + 1, 1), 0.5), SDDP.Noise((stage + 1, 2), 0.5)\n        ]\n        return children, noise_terms\n    end\nend\n\nsimulations = SDDP.simulate(model, 1, sampling_scheme = sampling_scheme)\n\nsimulations[1][3][:noise_term]\n\n# output\n\n(inflow = 75.0, fuel_multiplier = 1.2)","category":"page"},{"location":"guides/simulate_using_a_different_sampling_scheme/","page":"Simulate using a different sampling scheme","title":"Simulate using a different sampling scheme","text":"Alternatively, if you only want to modify the stagewise independent noise terms, pass use_insample_transition = true.","category":"page"},{"location":"guides/simulate_using_a_different_sampling_scheme/","page":"Simulate using a different sampling scheme","title":"Simulate using a different sampling scheme","text":"sampling_scheme = SDDP.OutOfSampleMonteCarlo(\n    model, use_insample_transition = true\n) do node\nstage, markov_state = node\n    if stage == 3\n        # Called from the final node. Return a single, deterministic\n        # realization for the noise terms. Don't return the children because we\n        # use the in-sample data.\n        return [SDDP.Noise((inflow = 65.0, fuel_multiplier = 1.1), 1.0)]\n    else\n        # Called from a normal node. Return the in-sample distribution for the\n        # noise terms. Don't return the children because we use the in-sample\n        # data.\n        probability = markov_state == 1 ? [1/6, 1/3, 1/2] : [1/2, 1/3, 1/6]\n        return [SDDP.Noise(ω, p) for (ω, p) in zip(Ω, probability)]\n    end\nend\n\nsimulations = SDDP.simulate(model, 1, sampling_scheme = sampling_scheme)\n\nsimulations[1][3][:noise_term]\n\n# output\n\n(inflow = 65.0, fuel_multiplier = 1.1)","category":"page"},{"location":"guides/simulate_using_a_different_sampling_scheme/#Historical-simulation","page":"Simulate using a different sampling scheme","title":"Historical simulation","text":"","category":"section"},{"location":"guides/simulate_using_a_different_sampling_scheme/","page":"Simulate using a different sampling scheme","title":"Simulate using a different sampling scheme","text":"Instead of performing a Monte Carlo simulation like the previous tutorials, we may want to simulate one particular sequence of noise realizations. This historical simulation can also be conducted by passing a SDDP.Historical sampling scheme to the sampling_scheme keyword of the SDDP.simulate function.","category":"page"},{"location":"guides/simulate_using_a_different_sampling_scheme/","page":"Simulate using a different sampling scheme","title":"Simulate using a different sampling scheme","text":"We can confirm that the historical sequence of nodes was visited by querying the :node_index key of the simulation results.","category":"page"},{"location":"guides/simulate_using_a_different_sampling_scheme/","page":"Simulate using a different sampling scheme","title":"Simulate using a different sampling scheme","text":"simulations = SDDP.simulate(\n    model,\n    sampling_scheme = SDDP.Historical(\n        [((1, 1), Ω[1]), ((2, 2), Ω[3]), ((3, 1), Ω[2])],\n    ),\n)\n\n[stage[:node_index] for stage in simulations[1]]\n\n# output\n\n3-element Vector{Tuple{Int64, Int64}}:\n (1, 1)\n (2, 2)\n (3, 1)","category":"page"},{"location":"guides/simulate_using_a_different_sampling_scheme/","page":"Simulate using a different sampling scheme","title":"Simulate using a different sampling scheme","text":"You can also pass a vector of scenarios, which are sampled sequentially:","category":"page"},{"location":"guides/simulate_using_a_different_sampling_scheme/","page":"Simulate using a different sampling scheme","title":"Simulate using a different sampling scheme","text":"julia> SDDP.Historical(\n           [\n               [\n                   (1, (inflow = 65.0, fuel_multiplier = 1.1)),\n                   (2, (inflow = 10.0, fuel_multiplier = 1.4)), # Can be out-of-sample\n                   (3, (inflow = 65.0, fuel_multiplier = 1.1)),\n               ],\n               [\n                   (1, (inflow = 65.0, fuel_multiplier = 1.1)),\n                   (2, (inflow = 100.0, fuel_multiplier = 0.75)),\n                   (3, (inflow = 0.0, fuel_multiplier = 1.5)),\n               ],\n           ],\n       )\nA Historical sampler with 2 scenarios sampled sequentially.","category":"page"},{"location":"guides/simulate_using_a_different_sampling_scheme/","page":"Simulate using a different sampling scheme","title":"Simulate using a different sampling scheme","text":"Or a vector of scenarios and a corresponding vector of probabilities so that the historical scenarios are sampled probabilistically:","category":"page"},{"location":"guides/simulate_using_a_different_sampling_scheme/","page":"Simulate using a different sampling scheme","title":"Simulate using a different sampling scheme","text":"julia> SDDP.Historical(\n           [\n               [\n                   (1, (inflow = 65.0, fuel_multiplier = 1.1)),\n                   (2, (inflow = 10.0, fuel_multiplier = 1.4)), # Can be out-of-sample\n                   (3, (inflow = 65.0, fuel_multiplier = 1.1)),\n               ],\n               [\n                   (1, (inflow = 65.0, fuel_multiplier = 1.1)),\n                   (2, (inflow = 100.0, fuel_multiplier = 0.75)),\n                   (3, (inflow = 0.0, fuel_multiplier = 1.5)),\n               ],\n           ],\n           [0.3, 0.7],\n       )\nA Historical sampler with 2 scenarios sampled probabilistically.","category":"page"},{"location":"guides/simulate_using_a_different_sampling_scheme/","page":"Simulate using a different sampling scheme","title":"Simulate using a different sampling scheme","text":"tip: Tip\nYour sample space doesn't have to be a NamedTuple. It an be any Julia type! Use a Vector if that is easier, or define your own struct.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/tutorial/first_steps.jl\"","category":"page"},{"location":"tutorial/first_steps/#An-introduction-to-SDDP.jl","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"","category":"section"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"SDDP.jl is a solver for multistage stochastic optimization problems. By multistage, we mean problems in which an agent makes a sequence of decisions over time. By stochastic, we mean that the agent is making decisions in the presence of uncertainty that is gradually revealed over the multiple stages.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"tip: Tip\nMultistage stochastic programming has a lot in common with fields like stochastic optimal control, approximate dynamic programming, Markov decision processes, and reinforcement learning. If it helps, you can think of SDDP as Q-learning in which we approximate the value function using linear programming duality.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"This tutorial is in two parts. First, it is an introduction to the background notation and theory we need, and second, it solves a simple multistage stochastic programming problem.","category":"page"},{"location":"tutorial/first_steps/#What-is-a-node?","page":"An introduction to SDDP.jl","title":"What is a node?","text":"","category":"section"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"A common feature of multistage stochastic optimization problems is that they model an agent controlling a system over time. To simplify things initially, we're going to start by describing what happens at an instant in time at which the agent makes a decision. Only after this will we extend our problem to multiple stages and the notion of time.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"A node is a place at which the agent makes a decision.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"tip: Tip\nFor readers with a stochastic programming background, \"node\" is synonymous with \"stage\" in this section. However, for reasons that will become clear shortly, there can be more than one \"node\" per instant in time, which is why we prefer the term \"node\" over \"stage.\"","category":"page"},{"location":"tutorial/first_steps/#States,-controls,-and-random-variables","page":"An introduction to SDDP.jl","title":"States, controls, and random variables","text":"","category":"section"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"The system that we are modeling can be described by three types of variables.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"State variables track a property of the system over time.\nEach node has an associated incoming state variable (the value of the state at the start of the node), and an outgoing state variable (the value of the state at the end of the node).\nExamples of state variables include the volume of water in a reservoir, the number of units of inventory in a warehouse, or the spatial position of a moving vehicle.\nBecause state variables track the system over time, each node must have the same set of state variables.\nWe denote state variables by the letter x for the incoming state variable and x^prime for the outgoing state variable.\nControl variables are actions taken (implicitly or explicitly) by the agent within a node which modify the state variables.\nExamples of control variables include releases of water from the reservoir, sales or purchasing decisions, and acceleration or braking of the vehicle.\nControl variables are local to a node i, and they can differ between nodes. For example, some control variables may be available within certain nodes.\nWe denote control variables by the letter u.\nRandom variables are finite, discrete, exogenous random variables that the agent observes at the start of a node, before the control variables are decided.\nExamples of random variables include rainfall inflow into a reservoir, probabilistic perishing of inventory, and steering errors in a vehicle.\nRandom variables are local to a node i, and they can differ between nodes. For example, some nodes may have random variables, and some nodes may not.\nWe denote random variables by the Greek letter omega and the sample space from which they are drawn by Omega_i. The probability of sampling omega is denoted p_omega for simplicity.\nImportantly, the random variable associated with node i is independent of the random variables in all other nodes.","category":"page"},{"location":"tutorial/first_steps/#Dynamics","page":"An introduction to SDDP.jl","title":"Dynamics","text":"","category":"section"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"In a node i, the three variables are related by a transition function, which maps the incoming state, the controls, and the random variables to the outgoing state as follows: x^prime = T_i(x u omega).","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"As a result of entering a node i with the incoming state x, observing random variable omega, and choosing control u, the agent incurs a cost C_i(x u omega). (If the agent is a maximizer, this can be a profit, or a negative cost.) We call C_i the stage objective.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"To choose their control variables in node i, the agent uses a decision rule u = pi_i(x omega), which is a function that maps the incoming state variable and observation of the random variable to a control u. This control must satisfy some feasibility requirements u in U_i(x omega).","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"Here is a schematic which we can use to visualize a single node:","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"(Image: Hazard-decision node)","category":"page"},{"location":"tutorial/first_steps/#Policy-graphs","page":"An introduction to SDDP.jl","title":"Policy graphs","text":"","category":"section"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"Now that we have a node, we need to connect multiple nodes together to form a multistage stochastic program. We call the graph created by connecting nodes together a policy graph.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"The simplest type of policy graph is a linear policy graph. Here's a linear policy graph with three nodes:","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"(Image: Linear policy graph)","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"Here we have dropped the notations inside each node and replaced them by a label (1, 2, and 3) to represent nodes i=1, i=2, and i=3.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"In addition to nodes 1, 2, and 3, there is also a root node (the circle), and three arcs. Each arc has an origin node and a destination node, like 1 => 2, and a corresponding probability of transitioning from the origin to the destination. Unless specified, we assume that the arc probabilities are uniform over the number of outgoing arcs. Thus, in this picture the arc probabilities are all 1.0.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"State variables flow long the arcs of the graph. Thus, the outgoing state variable x^prime from node 1 becomes the incoming state variable x to node 2, and so on.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"We denote the set of nodes by mathcalN, the root node by R, and the probability of transitioning from node i to node j by p_ij. (If no arc exists, then p_ij = 0.) We define the set of successors of node i as i^+ = j in mathcalN  p_ij  0.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"Each node in the graph corresponds to a place at which the agent makes a decision, and we call moments in time at which the agent makes a decision stages. By convention, we try to draw policy graphs from left-to-right, with the stages as columns. There can be more than one node in a stage! Here's an example of a structure we call Markovian policy graphs:","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"(Image: Markovian policy graph)","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"Here each column represents a moment in time, the squiggly lines represent stochastic rainfall, and the rows represent the world in two discrete states: El Niño and La Niña. In the El Niño states, the distribution of the rainfall random variable is different to the distribution of the rainfall random variable in the La Niña states, and there is some switching probability between the two states that can be modelled by a Markov chain.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"Moreover, policy graphs can have cycles! This allows them to model infinite horizon problems. Here's another example, taken from the paper Dowson (2020):","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"(Image: POWDer policy graph)","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"The columns represent time, and the rows represent different states of the world. In this case, the rows represent different prices that milk can be sold for at the end of each year. The squiggly lines denote a multivariate random variable that models the weekly amount of rainfall that occurs.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"note: Note\nThe sum of probabilities on the outgoing arcs of node i can be less than 1, i.e., sumlimits_jin i^+ p_ij le 1. What does this mean? One interpretation is that the probability is a discount factor. Another interpretation is that there is an implicit \"zero\" node that we have not modeled, with p_i0 = 1 - sumlimits_jin i^+ p_ij. This zero node has C_0(x u omega) = 0, and 0^+ = varnothing.","category":"page"},{"location":"tutorial/first_steps/#More-notation","page":"An introduction to SDDP.jl","title":"More notation","text":"","category":"section"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"Recall that each node i has a decision rule u = pi_i(x omega), which is a function that maps the incoming state variable and observation of the random variable to a control u.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"The set of decision rules, with one element for each node in the policy graph, is called a policy.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"The goal of the agent is to find a policy that minimizes the expected cost of starting at the root node with some initial condition x_R, and proceeding from node to node along the probabilistic arcs until they reach a node with no outgoing arcs (or it reaches an implicit \"zero\" node).","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"min_pi mathbbE_i in R^+ omega in Omega_iV_i^pi(x_R omega)","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"where","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"V_i^pi(x omega) = C_i(x u omega) + mathbbE_j in i^+ varphi in Omega_jV_j(x^prime varphi)","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"where u = pi_i(x omega) in U_i(x omega), and x^prime = T_i(x u omega).","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"The expectations are a bit complicated, but they are equivalent to:","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"mathbbE_j in i^+ varphi in Omega_jV_j(x^prime varphi) = sumlimits_j in i^+ p_ij sumlimits_varphi in Omega_j p_varphiV_j(x^prime varphi)","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"An optimal policy is the set of decision rules that the agent can use to make decisions and achieve the smallest expected cost.","category":"page"},{"location":"tutorial/first_steps/#Assumptions","page":"An introduction to SDDP.jl","title":"Assumptions","text":"","category":"section"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"warning: Warning\nThis section is important!","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"The space of problems you can model with this framework is very large. Too large, in fact, for us to form tractable solution algorithms for! Stochastic dual dynamic programming requires the following assumptions in order to work:","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"Assumption 1: finite nodes","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"There is a finite number of nodes in mathcalN.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"Assumption 2: finite random variables","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"The sample space Omega_i is finite and discrete for each node iinmathcalN.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"Assumption 3: convex problems","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"Given fixed omega, C_i(x u omega) is a convex function, T_i(x u omega) is linear, and  U_i(x u omega) is a non-empty, bounded convex set with respect to x and u.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"Assumption 4: no infinite loops","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"For all loops in the policy graph, the product of the arc transition probabilities around the loop is strictly less than 1.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"Assumption 5: relatively complete recourse","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"This is a technical but important assumption. See Relatively complete recourse for more details.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"note: Note\nSDDP.jl relaxes assumption (3) to allow for integer state and control variables, but we won't go into the details here. Assumption (4) essentially means that we obtain a discounted-cost solution for infinite-horizon problems, instead of an average-cost solution; see Dowson (2020) for details.","category":"page"},{"location":"tutorial/first_steps/#Dynamic-programming-and-subproblems","page":"An introduction to SDDP.jl","title":"Dynamic programming and subproblems","text":"","category":"section"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"Now that we have formulated our problem, we need some ways of computing optimal decision rules. One way is to just use a heuristic like \"choose a control randomly from the set of feasible controls.\" However, such a policy is unlikely to be optimal.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"A better way of obtaining an optimal policy is to use Bellman's principle of optimality, a.k.a Dynamic Programming, and define a recursive subproblem as follows:","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"beginaligned\nV_i(x omega) = minlimits_barx x^prime u   C_i(barx u omega) + mathbbE_j in i^+ varphi in Omega_jV_j(x^prime varphi)\n x^prime = T_i(barx u omega) \n u in U_i(barx omega) \n barx = x\nendaligned","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"Our decision rule, pi_i(x omega), solves this optimization problem and returns a u^* corresponding to an optimal solution.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"note: Note\nWe add barx as a decision variable, along with the fishing constraint barx = x for two reasons: it makes it obvious that formulating a problem with x times u results in a bilinear program instead of a linear program (see Assumption 3), and it simplifies the implementation of the SDDP algorithm.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"These subproblems are very difficult to solve exactly, because they involve recursive optimization problems with lots of nested expectations.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"Therefore, instead of solving them exactly, SDDP.jl works by iteratively approximating the expectation term of each subproblem, which is also called the cost-to-go term. For now, you don't need to understand the details, other than that there is a nasty cost-to-go term that we deal with behind-the-scenes.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"The subproblem view of a multistage stochastic program is also important, because it provides a convenient way of communicating the different parts of the broader problem, and it is how we will communicate the problem to SDDP.jl. All we need to do is drop the cost-to-go term and fishing constraint, and define a new subproblem SP as:","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"beginaligned\ntextttSP_i(x omega)  minlimits_barx x^prime u   C_i(barx u omega) \n x^prime = T_i(barx u omega) \n u in U_i(barx omega)\nendaligned","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"note: Note\nWhen we talk about formulating a subproblem with SDDP.jl, this is the formulation we mean.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"We've retained the transition function and uncertainty set because they help to motivate the different components of the subproblem. However, in general, the subproblem can be more general. A better (less restrictive) representation might be:","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"beginaligned\ntextttSP_i(x omega)  minlimits_barx x^prime u   C_i(barx x^prime u omega) \n (barx x^prime u) in mathcalX_i(omega)\nendaligned","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"Note that the outgoing state variable can appear in the objective, and we can add constraints involving the incoming and outgoing state variables. It should be obvious how to map between the two representations.","category":"page"},{"location":"tutorial/first_steps/#Example:-hydro-thermal-scheduling","page":"An introduction to SDDP.jl","title":"Example: hydro-thermal scheduling","text":"","category":"section"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"Hydrothermal scheduling is the most common application of stochastic dual dynamic programming. To illustrate some of the basic functionality of SDDP.jl, we implement a very simple model of the hydrothermal scheduling problem.","category":"page"},{"location":"tutorial/first_steps/#Problem-statement","page":"An introduction to SDDP.jl","title":"Problem statement","text":"","category":"section"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"We consider the problem of scheduling electrical generation over three weeks in order to meet a known demand of 150 MWh in each week.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"There are two generators: a thermal generator, and a hydro generator. In each week, the agent needs to decide how much energy to generate from thermal, and how much energy to generate from hydro.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"The thermal generator has a short-run marginal cost of $50/MWh in the first stage, $100/MWh in the second stage, and $150/MWh in the third stage.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"The hydro generator has a short-run marginal cost of $0/MWh.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"The hydro generator draws water from a reservoir which has a maximum capacity of 200 MWh. (Although water is usually measured in m³, we measure it in the energy-equivalent MWh to simplify things. In practice, there is a conversion function between m³ flowing throw the turbine and MWh.) At the start of the first time period, the reservoir is full.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"In addition to the ability to generate electricity by passing water through the hydroelectric turbine, the hydro generator can also spill water down a spillway (bypassing the turbine) in order to prevent the water from over-topping the dam. We assume that there is no cost of spillage.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"In addition to water leaving the reservoir, water that flows into the reservoir through rainfall or rivers are referred to as inflows. These inflows are uncertain, and are the cause of the main trade-off in hydro-thermal scheduling: the desire to use water now to generate cheap electricity, against the risk that future inflows will be low, leading to blackouts or expensive thermal generation.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"For our simple model, we assume that the inflows can be modelled by a discrete distribution with the three outcomes given in the following table:","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"ω 0 50 100\nP(ω) 1/3 1/3 1/3","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"The value of the noise (the random variable) is observed by the agent at the start of each stage. This makes the problem a wait-and-see or hazard-decision formulation.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"The goal of the agent is to minimize the expected cost of generation over the three weeks.","category":"page"},{"location":"tutorial/first_steps/#Formulating-the-problem","page":"An introduction to SDDP.jl","title":"Formulating the problem","text":"","category":"section"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"Before going further, we need to load SDDP.jl:","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"using SDDP","category":"page"},{"location":"tutorial/first_steps/#Graph-structure","page":"An introduction to SDDP.jl","title":"Graph structure","text":"","category":"section"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"First, we need to identify the structure of the policy graph. From the problem statement, we want to model the problem over three weeks in weekly stages. Therefore, the policy graph is a linear graph with three stages:","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"graph = SDDP.LinearGraph(3)","category":"page"},{"location":"tutorial/first_steps/#Building-the-subproblem","page":"An introduction to SDDP.jl","title":"Building the subproblem","text":"","category":"section"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"Next, we need to construct the associated subproblem for each node in graph. To do so, we need to provide SDDP.jl a function which takes two arguments. The first is subproblem::Model, which is an empty JuMP model. The second is node, which is the name of each node in the policy graph. If the graph is linear, SDDP defaults to naming the nodes using the integers in 1:T. Here's an example that we are going to flesh out over the next few paragraphs:","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"function subproblem_builder(subproblem::Model, node::Int)\n    # ... stuff to go here ...\n    return subproblem\nend","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"warning: Warning\nIf you use a different type of graph, node may be a type different to Int. For example, in SDDP.MarkovianGraph, node is a Tuple{Int,Int}.","category":"page"},{"location":"tutorial/first_steps/#State-variables","page":"An introduction to SDDP.jl","title":"State variables","text":"","category":"section"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"The first part of the subproblem we need to identify are the state variables. Since we only have one reservoir, there is only one state variable, volume, the volume of water in the reservoir [MWh].","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"The volume had bounds of [0, 200], and the reservoir was full at the start of time, so x_R = 200.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"We add state variables to our subproblem using JuMP's @variable macro. However, in addition to the usual syntax, we also pass SDDP.State, and we need to provide the initial value (x_R) using the initial_value keyword.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"function subproblem_builder(subproblem::Model, node::Int)\n    # State variables\n    @variable(subproblem, 0 <= volume <= 200, SDDP.State, initial_value = 200)\n    return subproblem\nend","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"The syntax for adding a state variable is a little obtuse, because volume is not single JuMP variable. Instead, volume is a struct with two fields, .in and .out, corresponding to the incoming and outgoing state variables respectively.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"note: Note\nWe don't need to add the fishing constraint barx = x; SDDP.jl does this automatically.","category":"page"},{"location":"tutorial/first_steps/#Control-variables","page":"An introduction to SDDP.jl","title":"Control variables","text":"","category":"section"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"The next part of the subproblem we need to identify are the control variables. The control variables for our problem are:","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"thermal_generation: the quantity of energy generated from thermal [MWh/week]\nhydro_generation: the quantity of energy generated from hydro [MWh/week]\nhydro_spill: the volume of water spilled from the reservoir in each week [MWh/week]","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"Each of these variables is non-negative.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"We add control variables to our subproblem as normal JuMP variables, using @variable or @variables:","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"function subproblem_builder(subproblem::Model, node::Int)\n    # State variables\n    @variable(subproblem, 0 <= volume <= 200, SDDP.State, initial_value = 200)\n    # Control variables\n    @variables(subproblem, begin\n        thermal_generation >= 0\n        hydro_generation >= 0\n        hydro_spill >= 0\n    end)\n    return subproblem\nend","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"tip: Tip\nModeling is an art, and a tricky part of that art is figuring out which variables are state variables, and which are control variables. A good rule is: if you need a value of a control variable in some future node to make a decision, it is a state variable instead.","category":"page"},{"location":"tutorial/first_steps/#Random-variables","page":"An introduction to SDDP.jl","title":"Random variables","text":"","category":"section"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"The next step is to identify any random variables. In our example, we had","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"inflow: the quantity of water that flows into the reservoir each week [MWh/week]","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"To add an uncertain variable to the model, we create a new JuMP variable inflow, and then call the function SDDP.parameterize. The SDDP.parameterize function takes three arguments: the subproblem, a vector of realizations, and a corresponding vector of probabilities.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"function subproblem_builder(subproblem::Model, node::Int)\n    # State variables\n    @variable(subproblem, 0 <= volume <= 200, SDDP.State, initial_value = 200)\n    # Control variables\n    @variables(subproblem, begin\n        thermal_generation >= 0\n        hydro_generation >= 0\n        hydro_spill >= 0\n    end)\n    # Random variables\n    @variable(subproblem, inflow)\n    Ω = [0.0, 50.0, 100.0]\n    P = [1 / 3, 1 / 3, 1 / 3]\n    SDDP.parameterize(subproblem, Ω, P) do ω\n        return JuMP.fix(inflow, ω)\n    end\n    return subproblem\nend","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"Note how we use the JuMP function JuMP.fix to set the value of the inflow variable to ω.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"warning: Warning\nSDDP.parameterize can only be called once in each subproblem definition! If your random variable is multi-variate, read Add multi-dimensional noise terms.","category":"page"},{"location":"tutorial/first_steps/#Transition-function-and-constraints","page":"An introduction to SDDP.jl","title":"Transition function and constraints","text":"","category":"section"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"Now that we've identified our variables, we can define the transition function and the constraints.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"For our problem, the state variable is the volume of water in the reservoir. The volume of water decreases in response to water being used for hydro generation and spillage. So the transition function is: volume.out = volume.in - hydro_generation - hydro_spill + inflow. (Note how we use volume.in and volume.out to refer to the incoming and outgoing state variables.)","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"There is also a constraint that the total generation must sum to 150 MWh.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"Both the transition function and any additional constraint are added using JuMP's @constraint and @constraints macro.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"function subproblem_builder(subproblem::Model, node::Int)\n    # State variables\n    @variable(subproblem, 0 <= volume <= 200, SDDP.State, initial_value = 200)\n    # Control variables\n    @variables(subproblem, begin\n        thermal_generation >= 0\n        hydro_generation >= 0\n        hydro_spill >= 0\n    end)\n    # Random variables\n    @variable(subproblem, inflow)\n    Ω = [0.0, 50.0, 100.0]\n    P = [1 / 3, 1 / 3, 1 / 3]\n    SDDP.parameterize(subproblem, Ω, P) do ω\n        return JuMP.fix(inflow, ω)\n    end\n    # Transition function and constraints\n    @constraints(\n        subproblem,\n        begin\n            volume.out == volume.in - hydro_generation - hydro_spill + inflow\n            demand_constraint, hydro_generation + thermal_generation == 150\n        end\n    )\n    return subproblem\nend","category":"page"},{"location":"tutorial/first_steps/#Objective-function","page":"An introduction to SDDP.jl","title":"Objective function","text":"","category":"section"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"Finally, we need to add an objective function using @stageobjective. The objective of the agent is to minimize the cost of thermal generation. This is complicated by a fuel cost that depends on the node.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"One possibility is to use an if statement on node to define the correct objective:","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"function subproblem_builder(subproblem::Model, node::Int)\n    # State variables\n    @variable(subproblem, 0 <= volume <= 200, SDDP.State, initial_value = 200)\n    # Control variables\n    @variables(subproblem, begin\n        thermal_generation >= 0\n        hydro_generation >= 0\n        hydro_spill >= 0\n    end)\n    # Random variables\n    @variable(subproblem, inflow)\n    Ω = [0.0, 50.0, 100.0]\n    P = [1 / 3, 1 / 3, 1 / 3]\n    SDDP.parameterize(subproblem, Ω, P) do ω\n        return JuMP.fix(inflow, ω)\n    end\n    # Transition function and constraints\n    @constraints(\n        subproblem,\n        begin\n            volume.out == volume.in - hydro_generation - hydro_spill + inflow\n            demand_constraint, hydro_generation + thermal_generation == 150\n        end\n    )\n    # Stage-objective\n    if node == 1\n        @stageobjective(subproblem, 50 * thermal_generation)\n    elseif node == 2\n        @stageobjective(subproblem, 100 * thermal_generation)\n    else\n        @assert node == 3\n        @stageobjective(subproblem, 150 * thermal_generation)\n    end\n    return subproblem\nend","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"A second possibility is to use an array of fuel costs, and use node to index the correct value:","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"function subproblem_builder(subproblem::Model, node::Int)\n    # State variables\n    @variable(subproblem, 0 <= volume <= 200, SDDP.State, initial_value = 200)\n    # Control variables\n    @variables(subproblem, begin\n        thermal_generation >= 0\n        hydro_generation >= 0\n        hydro_spill >= 0\n    end)\n    # Random variables\n    @variable(subproblem, inflow)\n    Ω = [0.0, 50.0, 100.0]\n    P = [1 / 3, 1 / 3, 1 / 3]\n    SDDP.parameterize(subproblem, Ω, P) do ω\n        return JuMP.fix(inflow, ω)\n    end\n    # Transition function and constraints\n    @constraints(\n        subproblem,\n        begin\n            volume.out == volume.in - hydro_generation - hydro_spill + inflow\n            demand_constraint, hydro_generation + thermal_generation == 150\n        end\n    )\n    # Stage-objective\n    fuel_cost = [50, 100, 150]\n    @stageobjective(subproblem, fuel_cost[node] * thermal_generation)\n    return subproblem\nend","category":"page"},{"location":"tutorial/first_steps/#Constructing-the-model","page":"An introduction to SDDP.jl","title":"Constructing the model","text":"","category":"section"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"Now that we've written our subproblem, we need to construct the full model. For that, we're going to need a linear solver. Let's choose HiGHS:","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"using HiGHS","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"warning: Warning\nIn larger problems, you should use a more robust commercial LP solver like Gurobi. Read Words of warning for more details.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"Then, we can create a full model using SDDP.PolicyGraph, passing our subproblem_builder function as the first argument, and our graph as the second:","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"model = SDDP.PolicyGraph(\n    subproblem_builder,\n    graph;\n    sense = :Min,\n    lower_bound = 0.0,\n    optimizer = HiGHS.Optimizer,\n)","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"sense: the optimization sense. Must be :Min or :Max.\nlower_bound: you must supply a valid bound on the objective. For our problem, we know that we cannot incur a negative cost so $0 is a valid lower bound.\noptimizer: This is borrowed directly from JuMP's Model constructor: Model(HiGHS.Optimizer)","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"Because linear policy graphs are the most commonly used structure, we can use SDDP.LinearPolicyGraph instead of passing SDDP.LinearGraph(3) to SDDP.PolicyGraph.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"model = SDDP.LinearPolicyGraph(\n    subproblem_builder;\n    stages = 3,\n    sense = :Min,\n    lower_bound = 0.0,\n    optimizer = HiGHS.Optimizer,\n)","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"There is also the option is to use Julia's do syntax to avoid needing to define a subproblem_builder function separately:","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"model = SDDP.LinearPolicyGraph(\n    stages = 3,\n    sense = :Min,\n    lower_bound = 0.0,\n    optimizer = HiGHS.Optimizer,\n) do subproblem, node\n    # State variables\n    @variable(subproblem, 0 <= volume <= 200, SDDP.State, initial_value = 200)\n    # Control variables\n    @variables(subproblem, begin\n        thermal_generation >= 0\n        hydro_generation >= 0\n        hydro_spill >= 0\n    end)\n    # Random variables\n    @variable(subproblem, inflow)\n    Ω = [0.0, 50.0, 100.0]\n    P = [1 / 3, 1 / 3, 1 / 3]\n    SDDP.parameterize(subproblem, Ω, P) do ω\n        return JuMP.fix(inflow, ω)\n    end\n    # Transition function and constraints\n    @constraints(\n        subproblem,\n        begin\n            volume.out == volume.in - hydro_generation - hydro_spill + inflow\n            demand_constraint, hydro_generation + thermal_generation == 150\n        end\n    )\n    # Stage-objective\n    if node == 1\n        @stageobjective(subproblem, 50 * thermal_generation)\n    elseif node == 2\n        @stageobjective(subproblem, 100 * thermal_generation)\n    else\n        @assert node == 3\n        @stageobjective(subproblem, 150 * thermal_generation)\n    end\nend","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"info: Info\nJulia's do syntax is just a different way of passing an anonymous function inner to some function outer which takes inner as the first argument. For example, given:outer(inner::Function, x, y) = inner(x, y)thenouter(1, 2) do x, y\n    return x^2 + y^2\nendis equivalent to:outer((x, y) -> x^2 + y^2, 1, 2)For our purpose, inner is subproblem_builder, and outer is SDDP.PolicyGraph.","category":"page"},{"location":"tutorial/first_steps/#Training-a-policy","page":"An introduction to SDDP.jl","title":"Training a policy","text":"","category":"section"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"Now we have a model, which is a description of the policy graph, we need to train a policy. Models can be trained using the SDDP.train function. It accepts a number of keyword arguments. iteration_limit terminates the training after the provided number of iterations.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"SDDP.train(model; iteration_limit = 10)","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"There's a lot going on in this printout! Let's break it down.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"The first section, \"problem,\" gives some problem statistics. In this example there are 3 nodes, 1 state variable, and 27 scenarios (3^3). We haven't solved this problem before so there are no existing cuts.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"The \"options\" section lists some options we are using to solve the problem. For more information on the numerical stability report, read the Numerical stability report section.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"The \"subproblem structure\" section also needs explaining. This looks at all of the nodes in the policy graph and reports the minimum and maximum number of variables and each constraint type in the corresponding subproblem. In this case each subproblem has 7 variables and various numbers of different constraint types. Note that the exact numbers may not correspond to the formulation as you wrote it, because SDDP.jl adds some extra variables for the cost-to-go function.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"Then comes the iteration log, which is the main part of the printout. It has the following columns:","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"iteration: the SDDP iteration\nsimulation: the cost of the single forward pass simulation for that iteration. This value is stochastic and is not guaranteed to improve over time. However, it's useful to check that the units are reasonable, and that it is not deterministic if you intended for the problem to be stochastic, etc.\nbound: this is a lower bound (upper if maximizing) for the value of the optimal policy. This should be monotonically improving (increasing if minimizing, decreasing if maximizing).\ntime (s): the total number of seconds spent solving so far\nsolves: the total number of subproblem solves to date. This can be very large!\npid: the ID of the processor used to solve that iteration. This should be 1 unless you are using parallel computation.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"In addition, if the first character of a line is †, then SDDP.jl experienced numerical issues during the solve, but successfully recovered.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"The printout finishes with some summary statistics:","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"status: why did the solver stop?\ntotal time (s), best bound, and total solves are the values from the last iteration of the solve.\nsimulation ci: a confidence interval that estimates the quality of the policy from the Simulation column.\nnumeric issues: the number of iterations that experienced numerical issues.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"warning: Warning\nThe simulation ci result can be misleading if you run a small number of iterations, or if the initial simulations are very bad. On a more technical note, it is an in-sample simulation, which may not reflect the true performance of the policy. See Obtaining bounds for more details.","category":"page"},{"location":"tutorial/first_steps/#Obtaining-the-decision-rule","page":"An introduction to SDDP.jl","title":"Obtaining the decision rule","text":"","category":"section"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"After training a policy, we can create a decision rule using SDDP.DecisionRule:","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"rule = SDDP.DecisionRule(model; node = 1)","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"Then, to evaluate the decision rule, we use SDDP.evaluate:","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"solution = SDDP.evaluate(\n    rule;\n    incoming_state = Dict(:volume => 150.0),\n    noise = 50.0,\n    controls_to_record = [:hydro_generation, :thermal_generation],\n)","category":"page"},{"location":"tutorial/first_steps/#Simulating-the-policy","page":"An introduction to SDDP.jl","title":"Simulating the policy","text":"","category":"section"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"Once you have a trained policy, you can also simulate it using SDDP.simulate. The return value from simulate is a vector with one element for each replication. Each element is itself a vector, with one element for each stage. Each element, corresponding to a particular stage in a particular replication, is a dictionary that records information from the simulation.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"simulations = SDDP.simulate(\n    # The trained model to simulate.\n    model,\n    # The number of replications.\n    100,\n    # A list of names to record the values of.\n    [:volume, :thermal_generation, :hydro_generation, :hydro_spill],\n)\n\nreplication = 1\nstage = 2\nsimulations[replication][stage]","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"Ignore many of the entries for now;  they will be relevant later.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"One element of interest is :volume.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"outgoing_volume = map(simulations[1]) do node\n    return node[:volume].out\nend","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"Another is :thermal_generation.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"thermal_generation = map(simulations[1]) do node\n    return node[:thermal_generation]\nend","category":"page"},{"location":"tutorial/first_steps/#Obtaining-bounds","page":"An introduction to SDDP.jl","title":"Obtaining bounds","text":"","category":"section"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"Because the optimal policy is stochastic, one common approach to quantify the quality of the policy is to construct a confidence interval for the expected cost by summing the stage objectives along each simulation.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"objectives = map(simulations) do simulation\n    return sum(stage[:stage_objective] for stage in simulation)\nend\n\nμ, ci = SDDP.confidence_interval(objectives)\nprintln(\"Confidence interval: \", μ, \" ± \", ci)","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"This confidence interval is an estimate for an upper bound of the policy's quality. We can calculate the lower bound using SDDP.calculate_bound.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"println(\"Lower bound: \", SDDP.calculate_bound(model))","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"tip: Tip\nThe upper- and lower-bounds are reversed if maximizing, i.e., SDDP.calculate_bound. returns an upper bound.","category":"page"},{"location":"tutorial/first_steps/#Custom-recorders","page":"An introduction to SDDP.jl","title":"Custom recorders","text":"","category":"section"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"In addition to simulating the primal values of variables, we can also pass custom recorder functions. Each of these functions takes one argument, the JuMP subproblem corresponding to each node. This function gets called after we have solved each node as we traverse the policy graph in the simulation.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"For example, the dual of the demand constraint (which we named demand_constraint) corresponds to the price we should charge for electricity, since it represents the cost of each additional unit of demand. To calculate this, we can go:","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"simulations = SDDP.simulate(\n    model,\n    1,  ## Perform a single simulation\n    custom_recorders = Dict{Symbol,Function}(\n        :price => (sp::JuMP.Model) -> JuMP.dual(sp[:demand_constraint]),\n    ),\n)\n\nprices = map(simulations[1]) do node\n    return node[:price]\nend","category":"page"},{"location":"tutorial/first_steps/#Extracting-the-marginal-water-values","page":"An introduction to SDDP.jl","title":"Extracting the marginal water values","text":"","category":"section"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"Finally, we can use SDDP.ValueFunction and SDDP.evaluate to obtain and evaluate the value function at different points in the state-space.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"note: Note\nBy \"value function\" we mean mathbbE_j in i^+ varphi in Omega_jV_j(x^prime varphi), note the function V_i(x omega).","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"First, we construct a value function from the first subproblem:","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"V = SDDP.ValueFunction(model; node = 1)","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"Then we can evaluate V at a point:","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"cost, price = SDDP.evaluate(V, Dict(\"volume\" => 10))","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"This returns the cost-to-go (cost), and the gradient of the cost-to-go function with respect to each state variable. Note that since we are minimizing, the price has a negative sign: each additional unit of water leads to a decrease in the expected long-run cost.","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"","category":"page"},{"location":"tutorial/first_steps/","page":"An introduction to SDDP.jl","title":"An introduction to SDDP.jl","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/StochDynamicProgramming.jl_stock/","page":"StochDynamicProgramming: the stock problem","title":"StochDynamicProgramming: the stock problem","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/examples/StochDynamicProgramming.jl_stock.jl\"","category":"page"},{"location":"examples/StochDynamicProgramming.jl_stock/#StochDynamicProgramming:-the-stock-problem","page":"StochDynamicProgramming: the stock problem","title":"StochDynamicProgramming: the stock problem","text":"","category":"section"},{"location":"examples/StochDynamicProgramming.jl_stock/","page":"StochDynamicProgramming: the stock problem","title":"StochDynamicProgramming: the stock problem","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/StochDynamicProgramming.jl_stock/","page":"StochDynamicProgramming: the stock problem","title":"StochDynamicProgramming: the stock problem","text":"This example comes from StochDynamicProgramming.jl.","category":"page"},{"location":"examples/StochDynamicProgramming.jl_stock/","page":"StochDynamicProgramming: the stock problem","title":"StochDynamicProgramming: the stock problem","text":"using SDDP, HiGHS, Test\n\nfunction stock_example()\n    model = SDDP.PolicyGraph(\n        SDDP.LinearGraph(5),\n        lower_bound = -2,\n        optimizer = HiGHS.Optimizer,\n    ) do sp, stage\n        @variable(sp, 0 <= state <= 1, SDDP.State, initial_value = 0.5)\n        @variable(sp, 0 <= control <= 0.5)\n        @variable(sp, ξ)\n        @constraint(sp, state.out == state.in - control + ξ)\n        SDDP.parameterize(sp, 0.0:1/30:0.3) do ω\n            return JuMP.fix(ξ, ω)\n        end\n        @stageobjective(sp, (sin(3 * stage) - 1) * control)\n    end\n    SDDP.train(model; log_frequency = 10)\n    @test SDDP.calculate_bound(model) ≈ -1.471 atol = 0.001\n    simulation_results = SDDP.simulate(model, 1_000)\n    @test length(simulation_results) == 1_000\n    μ = SDDP.Statistics.mean(\n        sum(data[:stage_objective] for data in simulation) for\n        simulation in simulation_results\n    )\n    @test μ ≈ -1.471 atol = 0.05\n    return\nend\n\nstock_example()","category":"page"},{"location":"examples/StochDynamicProgramming.jl_stock/","page":"StochDynamicProgramming: the stock problem","title":"StochDynamicProgramming: the stock problem","text":"","category":"page"},{"location":"examples/StochDynamicProgramming.jl_stock/","page":"StochDynamicProgramming: the stock problem","title":"StochDynamicProgramming: the stock problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/agriculture_mccardle_farm/","page":"The farm planning problem","title":"The farm planning problem","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/examples/agriculture_mccardle_farm.jl\"","category":"page"},{"location":"examples/agriculture_mccardle_farm/#The-farm-planning-problem","page":"The farm planning problem","title":"The farm planning problem","text":"","category":"section"},{"location":"examples/agriculture_mccardle_farm/","page":"The farm planning problem","title":"The farm planning problem","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/agriculture_mccardle_farm/","page":"The farm planning problem","title":"The farm planning problem","text":"There are four stages. The first stage is a deterministic planning stage. The next three are wait-and-see operational stages. The uncertainty in the three operational stages is a Markov chain for weather. There are three Markov states: dry, normal, and wet.","category":"page"},{"location":"examples/agriculture_mccardle_farm/","page":"The farm planning problem","title":"The farm planning problem","text":"Inspired by R. McCardle, Farm management optimization. Masters thesis, University of Louisville, Louisville, Kentucky, United States of America (2009).","category":"page"},{"location":"examples/agriculture_mccardle_farm/","page":"The farm planning problem","title":"The farm planning problem","text":"All data, including short variable names, is taken from that thesis.","category":"page"},{"location":"examples/agriculture_mccardle_farm/","page":"The farm planning problem","title":"The farm planning problem","text":"using SDDP, HiGHS, Test\n\nfunction test_mccardle_farm_model()\n    S = [  # cutting, stage\n        0 1 2\n        0 0 1\n        0 0 0\n    ]\n    t = [60, 60, 245]  # days in period\n    D = [210, 210, 858]  # demand\n    q = [  # selling price per bale\n        [4.5 4.5 4.5; 4.5 4.5 4.5; 4.5 4.5 4.5],\n        [5.5 5.5 5.5; 5.5 5.5 5.5; 5.5 5.5 5.5],\n        [6.5 6.5 6.5; 6.5 6.5 6.5; 6.5 6.5 6.5],\n    ]\n    b = [  # predicted yield (bales/acres) from cutting i in weather j.\n        30 75 37.5\n        15 37.5 18.25\n        7.5 18.75 9.325\n    ]\n    w = 3000  # max storage\n    C = [50 50 50; 50 50 50; 50 50 50]  # cost to grow hay\n    r = [  # Cost per bale of hay from cutting i during weather condition j.\n        [5 5 5; 5 5 5; 5 5 5],\n        [6 6 6; 6 6 6; 6 6 6],\n        [7 7 7; 7 7 7; 7 7 7],\n    ]\n    M = 60.0  # max acreage for planting\n    H = 0.0  # initial inventory\n    V = [0.05, 0.05, 0.05]  # inventory cost\n    L = 3000.0  # max demand for hay\n\n    graph = SDDP.MarkovianGraph([\n        ones(Float64, 1, 1),\n        [0.14 0.69 0.17],\n        [0.14 0.69 0.17; 0.14 0.69 0.17; 0.14 0.69 0.17],\n        [0.14 0.69 0.17; 0.14 0.69 0.17; 0.14 0.69 0.17],\n    ])\n\n    model = SDDP.PolicyGraph(\n        graph,\n        lower_bound = 0.0,\n        optimizer = HiGHS.Optimizer,\n    ) do subproblem, index\n        stage, weather = index\n        # ===================== State Variables =====================\n        # Area planted.\n        @variable(subproblem, 0 <= acres <= M, SDDP.State, initial_value = M)\n        @variable(\n            subproblem,\n            bales[i = 1:3] >= 0,\n            SDDP.State,\n            initial_value = (i == 1 ? H : 0)\n        )\n        # ===================== Variables =====================\n        @variables(subproblem, begin\n            buy[1:3] >= 0  # Quantity of bales to buy from each cutting.\n            sell[1:3] >= 0 # Quantity of bales to sell from each cutting.\n            eat[1:3] >= 0  # Quantity of bales to eat from each cutting.\n            pen_p[1:3] >= 0  # Penalties\n            pen_n[1:3] >= 0  # Penalties\n        end)\n        # ===================== Constraints =====================\n        if stage == 1\n            @constraint(subproblem, acres.out <= acres.in)\n            @constraint(subproblem, [i = 1:3], bales[i].in == bales[i].out)\n        else\n            @expression(\n                subproblem,\n                cut_ex[c = 1:3],\n                bales[c].in + buy[c] - eat[c] - sell[c] + pen_p[c] - pen_n[c]\n            )\n            @constraints(\n                subproblem,\n                begin\n                    # Cannot plant more land than previously cropped.\n                    acres.out <= acres.in\n                    # In each stage we need to meet demand.\n                    sum(eat) >= D[stage-1]\n                    # We can buy and sell other cuttings.\n                    bales[stage-1].out ==\n                    cut_ex[stage-1] + acres.in * b[stage-1, weather]\n                    [c = 1:3; c != stage - 1], bales[c].out == cut_ex[c]\n                    # There is some maximum storage.\n                    sum(bales[i].out for i in 1:3) <= w\n                    # We can only sell what is in storage.\n                    [c = 1:3], sell[c] <= bales[c].in\n                    # Maximum sales quantity.\n                    sum(sell) <= L\n                end\n            )\n        end\n        # ===================== Stage objective =====================\n        if stage == 1\n            @stageobjective(subproblem, 0.0)\n        else\n            @stageobjective(\n                subproblem,\n                1000 * (sum(pen_p) + sum(pen_n)) +\n                # cost of growing\n                C[stage-1, weather] * acres.in +\n                sum(\n                    # inventory cost\n                    V[stage-1] * bales[cutting].in * t[stage-1] +\n                    # purchase cost\n                    r[cutting][stage-1, weather] * buy[cutting] +\n                    # feed cost\n                    S[cutting, stage-1] * eat[cutting] -\n                    # sell reward\n                    q[cutting][stage-1, weather] * sell[cutting] for\n                    cutting in 1:3\n                )\n            )\n        end\n        return\n    end\n    SDDP.train(model)\n    @test SDDP.termination_status(model) == :simulation_stopping\n    @test SDDP.calculate_bound(model) ≈ 4074.1391 atol = 1e-5\nend\n\ntest_mccardle_farm_model()","category":"page"},{"location":"examples/agriculture_mccardle_farm/","page":"The farm planning problem","title":"The farm planning problem","text":"","category":"page"},{"location":"examples/agriculture_mccardle_farm/","page":"The farm planning problem","title":"The farm planning problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/vehicle_location/","page":"Vehicle location","title":"Vehicle location","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/examples/vehicle_location.jl\"","category":"page"},{"location":"examples/vehicle_location/#Vehicle-location","page":"Vehicle location","title":"Vehicle location","text":"","category":"section"},{"location":"examples/vehicle_location/","page":"Vehicle location","title":"Vehicle location","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/vehicle_location/","page":"Vehicle location","title":"Vehicle location","text":"This problem is a version of the Ambulance dispatch problem. A hospital is located at 0 on the number line that stretches from 0 to 100. Ambulance bases are located at points 20, 40, 60, 80, and 100. When not responding to a call, Ambulances must be located at a base, or the hospital. In this example there are three ambulances.","category":"page"},{"location":"examples/vehicle_location/","page":"Vehicle location","title":"Vehicle location","text":"Example location:","category":"page"},{"location":"examples/vehicle_location/","page":"Vehicle location","title":"Vehicle location","text":"H       B       B       B       B       B\n0 ---- 20 ---- 40 ---- 60 ---- 80 ---- 100","category":"page"},{"location":"examples/vehicle_location/","page":"Vehicle location","title":"Vehicle location","text":"Each stage, a call comes in from somewhere on the number line. The agent must decide which ambulance to dispatch. They pay the cost of twice the driving distance. If an ambulance is not dispatched in a stage, the ambulance can be relocated to a different base in preparation for future calls. This incurs a cost of the driving distance.","category":"page"},{"location":"examples/vehicle_location/","page":"Vehicle location","title":"Vehicle location","text":"using SDDP\nimport HiGHS\nimport Test\n\nfunction vehicle_location_model(duality_handler)\n    hospital_location = 0\n    bases = vcat(hospital_location, [20, 40, 60, 80, 100])\n    vehicles = [1, 2, 3]\n    requests = 0:10:100\n    shift_cost(src, dest) = abs(src - dest)\n    function dispatch_cost(base, request)\n        return 2 * (abs(request - hospital_location) + abs(request - base))\n    end\n    # Initial state of emergency vehicles at bases. All ambulances start at the\n    # hospital.\n    initial_state(b, v) = b == hospital_location ? 1.0 : 0.0\n    model = SDDP.LinearPolicyGraph(\n        stages = 10,\n        lower_bound = 0.0,\n        optimizer = HiGHS.Optimizer,\n    ) do sp, t\n        # Current location of each vehicle at each base.\n        @variable(\n            sp,\n            0 <= location[b = bases, v = vehicles] <= 1,\n            SDDP.State,\n            initial_value = initial_state(b, v)\n        )\n        @variables(sp, begin\n            # Which vehicle is dispatched?\n            0 <= dispatch[bases, vehicles] <= 1, Bin\n            # Shifting vehicles between bases: [src, dest, vehicle]\n            0 <= shift[bases, bases, vehicles] <= 1, Bin\n        end)\n        # Flow of vehicles in and out of bases:\n        @expression(\n            sp,\n            base_balance[b in bases, v in vehicles],\n            location[b, v].in - dispatch[b, v] - sum(shift[b, :, v]) +\n            sum(shift[:, b, v])\n        )\n        @constraints(\n            sp,\n            begin\n                # Only one vehicle dispatched to call.\n                sum(dispatch) == 1\n                # Can only dispatch vehicle from base if vehicle is at that base.\n                [b in bases, v in vehicles],\n                dispatch[b, v] <= location[b, v].in\n                # Can only shift vehicle if vehicle is at that src base.\n                [b in bases, v in vehicles],\n                sum(shift[b, :, v]) <= location[b, v].in\n                # Can only shift vehicle if vehicle is not being dispatched.\n                [b in bases, v in vehicles],\n                sum(shift[b, :, v]) + dispatch[b, v] <= 1\n                # Can't shift to same base.\n                [b in bases, v in vehicles], shift[b, b, v] == 0\n                # Update states for non-home/non-hospital bases.\n                [b in bases[2:end], v in vehicles],\n                location[b, v].out == base_balance[b, v]\n                # Update states for home/hospital bases.\n                [v in vehicles],\n                location[hospital_location, v].out ==\n                base_balance[hospital_location, v] + sum(dispatch[:, v])\n            end\n        )\n        SDDP.parameterize(sp, requests) do request\n            @stageobjective(\n                sp,\n                sum(\n                    # Distance to travel from base to emergency and then to hospital.\n                    dispatch[b, v] * dispatch_cost(b, request) +\n                    # Distance travelled by vehicles relocating bases.\n                    sum(\n                        shift_cost(b, dest) * shift[b, dest, v] for\n                        dest in bases\n                    ) for b in bases, v in vehicles\n                )\n            )\n        end\n    end\n    if get(ARGS, 1, \"\") == \"--write\"\n        # Run `$ julia vehicle_location.jl --write` to update the benchmark\n        # model directory\n        model_dir = joinpath(@__DIR__, \"..\", \"..\", \"..\", \"benchmarks\", \"models\")\n        SDDP.write_to_file(\n            model,\n            joinpath(model_dir, \"vehicle_location.sof.json.gz\");\n            test_scenarios = 100,\n        )\n        exit(0)\n    end\n    SDDP.train(\n        model;\n        iteration_limit = 20,\n        log_frequency = 10,\n        cut_deletion_minimum = 100,\n        duality_handler = duality_handler,\n    )\n    Test.@test SDDP.calculate_bound(model) >= 1000\n    return\nend\n\n# TODO(odow): find out why this fails\n# vehicle_location_model(SDDP.ContinuousConicDuality())","category":"page"},{"location":"examples/vehicle_location/","page":"Vehicle location","title":"Vehicle location","text":"","category":"page"},{"location":"examples/vehicle_location/","page":"Vehicle location","title":"Vehicle location","text":"This page was generated using Literate.jl.","category":"page"},{"location":"guides/improve_computational_performance/#Improve-computational-performance","page":"Improve computational performance","title":"Improve computational performance","text":"","category":"section"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"SDDP is a computationally intensive algorithm. Here are some suggestions for how the computational performance can be improved.","category":"page"},{"location":"guides/improve_computational_performance/#Numerical-stability-(again)","page":"Improve computational performance","title":"Numerical stability (again)","text":"","category":"section"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"We've already discussed this in the Numerical stability section of Words of warning. But, it's so important that we're going to say it again: improving the problem scaling is one of the best ways to improve the numerical performance of your models.","category":"page"},{"location":"guides/improve_computational_performance/#Solver-selection","page":"Improve computational performance","title":"Solver selection","text":"","category":"section"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"The majority of the solution time is spent inside the low-level solvers. Choosing which solver (and the associated settings) correctly can lead to big speed-ups.","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"Choose a commercial solver.\nOptions include CPLEX, Gurobi, and Xpress. Using free solvers such as CLP and HiGHS isn't a viable approach for large problems.\nTry different solvers.","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"Even commercial solvers can have wildly different solution times. We've seen   models on which CPLEX was 50% fast than Gurobi, and vice versa.","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"Experiment with different solver options.\nUsing the default settings is usually a good option. However, sometimes it can pay to change these. In particular, forcing solvers to use the dual simplex algorithm (e.g., Method=1 in Gurobi ) is usually a performance win.","category":"page"},{"location":"guides/improve_computational_performance/#Single-cut-vs.-multi-cut","page":"Improve computational performance","title":"Single-cut vs. multi-cut","text":"","category":"section"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"There are two competing ways that cuts can be created in SDDP: single-cut and multi-cut. By default, SDDP.jl uses the single-cut version of SDDP.","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"The performance of each method is problem-dependent. We recommend that you try both in order to see which one performs better. In general, the single-cut method works better when the number of realizations of the stagewise-independent random variable is large, whereas the multi-cut method works better on small problems. However, the multi-cut method can cause numerical stability problems, particularly if used in conjunction with objective or belief state variables.","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"You can switch between the methods by passing the relevant flag to cut_type in SDDP.train.","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"SDDP.train(model; cut_type = SDDP.SINGLE_CUT)\nSDDP.train(model; cut_type = SDDP.MULTI_CUT)","category":"page"},{"location":"guides/improve_computational_performance/#Parallelism","page":"Improve computational performance","title":"Parallelism","text":"","category":"section"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"SDDP.jl can take advantage of the parallel nature of modern computers to solve problems across multiple cores.","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"info: Info\nWe highly recommend that you read the Julia manual's section on parallel computing.","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"You can start Julia from a command line with N processors using the -p flag:","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"julia -p N","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"Alternatively, you can use the Distributed.jl package:","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"using Distributed\nDistributed.addprocs(N)","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"warning: Warning\nWorkers DON'T inherit their parent's Pkg environment. Therefore, if you started Julia with --project=/path/to/environment (or if you activated an environment from the REPL), you will need to put the following at the top of your script:using Distributed\n@everywhere begin\n    import Pkg\n    Pkg.activate(\"/path/to/environment\")\nend","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"Currently SDDP.jl supports to parallel schemes, SDDP.Serial and SDDP.Asynchronous. Instances of these parallel schemes should be passed to the parallel_scheme argument of SDDP.train and SDDP.simulate.","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"using SDDP, HiGHS\nmodel = SDDP.LinearPolicyGraph(\n  stages = 2, lower_bound = 0, optimizer = HiGHS.Optimizer\n) do sp, t\n     @variable(sp, x >= 0, SDDP.State, initial_value = 1)\n     @stageobjective(sp, x.out)\nend\nSDDP.train(model; iteration_limit = 10, parallel_scheme = SDDP.Asynchronous())\nSDDP.simulate(model, 10; parallel_scheme = SDDP.Asynchronous())","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"There is a large overhead for using the asynchronous solver. Even if you choose asynchronous mode, SDDP.jl will start in serial mode while the initialization takes place. Therefore, in the log you will see that the initial iterations take place on the master thread (Proc. ID = 1), and it is only after while that the solve switches to full parallelism.","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"info: Info\nBecause of the large data communication requirements (all cuts have to be shared with all other cores), the solution time will not scale linearly with the number of cores.","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"info: Info\nGiven the same number of iterations, the policy obtained from asynchronous mode will be worse than the policy obtained from serial mode. However, the asynchronous solver can take significantly less time to compute the same number of iterations.","category":"page"},{"location":"guides/improve_computational_performance/#Data-movement","page":"Improve computational performance","title":"Data movement","text":"","category":"section"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"By default, data defined on the master process is not made available to the workers. Therefore, a model like the following:","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"data = 1\nmodel = SDDP.LinearPolicyGraph(stages = 2, lower_bound = 0) do sp, t\n     @variable(sp, x >= 0, SDDP.State, initial_value = data)\n     @stageobjective(sp, x.out)\nend","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"will result in an UndefVarError error like UndefVarError: data not defined.","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"There are three solutions for this problem.","category":"page"},{"location":"guides/improve_computational_performance/#Option-1:-declare-data-inside-the-build-function","page":"Improve computational performance","title":"Option 1: declare data inside the build function","text":"","category":"section"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"model = SDDP.LinearPolicyGraph(stages = 2) do sp, t\n    data = 1\n    @variable(sp, x >= 0, SDDP.State, initial_value = 1)\n    @stageobjective(sp, x)\nend","category":"page"},{"location":"guides/improve_computational_performance/#Option-2:-use-@everywhere","page":"Improve computational performance","title":"Option 2: use @everywhere","text":"","category":"section"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"@everywhere begin\n    data = 1\nend\nmodel = SDDP.LinearPolicyGraph(stages = 2) do sp, t\n    @variable(sp, x >= 0, SDDP.State, initial_value = 1)\n    @stageobjective(sp, x)\nend","category":"page"},{"location":"guides/improve_computational_performance/#Option-3:-build-the-model-in-a-function","page":"Improve computational performance","title":"Option 3: build the model in a function","text":"","category":"section"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"function build_model()\n    data = 1\n    return SDDP.LinearPolicyGraph(stages = 2) do sp, t\n        @variable(sp, x >= 0, SDDP.State, initial_value = 1)\n        @stageobjective(sp, x)\n    end\nend\n\nmodel = build_model()","category":"page"},{"location":"guides/improve_computational_performance/#Initialization-hooks","page":"Improve computational performance","title":"Initialization hooks","text":"","category":"section"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"warning: Warning\nThis is important if you use Gurobi!","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"SDDP.Asynchronous accepts a pre-processing hook that is run on each worker process before the model is solved. The most useful situation is for solvers than need an initialization step. A good example is Gurobi, which can share an environment amongst all models on a worker. Notably, this environment cannot be shared amongst workers, so defining one environment at the top of a script will fail!","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"To initialize a new environment on each worker, use the following:","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"SDDP.train(\n    model;\n    parallel_scheme = SDDP.Asynchronous() do m::SDDP.PolicyGraph\n        env = Gurobi.Env()\n        set_optimizer(m, () -> Gurobi.Optimizer(env))\n    end,\n)","category":"page"},{"location":"examples/FAST_quickstart/","page":"FAST: the quickstart problem","title":"FAST: the quickstart problem","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/examples/FAST_quickstart.jl\"","category":"page"},{"location":"examples/FAST_quickstart/#FAST:-the-quickstart-problem","page":"FAST: the quickstart problem","title":"FAST: the quickstart problem","text":"","category":"section"},{"location":"examples/FAST_quickstart/","page":"FAST: the quickstart problem","title":"FAST: the quickstart problem","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/FAST_quickstart/","page":"FAST: the quickstart problem","title":"FAST: the quickstart problem","text":"An implementation of the QuickStart example from FAST","category":"page"},{"location":"examples/FAST_quickstart/","page":"FAST: the quickstart problem","title":"FAST: the quickstart problem","text":"using SDDP, HiGHS, Test\n\nfunction fast_quickstart()\n    model = SDDP.PolicyGraph(\n        SDDP.LinearGraph(2),\n        lower_bound = -5,\n        optimizer = HiGHS.Optimizer,\n    ) do sp, t\n        @variable(sp, x >= 0, SDDP.State, initial_value = 0.0)\n        if t == 1\n            @stageobjective(sp, x.out)\n        else\n            @variable(sp, s >= 0)\n            @constraint(sp, s <= x.in)\n            SDDP.parameterize(sp, [2, 3]) do ω\n                return JuMP.set_upper_bound(s, ω)\n            end\n            @stageobjective(sp, -2s)\n        end\n    end\n\n    det = SDDP.deterministic_equivalent(model, HiGHS.Optimizer)\n    set_silent(det)\n    JuMP.optimize!(det)\n    @test JuMP.objective_value(det) == -2\n\n    SDDP.train(model)\n    @test SDDP.calculate_bound(model) == -2\nend\n\nfast_quickstart()","category":"page"},{"location":"examples/FAST_quickstart/","page":"FAST: the quickstart problem","title":"FAST: the quickstart problem","text":"","category":"page"},{"location":"examples/FAST_quickstart/","page":"FAST: the quickstart problem","title":"FAST: the quickstart problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/StructDualDynProg.jl_prob5.2_3stages/","page":"StructDualDynProg: Problem 5.2, 3 stages","title":"StructDualDynProg: Problem 5.2, 3 stages","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/examples/StructDualDynProg.jl_prob5.2_3stages.jl\"","category":"page"},{"location":"examples/StructDualDynProg.jl_prob5.2_3stages/#StructDualDynProg:-Problem-5.2,-3-stages","page":"StructDualDynProg: Problem 5.2, 3 stages","title":"StructDualDynProg: Problem 5.2, 3 stages","text":"","category":"section"},{"location":"examples/StructDualDynProg.jl_prob5.2_3stages/","page":"StructDualDynProg: Problem 5.2, 3 stages","title":"StructDualDynProg: Problem 5.2, 3 stages","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/StructDualDynProg.jl_prob5.2_3stages/","page":"StructDualDynProg: Problem 5.2, 3 stages","title":"StructDualDynProg: Problem 5.2, 3 stages","text":"This example comes from StochasticDualDynamicProgramming.jl.","category":"page"},{"location":"examples/StructDualDynProg.jl_prob5.2_3stages/","page":"StructDualDynProg: Problem 5.2, 3 stages","title":"StructDualDynProg: Problem 5.2, 3 stages","text":"using SDDP, HiGHS, Test\n\nfunction test_prob52_3stages()\n    model = SDDP.LinearPolicyGraph(\n        stages = 3,\n        lower_bound = 0.0,\n        optimizer = HiGHS.Optimizer,\n    ) do sp, t\n        n = 4\n        m = 3\n        i_c = [16, 5, 32, 2]\n        C = [25, 80, 6.5, 160]\n        T = [8760, 7000, 1500] / 8760\n        D2 = [diff([0, 3919, 7329, 10315]) diff([0, 7086, 9004, 11169])]\n        p2 = [0.9, 0.1]\n        @variable(sp, x[i = 1:n] >= 0, SDDP.State, initial_value = 0.0)\n        @variables(sp, begin\n            y[1:n, 1:m] >= 0\n            v[1:n] >= 0\n            penalty >= 0\n            ξ[j = 1:m]\n        end)\n        @constraints(sp, begin\n            [i = 1:n], x[i].out == x[i].in + v[i]\n            [i = 1:n], sum(y[i, :]) <= x[i].in\n            [j = 1:m], sum(y[:, j]) + penalty >= ξ[j]\n        end)\n        @stageobjective(sp, i_c'v + C' * y * T + 1e5 * penalty)\n        if t != 1 # no uncertainty in first stage\n            SDDP.parameterize(sp, 1:size(D2, 2), p2) do ω\n                for j in 1:m\n                    JuMP.fix(ξ[j], D2[j, ω])\n                end\n            end\n        end\n        if t == 3\n            @constraint(sp, sum(v) == 0)\n        end\n    end\n\n    det = SDDP.deterministic_equivalent(model, HiGHS.Optimizer)\n    set_silent(det)\n    JuMP.optimize!(det)\n    @test JuMP.objective_value(det) ≈ 406712.49 atol = 0.1\n\n    SDDP.train(model; log_frequency = 10)\n    @test SDDP.calculate_bound(model) ≈ 406712.49 atol = 0.1\n    return\nend\n\ntest_prob52_3stages()","category":"page"},{"location":"examples/StructDualDynProg.jl_prob5.2_3stages/","page":"StructDualDynProg: Problem 5.2, 3 stages","title":"StructDualDynProg: Problem 5.2, 3 stages","text":"","category":"page"},{"location":"examples/StructDualDynProg.jl_prob5.2_3stages/","page":"StructDualDynProg: Problem 5.2, 3 stages","title":"StructDualDynProg: Problem 5.2, 3 stages","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/infinite_horizon_hydro_thermal/","page":"Infinite horizon hydro-thermal","title":"Infinite horizon hydro-thermal","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/examples/infinite_horizon_hydro_thermal.jl\"","category":"page"},{"location":"examples/infinite_horizon_hydro_thermal/#Infinite-horizon-hydro-thermal","page":"Infinite horizon hydro-thermal","title":"Infinite horizon hydro-thermal","text":"","category":"section"},{"location":"examples/infinite_horizon_hydro_thermal/","page":"Infinite horizon hydro-thermal","title":"Infinite horizon hydro-thermal","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/infinite_horizon_hydro_thermal/","page":"Infinite horizon hydro-thermal","title":"Infinite horizon hydro-thermal","text":"using SDDP, HiGHS, Test, Statistics\n\nfunction infinite_hydro_thermal(; cut_type)\n    Ω = [\n        (inflow = 0.0, demand = 7.5),\n        (inflow = 5.0, demand = 5),\n        (inflow = 10.0, demand = 2.5),\n    ]\n    graph = SDDP.Graph(\n        :root_node,\n        [:week],\n        [(:root_node => :week, 1.0), (:week => :week, 0.9)],\n    )\n    model = SDDP.PolicyGraph(\n        graph;\n        lower_bound = 0,\n        optimizer = HiGHS.Optimizer,\n    ) do subproblem, node\n        @variable(\n            subproblem,\n            5.0 <= reservoir <= 15.0,\n            SDDP.State,\n            initial_value = 10.0\n        )\n        @variables(subproblem, begin\n            thermal_generation >= 0\n            hydro_generation >= 0\n            spill >= 0\n            inflow\n            demand\n        end)\n        @constraints(\n            subproblem,\n            begin\n                reservoir.out == reservoir.in - hydro_generation - spill + inflow\n                hydro_generation + thermal_generation == demand\n            end\n        )\n        @stageobjective(subproblem, 10 * spill + thermal_generation)\n        SDDP.parameterize(subproblem, Ω) do ω\n            JuMP.fix(inflow, ω.inflow)\n            return JuMP.fix(demand, ω.demand)\n        end\n    end\n    SDDP.train(\n        model;\n        cut_type = cut_type,\n        log_frequency = 100,\n        sampling_scheme = SDDP.InSampleMonteCarlo(terminate_on_cycle = true),\n        cycle_discretization_delta = 0.1,\n    )\n    @test SDDP.calculate_bound(model) ≈ 119.167 atol = 0.1\n\n    results = SDDP.simulate(model, 500)\n    objectives =\n        [sum(s[:stage_objective] for s in simulation) for simulation in results]\n    sample_mean = round(Statistics.mean(objectives); digits = 2)\n    sample_ci = round(1.96 * Statistics.std(objectives) / sqrt(500); digits = 2)\n    println(\"Confidence_interval = $(sample_mean) ± $(sample_ci)\")\n    @test sample_mean - sample_ci <= 119.167 <= sample_mean + sample_ci\n    return\nend\n\ninfinite_hydro_thermal(cut_type = SDDP.SINGLE_CUT)\ninfinite_hydro_thermal(cut_type = SDDP.MULTI_CUT)","category":"page"},{"location":"examples/infinite_horizon_hydro_thermal/","page":"Infinite horizon hydro-thermal","title":"Infinite horizon hydro-thermal","text":"","category":"page"},{"location":"examples/infinite_horizon_hydro_thermal/","page":"Infinite horizon hydro-thermal","title":"Infinite horizon hydro-thermal","text":"This page was generated using Literate.jl.","category":"page"},{"location":"apireference/#api_reference_list","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"apireference/#Policy-graphs","page":"API Reference","title":"Policy graphs","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"SDDP.Graph\nSDDP.add_node\nSDDP.add_edge\nSDDP.add_ambiguity_set\nSDDP.LinearGraph\nSDDP.MarkovianGraph\nSDDP.UnicyclicGraph\nSDDP.LinearPolicyGraph\nSDDP.MarkovianPolicyGraph\nSDDP.PolicyGraph","category":"page"},{"location":"apireference/#SDDP.Graph","page":"API Reference","title":"SDDP.Graph","text":"Graph(root_node::T) where T\n\nCreate an empty graph struture with the root node root_node.\n\nExample\n\njulia> graph = SDDP.Graph(0)\nRoot\n 0\nNodes\n {}\nArcs\n {}\n\njulia> graph = SDDP.Graph(:root)\nRoot\n root\nNodes\n {}\nArcs\n {}\n\njulia> graph = SDDP.Graph((0, 0))\nRoot\n (0, 0)\nNodes\n {}\nArcs\n {}\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.add_node","page":"API Reference","title":"SDDP.add_node","text":"add_node(graph::Graph{T}, node::T) where {T}\n\nAdd a node to the graph graph.\n\nExamples\n\njulia> graph = SDDP.Graph(:root);\n\njulia> SDDP.add_node(graph, :A)\n\njulia> graph\nRoot\n root\nNodes\n A\nArcs\n {}\n\njulia> graph = SDDP.Graph(0);\n\njulia> SDDP.add_node(graph, 2)\n\njulia> graph\nRoot\n 0\nNodes\n 2\nArcs\n {}\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.add_edge","page":"API Reference","title":"SDDP.add_edge","text":"add_edge(graph::Graph{T}, edge::Pair{T, T}, probability::Float64) where {T}\n\nAdd an edge to the graph graph.\n\nExamples\n\njulia> graph = SDDP.Graph(0);\n\njulia> SDDP.add_node(graph, 1)\n\njulia> SDDP.add_edge(graph, 0 => 1, 0.9)\n\njulia> graph\nRoot\n 0\nNodes\n 1\nArcs\n 0 => 1 w.p. 0.9\n\njulia> graph = SDDP.Graph(:root);\n\njulia> SDDP.add_node(graph, :A)\n\njulia> SDDP.add_edge(graph, :root => :A, 1.0)\n\njulia> graph\nRoot\n root\nNodes\n A\nArcs\n root => A w.p. 1.0\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.add_ambiguity_set","page":"API Reference","title":"SDDP.add_ambiguity_set","text":"add_ambiguity_set(\n    graph::Graph{T},\n    set::Vector{T},\n    lipschitz::Vector{Float64},\n) where {T}\n\nAdd set to the belief partition of graph.\n\nlipschitz is a vector of Lipschitz constants, with one element for each node in set. The Lipschitz constant is the maximum slope of the cost-to-go function with respect to the belief state associated with each node at any point in the state-space.\n\nExamples\n\njulia> graph = SDDP.LinearGraph(3)\nRoot\n 0\nNodes\n 1\n 2\n 3\nArcs\n 0 => 1 w.p. 1.0\n 1 => 2 w.p. 1.0\n 2 => 3 w.p. 1.0\n\njulia> SDDP.add_ambiguity_set(graph, [1, 2], [1e3, 1e2])\n\njulia> SDDP.add_ambiguity_set(graph, [3], [1e5])\n\njulia> graph\nRoot\n 0\nNodes\n 1\n 2\n 3\nArcs\n 0 => 1 w.p. 1.0\n 1 => 2 w.p. 1.0\n 2 => 3 w.p. 1.0\nPartitions\n {1, 2}\n {3}\n\n\n\n\n\nadd_ambiguity_set(graph::Graph{T}, set::Vector{T}, lipschitz::Float64)\n\nAdd set to the belief partition of graph.\n\nlipschitz is a Lipschitz constant for each node in set. The Lipschitz constant is the maximum slope of the cost-to-go function with respect to the belief state associated with each node at any point in the state-space.\n\nExamples\n\njulia> graph = SDDP.LinearGraph(3);\n\njulia> SDDP.add_ambiguity_set(graph, [1, 2], 1e3)\n\njulia> SDDP.add_ambiguity_set(graph, [3], 1e5)\n\njulia> graph\nRoot\n 0\nNodes\n 1\n 2\n 3\nArcs\n 0 => 1 w.p. 1.0\n 1 => 2 w.p. 1.0\n 2 => 3 w.p. 1.0\nPartitions\n {1, 2}\n {3}\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.LinearGraph","page":"API Reference","title":"SDDP.LinearGraph","text":"LinearGraph(stages::Int)\n\nCreate a linear graph with stages number of nodes.\n\nExamples\n\njulia> graph = SDDP.LinearGraph(3)\nRoot\n 0\nNodes\n 1\n 2\n 3\nArcs\n 0 => 1 w.p. 1.0\n 1 => 2 w.p. 1.0\n 2 => 3 w.p. 1.0\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.MarkovianGraph","page":"API Reference","title":"SDDP.MarkovianGraph","text":"MarkovianGraph(transition_matrices::Vector{Matrix{Float64}})\n\nConstruct a Markovian graph from the vector of transition matrices.\n\ntransition_matrices[t][i, j] gives the probability of transitioning from Markov state i in stage t - 1 to Markov state j in stage t.\n\nThe dimension of the first transition matrix should be (1, N), and transition_matrics[1][1, i] is the probability of transitioning from the root node to the Markov state i.\n\nExamples\n\njulia> graph = SDDP.MarkovianGraph([ones(1, 1), [0.5 0.5], [0.8 0.2; 0.2 0.8]])\nRoot\n (0, 1)\nNodes\n (1, 1)\n (2, 1)\n (2, 2)\n (3, 1)\n (3, 2)\nArcs\n (0, 1) => (1, 1) w.p. 1.0\n (1, 1) => (2, 1) w.p. 0.5\n (1, 1) => (2, 2) w.p. 0.5\n (2, 1) => (3, 1) w.p. 0.8\n (2, 1) => (3, 2) w.p. 0.2\n (2, 2) => (3, 1) w.p. 0.2\n (2, 2) => (3, 2) w.p. 0.8\n\n\n\n\n\nMarkovianGraph(;\n    stages::Int,\n    transition_matrix::Matrix{Float64},\n    root_node_transition::Vector{Float64},\n)\n\nConstruct a Markovian graph object with stages number of stages and time-independent Markov transition probabilities.\n\ntransition_matrix must be a square matrix, and the probability of transitioning from Markov state i in stage t to Markov state j in stage t + 1 is given by transition_matrix[i, j].\n\nroot_node_transition[i] is the probability of transitioning from the root node to Markov state i in the first stage.\n\nExamples\n\njulia> graph = SDDP.MarkovianGraph(;\n           stages = 3,\n           transition_matrix = [0.8 0.2; 0.2 0.8],\n           root_node_transition = [0.5, 0.5],\n       )\nRoot\n (0, 1)\nNodes\n (1, 1)\n (1, 2)\n (2, 1)\n (2, 2)\n (3, 1)\n (3, 2)\nArcs\n (0, 1) => (1, 1) w.p. 0.5\n (0, 1) => (1, 2) w.p. 0.5\n (1, 1) => (2, 1) w.p. 0.8\n (1, 1) => (2, 2) w.p. 0.2\n (1, 2) => (2, 1) w.p. 0.2\n (1, 2) => (2, 2) w.p. 0.8\n (2, 1) => (3, 1) w.p. 0.8\n (2, 1) => (3, 2) w.p. 0.2\n (2, 2) => (3, 1) w.p. 0.2\n (2, 2) => (3, 2) w.p. 0.8\n\n\n\n\n\nMarkovianGraph(\n    simulator::Function;\n    budget::Union{Int,Vector{Int}},\n    scenarios::Int = 1000,\n)\n\nConstruct a Markovian graph by fitting Markov chain to scenarios generated by simulator().\n\nbudget is the total number of nodes in the resulting Markov chain. This can either be specified as a single Int, in which case we will attempt to intelligently distributed the nodes between stages. Alternatively, budget can be a Vector{Int}, which details the number of Markov state to have in each stage.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.UnicyclicGraph","page":"API Reference","title":"SDDP.UnicyclicGraph","text":"UnicyclicGraph(discount_factor::Float64; num_nodes::Int = 1)\n\nConstruct a graph composed of num_nodes nodes that form a single cycle, with a probability of discount_factor of continuing the cycle.\n\nExamples\n\njulia> graph = SDDP.UnicyclicGraph(0.9; num_nodes = 2)\nRoot\n 0\nNodes\n 1\n 2\nArcs\n 0 => 1 w.p. 1.0\n 1 => 2 w.p. 1.0\n 2 => 1 w.p. 0.9\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.LinearPolicyGraph","page":"API Reference","title":"SDDP.LinearPolicyGraph","text":"LinearPolicyGraph(builder::Function; stages::Int, kwargs...)\n\nCreate a linear policy graph with stages number of stages.\n\nKeyword arguments\n\nstages: the number of stages in the graph\nkwargs: other keyword arguments are passed to SDDP.PolicyGraph.\n\nExamples\n\njulia> SDDP.LinearPolicyGraph(; stages = 2, lower_bound = 0.0) do sp, t\n    # ... build model ...\nend\nA policy graph with 2 nodes.\nNode indices: 1, 2\n\nis equivalent to\n\njulia> graph = SDDP.LinearGraph(2);\n\njulia> SDDP.PolicyGraph(graph; lower_bound = 0.0) do sp, t\n    # ... build model ...\nend\nA policy graph with 2 nodes.\nNode indices: 1, 2\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.MarkovianPolicyGraph","page":"API Reference","title":"SDDP.MarkovianPolicyGraph","text":"MarkovianPolicyGraph(\n    builder::Function;\n    transition_matrices::Vector{Array{Float64,2}},\n    kwargs...\n)\n\nCreate a Markovian policy graph based on the transition matrices given in transition_matrices.\n\nKeyword arguments\n\ntransition_matrices[t][i, j] gives the probability of transitioning from Markov state i in stage t - 1 to Markov state j in stage t. The dimension of the first transition matrix should be (1, N), and transition_matrics[1][1, i] is the probability of transitioning from the root node to the Markov state i.\nkwargs: other keyword arguments are passed to SDDP.PolicyGraph.\n\nSee also\n\nSee SDDP.MarkovianGraph for other ways of specifying a Markovian policy graph.\n\nSee SDDP.PolicyGraph for the other keyword arguments.\n\nExamples\n\njulia> SDDP.MarkovianPolicyGraph(;\n           transition_matrices = [ones(1, 1), [0.5 0.5], [0.8 0.2; 0.2 0.8]],\n           lower_bound = 0.0,\n       ) do sp, node\n           # ... build model ...\n       end\nA policy graph with 5 nodes.\n Node indices: (1, 1), (2, 1), (2, 2), (3, 1), (3, 2)\n\nis equivalent to\n\njulia> graph = SDDP.MarkovianGraph([ones(1, 1), [0.5 0.5], [0.8 0.2; 0.2 0.8]]);\n\njulia> SDDP.PolicyGraph(graph; lower_bound = 0.0) do sp, t\n    # ... build model ...\nend\nA policy graph with 5 nodes.\n Node indices: (1, 1), (2, 1), (2, 2), (3, 1), (3, 2)\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.PolicyGraph","page":"API Reference","title":"SDDP.PolicyGraph","text":"PolicyGraph(\n    builder::Function,\n    graph::Graph{T};\n    sense::Symbol = :Min,\n    lower_bound = -Inf,\n    upper_bound = Inf,\n    optimizer = nothing,\n) where {T}\n\nConstruct a policy graph based on the graph structure of graph. (See SDDP.Graph for details.)\n\nKeyword arguments\n\nsense: whether we are minimizing (:Min) or maximizing (:Max).\nlower_bound: if mimimizing, a valid lower bound for the cost to go in all subproblems.\nupper_bound: if maximizing, a valid upper bound for the value to go in all subproblems.\noptimizer: the optimizer to use for each of the subproblems\n\nExamples\n\nfunction builder(subproblem::JuMP.Model, index)\n    # ... subproblem definition ...\nend\n\nmodel = PolicyGraph(\n    builder,\n    graph;\n    lower_bound = 0.0,\n    optimizer = HiGHS.Optimizer,\n)\n\nOr, using the Julia do ... end syntax:\n\nmodel = PolicyGraph(\n    graph;\n    lower_bound = 0.0,\n    optimizer = HiGHS.Optimizer,\n) do subproblem, index\n    # ... subproblem definitions ...\nend\n\n\n\n\n\n","category":"type"},{"location":"apireference/#Subproblem-definition","page":"API Reference","title":"Subproblem definition","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"@stageobjective\nSDDP.parameterize\nSDDP.add_objective_state\nSDDP.objective_state\nSDDP.Noise","category":"page"},{"location":"apireference/#SDDP.@stageobjective","page":"API Reference","title":"SDDP.@stageobjective","text":"@stageobjective(subproblem, expr)\n\nSet the stage-objective of subproblem to expr.\n\nExamples\n\n@stageobjective(subproblem, 2x + y)\n\n\n\n\n\n","category":"macro"},{"location":"apireference/#SDDP.parameterize","page":"API Reference","title":"SDDP.parameterize","text":"parameterize(\n    modify::Function,\n    subproblem::JuMP.Model,\n    realizations::Vector{T},\n    probability::Vector{Float64} = fill(1.0 / length(realizations))\n) where {T}\n\nAdd a parameterization function modify to subproblem. The modify function takes one argument and modifies subproblem based on the realization of the noise sampled from realizations with corresponding probabilities probability.\n\nIn order to conduct an out-of-sample simulation, modify should accept arguments that are not in realizations (but still of type T).\n\nExamples\n\nSDDP.parameterize(subproblem, [1, 2, 3], [0.4, 0.3, 0.3]) do ω\n    JuMP.set_upper_bound(x, ω)\nend\n\n\n\n\n\nparameterize(node::Node, noise)\n\nParameterize node node with the noise noise.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.add_objective_state","page":"API Reference","title":"SDDP.add_objective_state","text":"add_objective_state(update::Function, subproblem::JuMP.Model; kwargs...)\n\nAdd an objective state variable to subproblem.\n\nRequired kwargs are:\n\ninitial_value: The initial value of the objective state variable at the  root node.\nlipschitz: The lipschitz constant of the objective state variable.\n\nSetting a tight value for the lipschitz constant can significantly improve the speed of convergence.\n\nOptional kwargs are:\n\nlower_bound: A valid lower bound for the objective state variable. Can be  -Inf.\nupper_bound: A valid upper bound for the objective state variable. Can be  +Inf.\n\nSetting tight values for these optional variables can significantly improve the speed of convergence.\n\nIf the objective state is N-dimensional, each keyword argument must be an NTuple{N,Float64}. For example, initial_value = (0.0, 1.0).\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.objective_state","page":"API Reference","title":"SDDP.objective_state","text":"objective_state(subproblem::JuMP.Model)\n\nReturn the current objective state of the problem.\n\nCan only be called from SDDP.parameterize.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.Noise","page":"API Reference","title":"SDDP.Noise","text":"Noise(support, probability)\n\nAn atom of a discrete random variable at the point of support support and associated probability probability.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#Training-the-policy","page":"API Reference","title":"Training the policy","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"SDDP.numerical_stability_report\nSDDP.train\nSDDP.termination_status\nSDDP.write_cuts_to_file\nSDDP.read_cuts_from_file\nSDDP.write_log_to_csv","category":"page"},{"location":"apireference/#SDDP.numerical_stability_report","page":"API Reference","title":"SDDP.numerical_stability_report","text":"numerical_stability_report(\n    [io::IO = stdout,]\n    model::PolicyGraph;\n    by_node::Bool = false,\n    print::Bool = true,\n    warn::Bool = true,\n)\n\nPrint a report identifying possible numeric stability issues.\n\nKeyword arguments\n\nIf by_node, print a report for each node in the graph.\nIf print, print to io.\nIf warn, warn if the coefficients may cause numerical issues.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.train","page":"API Reference","title":"SDDP.train","text":"SDDP.train(model::PolicyGraph; kwargs...)\n\nTrain the policy for model.\n\nKeyword arguments\n\niteration_limit::Int: number of iterations to conduct before termination.\ntime_limit::Float64: number of seconds to train before termination.\nstoping_rules: a vector of SDDP.AbstractStoppingRules. Defaults to SimulationStoppingRule.\nprint_level::Int: control the level of printing to the screen. Defaults to  1. Set to 0 to disable all printing.\nlog_file::String: filepath at which to write a log of the training progress. Defaults to SDDP.log.\nlog_frequency::Int: control the frequency with which the logging is  outputted (iterations/log). Defaults to 1.\nlog_every_seconds::Float64: control the frequency with which the logging is outputted (seconds/log). Defaults to 0.0.\nrun_numerical_stability_report::Bool: generate (and print) a numerical stability report prior to solve. Defaults to true.\nrefine_at_similar_nodes::Bool: if SDDP can detect that two nodes have the  same children, it can cheaply add a cut discovered at one to the other. In  almost all cases this should be set to true.\ncut_deletion_minimum::Int: the minimum number of cuts to cache before  deleting  cuts from the subproblem. The impact on performance is solver  specific; however, smaller values result in smaller subproblems (and  therefore quicker solves), at the expense of more time spent performing cut  selection.\nrisk_measure: the risk measure to use at each node. Defaults to Expectation.\nsampling_scheme: a sampling scheme to use on the forward pass of the  algorithm. Defaults to InSampleMonteCarlo.\nbackward_sampling_scheme: a backward pass sampling scheme to use on the  backward pass of the algorithm. Defaults to CompleteSampler.\ncut_type: choose between SDDP.SINGLE_CUT and SDDP.MULTI_CUT versions of SDDP.\ndashboard::Bool: open a visualization of the training over time. Defaults  to false.\nparallel_scheme::AbstractParallelScheme: specify a scheme for solving in parallel. Defaults to Serial().\nforward_pass::AbstractForwardPass: specify a scheme to use for the forward passes.\nforward_pass_resampling_probability::Union{Nothing,Float64}: set to a value in (0, 1) to enable RiskAdjustedForwardPass. Defaults to nothing (disabled).\nadd_to_existing_cuts::Bool: set to true to allow training a model that was previously trained. Defaults to false.\nduality_handler::AbstractDualityHandler: specify a duality handler to use when creating cuts.\npost_iteration_callback::Function: a callback with the signature post_iteration_callback(::IterationResult) that is evaluated after each iteration of the algorithm.\n\nThere is also a special option for infinite horizon problems\n\ncycle_discretization_delta: the maximum distance between states allowed on  the forward pass. This is for advanced users only and needs to be used in  conjunction with a different sampling_scheme.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.termination_status","page":"API Reference","title":"SDDP.termination_status","text":"termination_status(model::PolicyGraph)::Symbol\n\nQuery the reason why the training stopped.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.write_cuts_to_file","page":"API Reference","title":"SDDP.write_cuts_to_file","text":"write_cuts_to_file(\n    model::PolicyGraph{T},\n    filename::String;\n    node_name_parser::Function = string,\n) where {T}\n\nWrite the cuts that form the policy in model to filename in JSON format.\n\nnode_name_parser is a function which converts the name of each node into a string representation. It has the signature: node_name_parser(::T)::String.\n\nSee also SDDP.read_cuts_from_file.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.read_cuts_from_file","page":"API Reference","title":"SDDP.read_cuts_from_file","text":"read_cuts_from_file(\n    model::PolicyGraph{T},\n    filename::String;\n    node_name_parser::Function = _node_name_parser,\n) where {T}\n\nRead cuts (saved using SDDP.write_cuts_to_file) from filename into model.\n\nSince T can be an arbitrary Julia type, the conversion to JSON is lossy. When reading, read_cuts_from_file only supports T=Int, T=NTuple{N, Int}, and T=Symbol. If you have manually created a policy graph with a different node type T, provide a function node_name_parser with the signature node_name_parser(T, name::String)::T where {T} that returns the name of each node given the string name name.\n\nIf node_name_parser returns nothing, those cuts are skipped.\n\nSee also SDDP.write_cuts_to_file.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.write_log_to_csv","page":"API Reference","title":"SDDP.write_log_to_csv","text":"write_log_to_csv(model::PolicyGraph, filename::String)\n\nWrite the log of the most recent training to a csv for post-analysis.\n\nAssumes that the model has been trained via SDDP.train.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#api_stopping_rules","page":"API Reference","title":"Stopping rules","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"SDDP.AbstractStoppingRule\nSDDP.stopping_rule_status\nSDDP.convergence_test\nSDDP.IterationLimit\nSDDP.TimeLimit\nSDDP.Statistical\nSDDP.BoundStalling\nSDDP.StoppingChain\nSDDP.SimulationStoppingRule\nSDDP.FirstStageStoppingRule","category":"page"},{"location":"apireference/#SDDP.AbstractStoppingRule","page":"API Reference","title":"SDDP.AbstractStoppingRule","text":"AbstractStoppingRule\n\nThe abstract type for the stopping-rule interface.\n\nYou need to define the following methods:\n\nSDDP.stopping_rule_status\nSDDP.convergence_test\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.stopping_rule_status","page":"API Reference","title":"SDDP.stopping_rule_status","text":"stopping_rule_status(::AbstractStoppingRule)::Symbol\n\nReturn a symbol describing the stopping rule.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.convergence_test","page":"API Reference","title":"SDDP.convergence_test","text":"convergence_test(\n    model::PolicyGraph,\n    log::Vector{Log},\n    ::AbstractStoppingRule,\n)::Bool\n\nReturn a Bool indicating if the algorithm should terminate the training.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.IterationLimit","page":"API Reference","title":"SDDP.IterationLimit","text":"IterationLimit(limit::Int)\n\nTeriminate the algorithm after limit number of iterations.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.TimeLimit","page":"API Reference","title":"SDDP.TimeLimit","text":"TimeLimit(limit::Float64)\n\nTeriminate the algorithm after limit seconds of computation.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.Statistical","page":"API Reference","title":"SDDP.Statistical","text":"Statistical(;\n    num_replications,\n    iteration_period = 1,\n    z_score = 1.96,\n    verbose = true,\n)\n\nPerform an in-sample Monte Carlo simulation of the policy with num_replications replications every iteration_periods. Terminate if the deterministic bound (lower if minimizing) calls into the confidence interval for the mean of the simulated cost. If verbose = true, print the confidence interval.\n\nNote that this tests assumes that the simulated values are normally distributed. In infinite horizon models, this is almost never the case. The distribution is usually closer to exponential or log-normal.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.BoundStalling","page":"API Reference","title":"SDDP.BoundStalling","text":"BoundStalling(num_previous_iterations::Int, tolerance::Float64)\n\nTeriminate the algorithm once the deterministic bound (lower if minimizing, upper if maximizing) fails to improve by more than tolerance in absolute terms for more than num_previous_iterations consecutve iterations, provided it has improved relative to the bound after the first iteration.\n\nChecking for an improvement relative to the first iteration avoids early termination in a situation where the bound fails to improve for the first N iterations. This frequently happens in models with a large number of stages, where it takes time for the cuts to propogate backward enough to modify the bound of the root node.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.StoppingChain","page":"API Reference","title":"SDDP.StoppingChain","text":"StoppingChain(rules::AbstractStoppingRule...)\n\nTerminate once all of the rules are statified.\n\nThis stopping rule short-circuits, so subsequent rules are only tested if the previous pass.\n\nExamples\n\nA stopping rule that runs 100 iterations, then checks for the bound stalling:\n\nStoppingChain(IterationLimit(100), BoundStalling(5, 0.1))\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.SimulationStoppingRule","page":"API Reference","title":"SDDP.SimulationStoppingRule","text":"SimulationStoppingRule(;\n    sampling_scheme::AbstractSamplingScheme = SDDP.InSampleMonteCarlo(),\n    replications::Int = -1,\n    period::Int = -1,\n    distance_tol::Float64 = 1e-2,\n    bound_tol::Float64 = 1e-4,\n)\n\nTerminate the algorithm using a mix of heuristics. Unless you know otherwise, this is typically a good default.\n\nTermination criteria\n\nFirst, we check that the deterministic bound has stabilized. That is, over the last five iterations, the deterministic bound has changed by less than an absolute or relative tolerance of bound_tol.\n\nThen, if we have not done one in the last period iterations, we perform a primal simulation of the policy using replications out-of-sample realizations from sampling_scheme. The realizations are stored and re-used in each simulation. From each simulation, we record the value of the stage objective. We terminate the policy if each of the trajectories in two consecutive simulations differ by less than distance_tol.\n\nBy default, replications and period are -1, and SDDP.jl will guess good values for these. Over-ride the default behavior by setting an appropriate value.\n\nExample\n\nSDDP.train(model; stopping_rules = [SimulationStoppingRule()])\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.FirstStageStoppingRule","page":"API Reference","title":"SDDP.FirstStageStoppingRule","text":"FirstStageStoppingRule(; atol::Float64 = 1e-3, iterations::Int = 50)\n\nTerminate the algorithm when the outgoing values of the first-stage state variables have not changed by more than atol for iterations number of consecutive iterations.\n\nExample\n\nSDDP.train(model; stopping_rules = [FirstStageStoppingRule()])\n\n\n\n\n\n","category":"type"},{"location":"apireference/#Sampling-schemes","page":"API Reference","title":"Sampling schemes","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"SDDP.AbstractSamplingScheme\nSDDP.sample_scenario\nSDDP.InSampleMonteCarlo\nSDDP.OutOfSampleMonteCarlo\nSDDP.Historical\nSDDP.PSRSamplingScheme\nSDDP.SimulatorSamplingScheme","category":"page"},{"location":"apireference/#SDDP.AbstractSamplingScheme","page":"API Reference","title":"SDDP.AbstractSamplingScheme","text":"AbstractSamplingScheme\n\nThe abstract type for the sampling-scheme interface.\n\nYou need to define the following methods:\n\nSDDP.sample_scenario\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.sample_scenario","page":"API Reference","title":"SDDP.sample_scenario","text":"sample_scenario(graph::PolicyGraph{T}, ::AbstractSamplingScheme) where {T}\n\nSample a scenario from the policy graph graph based on the sampling scheme.\n\nReturns ::Tuple{Vector{Tuple{T, <:Any}}, Bool}, where the first element is the scenario, and the second element is a Boolean flag indicating if the scenario was terminated due to the detection of a cycle.\n\nThe scenario is a list of tuples (type Vector{Tuple{T, <:Any}}) where the first component of each tuple is the index of the node, and the second component is the stagewise-independent noise term observed in that node.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.InSampleMonteCarlo","page":"API Reference","title":"SDDP.InSampleMonteCarlo","text":"InSampleMonteCarlo(;\n    max_depth::Int = 0,\n    terminate_on_cycle::Function = false,\n    terminate_on_dummy_leaf::Function = true,\n    rollout_limit::Function = (i::Int) -> typemax(Int),\n    initial_node::Any = nothing,\n)\n\nA Monte Carlo sampling scheme using the in-sample data from the policy graph definition.\n\nIf terminate_on_cycle, terminate the forward pass once a cycle is detected. If max_depth > 0, return once max_depth nodes have been sampled. If terminate_on_dummy_leaf, terminate the forward pass with 1 - probability of sampling a child node.\n\nNote that if terminate_on_cycle = false and terminate_on_dummy_leaf = false then max_depth must be set > 0.\n\nControl which node the trajectories start from using initial_node. If it is left as nothing, the root node is used as the starting node.\n\nYou can use rollout_limit to set iteration specific depth limits. For example:\n\nInSampleMonteCarlo(rollout_limit = i -> 2 * i)\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.OutOfSampleMonteCarlo","page":"API Reference","title":"SDDP.OutOfSampleMonteCarlo","text":"OutOfSampleMonteCarlo(\n    f::Function,\n    graph::PolicyGraph;\n    use_insample_transition::Bool = false,\n    max_depth::Int = 0,\n    terminate_on_cycle::Bool = false,\n    terminate_on_dummy_leaf::Bool = true,\n    rollout_limit::Function = i -> typemax(Int),\n    initial_node = nothing,\n)\n\nCreate a Monte Carlo sampler using out-of-sample probabilities and/or supports for the stagewise-independent noise terms, and out-of-sample probabilities for the node-transition matrix.\n\nf is a function that takes the name of a node and returns a tuple containing a vector of new SDDP.Noise terms for the children of that node, and a vector of new SDDP.Noise terms for the stagewise-independent noise.\n\nIf f is called with the name of the root node (e.g., 0 in a linear policy graph, (0, 1) in a Markovian Policy Graph), then return a vector of SDDP.Noise for the children of the root node.\n\nIf use_insample_transition, the in-sample transition probabilities will be used. Therefore, f should only return a vector of the stagewise-independent noise terms, and f will not be called for the root node.\n\nIf terminate_on_cycle, terminate the forward pass once a cycle is detected. If max_depth > 0, return once max_depth nodes have been sampled. If terminate_on_dummy_leaf, terminate the forward pass with 1 - probability of sampling a child node.\n\nNote that if terminate_on_cycle = false and terminate_on_dummy_leaf = false then max_depth must be set > 0.\n\nControl which node the trajectories start from using initial_node. If it is left as nothing, the root node is used as the starting node.\n\nYou can use rollout_limit to set iteration specific depth limits. For example:\n\nOutOfSampleMonteCarlo(rollout_limit = i -> 2 * i)\n\nExamples\n\nGiven linear policy graph graph with T stages:\n\nsampler = OutOfSampleMonteCarlo(graph) do node\n    if node == 0\n        return [SDDP.Noise(1, 1.0)]\n    else\n        noise_terms = [SDDP.Noise(node, 0.3), SDDP.Noise(node + 1, 0.7)]\n        children = node < T ? [SDDP.Noise(node + 1, 0.9)] : SDDP.Noise{Int}[]\n        return children, noise_terms\n    end\nend\n\nGiven linear policy graph graph with T stages:\n\nsampler = OutOfSampleMonteCarlo(graph, use_insample_transition=true) do node\n    return [SDDP.Noise(node, 0.3), SDDP.Noise(node + 1, 0.7)]\nend\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.Historical","page":"API Reference","title":"SDDP.Historical","text":"Historical(\n    scenarios::Vector{Vector{Tuple{T,S}}},\n    probability::Vector{Float64};\n    terminate_on_cycle::Bool = false,\n) where {T,S}\n\nA sampling scheme that samples a scenario from the vector of scenarios scenarios according to probability.\n\nExamples\n\nHistorical(\n    [\n        [(1, 0.5), (2, 1.0), (3, 0.5)],\n        [(1, 0.5), (2, 0.0), (3, 1.0)],\n        [(1, 1.0), (2, 0.0), (3, 0.0)]\n    ],\n    [0.2, 0.5, 0.3],\n)\n\n\n\n\n\nHistorical(\n    scenarios::Vector{Vector{Tuple{T,S}}};\n    terminate_on_cycle::Bool = false,\n) where {T,S}\n\nA deterministic sampling scheme that iterates through the vector of provided scenarios.\n\nExamples\n\nHistorical([\n    [(1, 0.5), (2, 1.0), (3, 0.5)],\n    [(1, 0.5), (2, 0.0), (3, 1.0)],\n    [(1, 1.0), (2, 0.0), (3, 0.0)],\n])\n\n\n\n\n\nHistorical(\n    scenario::Vector{Tuple{T,S}};\n    terminate_on_cycle::Bool = false,\n) where {T,S}\n\nA deterministic sampling scheme that always samples scenario.\n\nExamples\n\nHistorical([(1, 0.5), (2, 1.5), (3, 0.75)])\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.PSRSamplingScheme","page":"API Reference","title":"SDDP.PSRSamplingScheme","text":"PSRSamplingScheme(N::Int; sampling_scheme = InSampleMonteCarlo())\n\nA sampling scheme with N scenarios, similar to how PSR does it.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.SimulatorSamplingScheme","page":"API Reference","title":"SDDP.SimulatorSamplingScheme","text":"SimulatorSamplingScheme(simulator::Function)\n\nCreate a sampling scheme based on a univariate scenario generator simulator, which returns a Vector{Float64} when called with no arguments like simulator().\n\nThis sampling scheme must be used with a Markovian graph constructed from the same simulator.\n\nThe sample space for SDDP.parameterize must be a tuple in which the first element is the Markov state.\n\nThis sampling scheme generates a new scenario by calling simulator(), and then picking the sequence of nodes in the Markovian graph that is closest to the new trajectory.\n\nExample\n\njulia> using SDDP\n\njulia> import HiGHS\n\njulia> simulator() = cumsum(rand(10))\nsimulator (generic function with 1 method)\n\njulia> model = SDDP.PolicyGraph(\n           SDDP.MarkovianGraph(simulator; budget = 20, scenarios = 100);\n           sense = :Max,\n           upper_bound = 12,\n           optimizer = HiGHS.Optimizer,\n       ) do sp, node\n           t, markov_state = node\n           @variable(sp, x >= 0, SDDP.State, initial_value = 1)\n           @variable(sp, u >= 0)\n           @constraint(sp, x.out == x.in - u)\n           # Elements of Ω must be a tuple in which `markov_state` is the first\n           # element.\n           Ω = [(markov_state, (u = u_max,)) for u_max in (0.0, 0.5)]\n           SDDP.parameterize(sp, Ω) do (markov_state, ω)\n               set_upper_bound(u, ω.u)\n               @stageobjective(sp, markov_state * u)\n           end\n       end;\n\njulia> SDDP.train(\n           model;\n           print_level = 0,\n           iteration_limit = 10,\n           sampling_scheme = SDDP.SimulatorSamplingScheme(simulator),\n       )\n\n\n\n\n\n\n","category":"type"},{"location":"apireference/#Parallel-schemes","page":"API Reference","title":"Parallel schemes","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"SDDP.AbstractParallelScheme\nSDDP.Serial\nSDDP.Asynchronous","category":"page"},{"location":"apireference/#SDDP.AbstractParallelScheme","page":"API Reference","title":"SDDP.AbstractParallelScheme","text":"AbstractParallelScheme\n\nAbstract type for different parallelism schemes.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.Serial","page":"API Reference","title":"SDDP.Serial","text":"Serial()\n\nRun SDDP in serial mode.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.Asynchronous","page":"API Reference","title":"SDDP.Asynchronous","text":"Asynchronous(\n    [init_callback::Function,]\n    slave_pids::Vector{Int} = workers();\n    use_master::Bool = true,\n)\n\nRun SDDP in asynchronous mode workers with pid's slave_pids.\n\nAfter initializing the models on each worker, call init_callback(model). Note that init_callback is run locally on the worker and not on the master thread.\n\nIf use_master is true, iterations are also conducted on the master process.\n\n\n\n\n\nAsynchronous(\n    solver::Any,\n    slave_pids::Vector{Int} = workers();\n    use_master::Bool = true,\n)\n\nRun SDDP in asynchronous mode workers with pid's slave_pids.\n\nSet the optimizer on each worker by calling JuMP.set_optimizer(model, solver).\n\n\n\n\n\n","category":"type"},{"location":"apireference/#Forward-passes","page":"API Reference","title":"Forward passes","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"SDDP.AbstractForwardPass\nSDDP.DefaultForwardPass\nSDDP.RevisitingForwardPass\nSDDP.RiskAdjustedForwardPass\nSDDP.AlternativeForwardPass\nSDDP.AlternativePostIterationCallback\nSDDP.RegularizedForwardPass","category":"page"},{"location":"apireference/#SDDP.AbstractForwardPass","page":"API Reference","title":"SDDP.AbstractForwardPass","text":"AbstractForwardPass\n\nAbstract type for different forward passes.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.DefaultForwardPass","page":"API Reference","title":"SDDP.DefaultForwardPass","text":"DefaultForwardPass(; include_last_node::Bool = true)\n\nThe default forward pass.\n\nIf include_last_node = false and the sample terminated due to a cycle, then the last node (which forms the cycle) is omitted. This can be useful option to set when training, but it comes at the cost of not knowing which node formed the cycle (if there are multiple possibilities).\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.RevisitingForwardPass","page":"API Reference","title":"SDDP.RevisitingForwardPass","text":"RevisitingForwardPass(\n    period::Int = 500;\n    sub_pass::AbstractForwardPass = DefaultForwardPass(),\n)\n\nA forward pass scheme that generate period new forward passes (using sub_pass), then revisits all previously explored forward passes. This can be useful to encourage convergence at a diversity of points in the state-space.\n\nSet period = typemax(Int) to disable.\n\nFor example, if period = 2, then the forward passes will be revisited as follows: 1, 2, 1, 2, 3, 4, 1, 2, 3, 4, 5, 6, 1, 2, ....\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.RiskAdjustedForwardPass","page":"API Reference","title":"SDDP.RiskAdjustedForwardPass","text":"RiskAdjustedForwardPass(;\n    forward_pass::AbstractForwardPass,\n    risk_measure::AbstractRiskMeasure,\n    resampling_probability::Float64,\n    rejection_count::Int = 5,\n)\n\nA forward pass that resamples a previous forward pass with resampling_probability probability, and otherwise samples a new forward pass using forward_pass.\n\nThe forward pass to revisit is chosen based on the risk-adjusted (using risk_measure) probability of the cumulative stage objectives.\n\nNote that this objective corresponds to the first time we visited the trajectory. Subsequent visits may have improved things, but we don't have the mechanisms in-place to update it. Therefore, remove the forward pass from resampling consideration after rejection_count revisits.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.AlternativeForwardPass","page":"API Reference","title":"SDDP.AlternativeForwardPass","text":"AlternativeForwardPass(\n    forward_model::SDDP.PolicyGraph{T};\n    forward_pass::AbstractForwardPass = DefaultForwardPass(),\n)\n\nA forward pass that simulates using forward_model, which may be different to the model used in the backwards pass.\n\nWhen using this forward pass, you should almost always pass SDDP.AlternativePostIterationCallback to the post_iteration_callback argument of SDDP.train.\n\nThis forward pass is most useful when the forward_model is non-convex and we use a convex approximation of the model in the backward pass.\n\nFor example, in optimal power flow models, we can use an AC-OPF formulation as the forward_model and a DC-OPF formulation as the backward model.\n\nFor more details see the paper:\n\nRosemberg, A., and Street, A., and Garcia, J.D., and Valladão, D.M., and Silva, T., and Dowson, O. (2021). Assessing the cost of network simplifications in long-term hydrothermal dispatch planning models. IEEE Transactions on Sustainable Energy. 13(1), 196-206.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.AlternativePostIterationCallback","page":"API Reference","title":"SDDP.AlternativePostIterationCallback","text":"AlternativePostIterationCallback(forward_model::PolicyGraph)\n\nA post-iteration callback that should be used whenever SDDP.AlternativeForwardPass is used.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.RegularizedForwardPass","page":"API Reference","title":"SDDP.RegularizedForwardPass","text":"RegularizedForwardPass(;\n    rho::Float64 = 0.05,\n    forward_pass::AbstractForwardPass = DefaultForwardPass(),\n)\n\nA forward pass that regularizes the outgoing first-stage state variables with an L-infty trust-region constraint about the previous iteration's solution. Specifically, the bounds of the outgoing state variable x are updated from (l, u) to max(l, x^k - rho * (u - l)) <= x <= min(u, x^k + rho * (u - l)), where x^k is the optimal solution of x in the previous iteration. On the first iteration, the value of the state at the root node is used.\n\nBy default, rho is set to 5%, which seems to work well empirically.\n\nPass a different forward_pass to control the forward pass within the regularized forward pass.\n\nThis forward pass is largely intended to be used for investment problems in which the first stage makes a series of capacity decisions that then influence the rest of the graph. An error is thrown if the first stage problem is not deterministic, and states are silently skipped if they do not have finite bounds.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#Risk-Measures","page":"API Reference","title":"Risk Measures","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"SDDP.AbstractRiskMeasure\nSDDP.adjust_probability","category":"page"},{"location":"apireference/#SDDP.AbstractRiskMeasure","page":"API Reference","title":"SDDP.AbstractRiskMeasure","text":"AbstractRiskMeasure\n\nThe abstract type for the risk measure interface.\n\nYou need to define the following methods:\n\nSDDP.adjust_probability\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.adjust_probability","page":"API Reference","title":"SDDP.adjust_probability","text":"adjust_probability(\n    measure::Expectation\n    risk_adjusted_probability::Vector{Float64},\n    original_probability::Vector{Float64},\n    noise_support::Vector{Noise{T}},\n    objective_realizations::Vector{Float64},\n    is_minimization::Bool,\n) where {T}\n\n\n\n\n\n","category":"function"},{"location":"apireference/#Duality-handlers","page":"API Reference","title":"Duality handlers","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"SDDP.AbstractDualityHandler\nSDDP.ContinuousConicDuality\nSDDP.LagrangianDuality\nSDDP.StrengthenedConicDuality\nSDDP.BanditDuality","category":"page"},{"location":"apireference/#SDDP.AbstractDualityHandler","page":"API Reference","title":"SDDP.AbstractDualityHandler","text":"AbstractDualityHandler\n\nThe abstract type for the duality handler interface.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.ContinuousConicDuality","page":"API Reference","title":"SDDP.ContinuousConicDuality","text":"ContinuousConicDuality()\n\nCompute dual variables in the backward pass using conic duality, relaxing any binary or integer restrictions as necessary.\n\nTheory\n\nGiven the problem\n\nmin Cᵢ(x̄, u, w) + θᵢ\n st (x̄, x′, u) in Xᵢ(w) ∩ S\n    x̄ - x == 0          [λ]\n\nwhere S ⊆ ℝ×ℤ, we relax integrality and using conic duality to solve for λ in the problem:\n\nmin Cᵢ(x̄, u, w) + θᵢ\n st (x̄, x′, u) in Xᵢ(w)\n    x̄ - x == 0          [λ]\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.LagrangianDuality","page":"API Reference","title":"SDDP.LagrangianDuality","text":"LagrangianDuality(;\n    method::LocalImprovementSearch.AbstractSearchMethod =\n        LocalImprovementSearch.BFGS(100),\n)\n\nObtain dual variables in the backward pass using Lagrangian duality.\n\nArguments\n\nmethod: the LocalImprovementSearch method for maximizing the Lagrangian dual problem.\n\nTheory\n\nGiven the problem\n\nmin Cᵢ(x̄, u, w) + θᵢ\n st (x̄, x′, u) in Xᵢ(w) ∩ S\n    x̄ - x == 0          [λ]\n\nwhere S ⊆ ℝ×ℤ, we solve the problem max L(λ), where:\n\nL(λ) = min Cᵢ(x̄, u, w) + θᵢ - λ' h(x̄)\n        st (x̄, x′, u) in Xᵢ(w) ∩ S\n\nand where h(x̄) = x̄ - x.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.StrengthenedConicDuality","page":"API Reference","title":"SDDP.StrengthenedConicDuality","text":"StrengthenedConicDuality()\n\nObtain dual variables in the backward pass using strengthened conic duality.\n\nTheory\n\nGiven the problem\n\nmin Cᵢ(x̄, u, w) + θᵢ\n st (x̄, x′, u) in Xᵢ(w) ∩ S\n    x̄ - x == 0          [λ]\n\nwe first obtain an estimate for λ using ContinuousConicDuality.\n\nThen, we evaluate the Lagrangian function:\n\nL(λ) = min Cᵢ(x̄, u, w) + θᵢ - λ' (x̄ - x`)\n        st (x̄, x′, u) in Xᵢ(w) ∩ S\n\nto obtain a better estimate of the intercept.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.BanditDuality","page":"API Reference","title":"SDDP.BanditDuality","text":"BanditDuality()\n\nFormulates the problem of choosing a duality handler as a multi-armed bandit problem. The arms to choose between are:\n\nContinuousConicDuality\nStrengthenedConicDuality\nLagrangianDuality\n\nOur problem isn't a typical multi-armed bandit for a two reasons:\n\nThe reward distribution is non-stationary (each arm converges to 0 as it keeps getting pulled.\nThe distribution of rewards is dependent on the history of the arms that were chosen.\n\nWe choose a very simple heuristic: pick the arm with the best mean + 1 standard deviation. That should ensure we consistently pick the arm with the best likelihood of improving the value function.\n\nIn future, we should consider discounting the rewards of earlier iterations, and focus more on the more-recent rewards.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#Simulating-the-policy","page":"API Reference","title":"Simulating the policy","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"SDDP.simulate\nSDDP.calculate_bound\nSDDP.add_all_cuts","category":"page"},{"location":"apireference/#SDDP.simulate","page":"API Reference","title":"SDDP.simulate","text":"simulate(\n    model::PolicyGraph,\n    number_replications::Int = 1,\n    variables::Vector{Symbol} = Symbol[];\n    sampling_scheme::AbstractSamplingScheme =\n        InSampleMonteCarlo(),\n    custom_recorders = Dict{Symbol, Function}(),\n    duality_handler::Union{Nothing,AbstractDualityHandler} = nothing,\n    skip_undefined_variables::Bool = false,\n    parallel_scheme::AbstractParallelScheme = Serial(),\n    incoming_state::Dict{String,Float64} = _initial_state(model),\n )::Vector{Vector{Dict{Symbol,Any}}}\n\nPerform a simulation of the policy model with number_replications replications.\n\nReturn data structure\n\nReturns a vector with one element for each replication. Each element is a vector with one-element for each node in the scenario that was sampled. Each element in that vector is a dictionary containing information about the subproblem that was solved.\n\nIn that dictionary there are four special keys:\n\n:node_index, which records the index of the sampled node in the policy model\n:noise_term, which records the noise observed at the node\n:stage_objective, which records the stage-objective of the subproblem\n:bellman_term, which records the cost/value-to-go of the node.\n\nThe sum of :stage_objective + :bellman_term will equal the objective value of the solved subproblem.\n\nIn addition to the special keys, the dictionary will contain the result of key => JuMP.value(subproblem[key]) for each key in variables. This is useful to obtain the primal value of the state and control variables.\n\nPositonal arguments\n\nmodel: the model to simulate\nnumber_replications::Int = 1: the number of simulation replications to conduct, that is, the length of the simulation vector that is returned by this function. If omitted, this defaults to 1.`\nvariables::Vector{Symbol} = Symbol[]: a list of the variable names to record the value of in each stage.\n\nKeyword arguments\n\nsampling_scheme: the sampling scheme used when simulating.\ncustom_recorders: see Custom recorders section below.\nduality_handler: the SDDP.AbstractDualityHandler used to compute dual variables. If you do not require dual variables (or if they are not available), pass duality_handler = nothing.\nskip_undefined_variables: If you attempt to simulate the value of a variable that is only defined in some of the stage problems, an error will be thrown. To over-ride this (and return a NaN instead), pass skip_undefined_variables = true.\nparallel_scheme: Use parallel_scheme::[AbstractParallelScheme](@ref) to specify a scheme for simulating in parallel. Defaults to Serial.\ninitial_state: Use incoming_state to pass an initial value of the state variable, if it differs from that at the root node. Each key should be the string name of the state variable.\n\nCustom recorders\n\nFor more complicated data, the custom_recorders keyword argument can be used.\n\nFor example, to record the dual of a constraint named my_constraint, pass the following:\n\nsimulation_results = SDDP.simulate(model, 2;\n    custom_recorders = Dict{Symbol, Function}(\n        :constraint_dual => sp -> JuMP.dual(sp[:my_constraint])\n    )\n)\n\nThe value of the dual in the first stage of the second replication can be accessed as:\n\nsimulation_results[2][1][:constraint_dual]\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.calculate_bound","page":"API Reference","title":"SDDP.calculate_bound","text":"SDDP.calculate_bound(\n    model::PolicyGraph,\n    state::Dict{Symbol,Float64} = model.initial_root_state;\n    risk_measure::AbstractRiskMeasure = Expectation(),\n)\n\nCalculate the lower bound (if minimizing, otherwise upper bound) of the problem model at the point state, assuming the risk measure at the root node is risk_measure.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.add_all_cuts","page":"API Reference","title":"SDDP.add_all_cuts","text":"add_all_cuts(model::PolicyGraph)\n\nAdd all cuts that may have been deleted back into the model.\n\nExplanation\n\nDuring the solve, SDDP.jl may decide to remove cuts for a variety of reasons.\n\nThese can include cuts that define the optimal value function, particularly around the extremes of the state-space (e.g., reservoirs empty).\n\nThis function ensures that all cuts discovered are added back into the model.\n\nYou should call this after train and before simulate.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#Decision-rules","page":"API Reference","title":"Decision rules","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"SDDP.DecisionRule\nSDDP.evaluate","category":"page"},{"location":"apireference/#SDDP.DecisionRule","page":"API Reference","title":"SDDP.DecisionRule","text":"DecisionRule(model::PolicyGraph{T}; node::T)\n\nCreate a decision rule for node node in model.\n\nExample\n\nrule = SDDP.DecisionRule(model; node = 1)\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.evaluate","page":"API Reference","title":"SDDP.evaluate","text":"evaluate(\n    rule::DecisionRule;\n    incoming_state::Dict{Symbol,Float64},\n    noise = nothing,\n    controls_to_record = Symbol[],\n)\n\nEvalute the decision rule rule at the point described by the incoming_state and noise.\n\nIf the node is deterministic, omit the noise argument.\n\nPass a list of symbols to controls_to_record to save the optimal primal solution corresponding to the names registered in the model.\n\n\n\n\n\nevaluate(\n    V::ValueFunction,\n    point::Dict{Union{Symbol,String},<:Real}\n    objective_state = nothing,\n    belief_state = nothing\n)\n\nEvaluate the value function V at point in the state-space.\n\nReturns a tuple containing the height of the function, and the subgradient w.r.t. the convex state-variables.\n\nExamples\n\nevaluate(V, Dict(:volume => 1.0))\n\nIf the state variable is constructed like @variable(sp, volume[1:4] >= 0, SDDP.State, initial_value = 0.0), use [i] to index the state variable:\n\nevaluate(V, Dict(Symbol(\"volume[1]\") => 1.0))\n\nYou can also use strings or symbols for the keys.\n\nevaluate(V, Dict(\"volume[1]\" => 1))\n\n\n\n\n\nevalute(V::ValueFunction{Nothing, Nothing}; kwargs...)\n\nEvalute the value function V at the point in the state-space specified by kwargs.\n\nExamples\n\nevaluate(V; volume = 1)\n\n\n\n\n\nevaluate(\n    model::PolicyGraph{T},\n    validation_scenarios::ValidationScenarios{T,S},\n) where {T,S}\n\nEvaluate the performance of the policy contained in model after a call to train on the scenarios specified by validation_scenarios.\n\nExamples\n\nmodel, validation_scenarios = read_from_file(\"my_model.sof.json\")\ntrain(model; iteration_limit = 100)\nsimulations = evaluate(model, validation_scenarios)\n\n\n\n\n\n","category":"function"},{"location":"apireference/#Visualizing-the-policy","page":"API Reference","title":"Visualizing the policy","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"SDDP.SpaghettiPlot\nSDDP.add_spaghetti\nSDDP.publication_plot\nSDDP.ValueFunction\nSDDP.evaluate(::SDDP.ValueFunction, ::Dict{Symbol,Float64})\nSDDP.plot","category":"page"},{"location":"apireference/#SDDP.SpaghettiPlot","page":"API Reference","title":"SDDP.SpaghettiPlot","text":"SDDP.SpaghettiPlot(; stages, scenarios)\n\nInitialize a new SpaghettiPlot with stages stages and scenarios number of replications.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.add_spaghetti","page":"API Reference","title":"SDDP.add_spaghetti","text":"SDDP.add_spaghetti(data_function::Function, plt::SpaghettiPlot; kwargs...)\n\nDescription\n\nAdd a new figure to the SpaghettiPlot plt, where the y-value of the scenarioth line when x = stage is given by data_function(plt.simulations[scenario][stage]).\n\nKeyword arguments\n\nxlabel: set the xaxis label\nylabel: set the yaxis label\ntitle: set the title of the plot\nymin: set the minimum y value\nymax: set the maximum y value\ncumulative: plot the additive accumulation of the value across the stages\ninterpolate: interpolation method for lines between stages.\n\nDefaults to \"linear\" see the d3 docs \tfor all options.\n\nExamples\n\nsimulations = simulate(model, 10)\nplt = SDDP.spaghetti_plot(simulations)\nSDDP.add_spaghetti(plt; title = \"Stage objective\") do data\n    return data[:stage_objective]\nend\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.publication_plot","page":"API Reference","title":"SDDP.publication_plot","text":"SDDP.publication_plot(\n    data_function, simulations;\n    quantile = [0.0, 0.1, 0.25, 0.5, 0.75, 0.9, 1.0],\n    kwargs...)\n\nCreate a Plots.jl recipe plot of the simulations.\n\nSee Plots.jl for the list of keyword arguments.\n\nExamples\n\nSDDP.publication_plot(simulations; title = \"My title\") do data\n    return data[:stage_objective]\nend\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.ValueFunction","page":"API Reference","title":"SDDP.ValueFunction","text":"ValueFunction\n\nA representation of the value function. SDDP.jl uses the following unique representation of the value function that is undocumented in the literature.\n\nIt supports three types of state variables:\n\nx - convex \"resource\" states\nb - concave \"belief\" states\ny - concave \"objective\" states\n\nIn addition, we have three types of cuts:\n\nSingle-cuts (also called \"average\" cuts in the literature), which involve the risk-adjusted expectation of the cost-to-go.\nMulti-cuts, which use a different cost-to-go term for each realization w.\nRisk-cuts, which correspond to the facets of the dual interpretation of a coherent risk measure.\n\nTherefore, ValueFunction returns a JuMP model of the following form:\n\nV(x, b, y) = min: μᵀb + νᵀy + θ\n             s.t. # \"Single\" / \"Average\" cuts\n                  μᵀb(j) + νᵀy(j) + θ >= α(j) + xᵀβ(j), ∀ j ∈ J\n                  # \"Multi\" cuts\n                  μᵀb(k) + νᵀy(k) + φ(w) >= α(k, w) + xᵀβ(k, w), ∀w ∈ Ω, k ∈ K\n                  # \"Risk-set\" cuts\n                  θ ≥ Σ{p(k, w) * φ(w)}_w - μᵀb(k) - νᵀy(k), ∀ k ∈ K\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.evaluate-Tuple{SDDP.ValueFunction, Dict{Symbol, Float64}}","page":"API Reference","title":"SDDP.evaluate","text":"evaluate(\n    V::ValueFunction,\n    point::Dict{Union{Symbol,String},<:Real}\n    objective_state = nothing,\n    belief_state = nothing\n)\n\nEvaluate the value function V at point in the state-space.\n\nReturns a tuple containing the height of the function, and the subgradient w.r.t. the convex state-variables.\n\nExamples\n\nevaluate(V, Dict(:volume => 1.0))\n\nIf the state variable is constructed like @variable(sp, volume[1:4] >= 0, SDDP.State, initial_value = 0.0), use [i] to index the state variable:\n\nevaluate(V, Dict(Symbol(\"volume[1]\") => 1.0))\n\nYou can also use strings or symbols for the keys.\n\nevaluate(V, Dict(\"volume[1]\" => 1))\n\n\n\n\n\n","category":"method"},{"location":"apireference/#SDDP.plot","page":"API Reference","title":"SDDP.plot","text":"plot(plt::SpaghettiPlot[, filename::String]; open::Bool = true)\n\nThe SpaghettiPlot plot plt to filename. If filename is not given, it will be saved to a temporary directory. If open = true, then a browser window will be opened to display the resulting HTML file.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#Debugging-the-model","page":"API Reference","title":"Debugging the model","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"SDDP.write_subproblem_to_file\nSDDP.deterministic_equivalent","category":"page"},{"location":"apireference/#SDDP.write_subproblem_to_file","page":"API Reference","title":"SDDP.write_subproblem_to_file","text":"write_subproblem_to_file(\n    node::Node,\n    filename::String;\n    throw_error::Bool = false,\n)\n\nWrite the subproblem contained in node to the file filename.\n\nThe throw_error is an argument used internally by SDDP.jl. If set, an error will be thrown.\n\nExample\n\nSDDP.write_subproblem_to_file(model[1], \"subproblem_1.lp\")\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.deterministic_equivalent","page":"API Reference","title":"SDDP.deterministic_equivalent","text":"deterministic_equivalent(\n    pg::PolicyGraph{T},\n    optimizer = nothing;\n    time_limit::Union{Real,Nothing} = 60.0,\n)\n\nForm a JuMP model that represents the deterministic equivalent of the problem.\n\nExamples\n\ndeterministic_equivalent(model)\n\ndeterministic_equivalent(model, HiGHS.Optimizer)\n\n\n\n\n\n","category":"function"},{"location":"apireference/#StochOptFormat","page":"API Reference","title":"StochOptFormat","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"SDDP.write_to_file\nSDDP.read_from_file\nBase.write(::IO, ::SDDP.PolicyGraph)\nBase.read(::IO, ::Type{SDDP.PolicyGraph})\nSDDP.evaluate(::SDDP.PolicyGraph{T}, ::SDDP.ValidationScenarios{T}) where {T}\nSDDP.ValidationScenarios\nSDDP.ValidationScenario","category":"page"},{"location":"apireference/#SDDP.write_to_file","page":"API Reference","title":"SDDP.write_to_file","text":"write_to_file(\n    model::PolicyGraph,\n    filename::String;\n    compression::MOI.FileFormats.AbstractCompressionScheme =\n        MOI.FileFormats.AutomaticCompression(),\n    kwargs...\n)\n\nWrite model to filename in the StochOptFormat file format.\n\nPass an argument to compression to override the default of automatically detecting the file compression to use based on the extension of filename.\n\nSee Base.write(::IO, ::PolicyGraph) for information on the keyword arguments that can be provided.\n\nwarning: Warning\nThis function is experimental. See the full warning in Base.write(::IO, ::PolicyGraph).\n\nExamples\n\nwrite_to_file(model, \"my_model.sof.json\"; validation_scenarios = 10)\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.read_from_file","page":"API Reference","title":"SDDP.read_from_file","text":"read_from_file(\n    filename::String;\n    compression::MOI.FileFormats.AbstractCompressionScheme =\n        MOI.FileFormats.AutomaticCompression(),\n    kwargs...\n)::Tuple{PolicyGraph, ValidationScenarios}\n\nReturn a tuple containing a PolicyGraph object and a ValidationScenarios read from filename in the StochOptFormat file format.\n\nPass an argument to compression to override the default of automatically detecting the file compression to use based on the extension of filename.\n\nSee Base.read(::IO, ::Type{PolicyGraph}) for information on the keyword arguments that can be provided.\n\nwarning: Warning\nThis function is experimental. See the full warning in Base.read(::IO, ::Type{PolicyGraph}).\n\nExamples\n\nmodel, validation_scenarios = read_from_file(\"my_model.sof.json\")\n\n\n\n\n\n","category":"function"},{"location":"apireference/#Base.write-Tuple{IO, SDDP.PolicyGraph}","page":"API Reference","title":"Base.write","text":"Base.write(\n    io::IO,\n    model::PolicyGraph;\n    validation_scenarios::Union{Nothing,Int,ValidationScenarios} = nothing,\n    sampling_scheme::AbstractSamplingScheme = InSampleMonteCarlo(),\n    kwargs...\n)\n\nWrite model to io in the StochOptFormat file format.\n\nPass an Int to validation_scenarios (default nothing) to specify the number of test scenarios to generate using the sampling_scheme sampling scheme. Alternatively, pass a ValidationScenarios object to manually specify the test scenarios to use.\n\nAny additional kwargs passed to write will be stored in the top-level of the resulting StochOptFormat file. Valid arguments include name, author, date, and description.\n\nCompatibility\n\nwarning: Warning\nTHIS FUNCTION IS EXPERIMENTAL. THINGS MAY CHANGE BETWEEN COMMITS. YOU SHOULD NOT RELY ON THIS FUNCTIONALITY AS A LONG-TERM FILE FORMAT (YET).\n\nIn addition to potential changes to the underlying format, only a subset of possible modifications are supported. These include:\n\nJuMP.fix\nJuMP.set_lower_bound\nJuMP.set_upper_bound\nJuMP.set_normalized_rhs\nChanges to the constant or affine terms in a stage objective.\n\nIf your model uses something other than this, this function will silently write an incorrect formulation of the problem.\n\nExamples\n\nopen(\"my_model.sof.json\", \"w\") do io\n    write(\n        io,\n        model;\n        validation_scenarios = 10,\n        name = \"MyModel\",\n        author = \"@odow\",\n        date = \"2020-07-20\",\n        description = \"Example problem for the SDDP.jl documentation\",\n    )\nend\n\n\n\n\n\n","category":"method"},{"location":"apireference/#Base.read-Tuple{IO, Type{SDDP.PolicyGraph}}","page":"API Reference","title":"Base.read","text":"Base.read(\n    io::IO,\n    ::Type{PolicyGraph};\n    bound::Float64 = 1e6,\n)::Tuple{PolicyGraph,ValidationScenarios}\n\nReturn a tuple containing a PolicyGraph object and a ValidationScenarios read from io in the StochOptFormat file format.\n\nSee also: evaluate.\n\nCompatibility\n\nwarning: Warning\nThis function is experimental. Things may change between commits. You should not rely on this functionality as a long-term file format (yet).\n\nIn addition to potential changes to the underlying format, only a subset of possible modifications are supported. These include:\n\nAdditive random variables in the constraints or in the objective\nMultiplicative random variables in the objective\n\nIf your model uses something other than this, this function may throw an error or silently build a non-convex model.\n\nExamples\n\nopen(\"my_model.sof.json\", \"r\") do io\n    model, validation_scenarios = read(io, PolicyGraph)\nend\n\n\n\n\n\n","category":"method"},{"location":"apireference/#SDDP.evaluate-Union{Tuple{T}, Tuple{SDDP.PolicyGraph{T}, SDDP.ValidationScenarios{T}}} where T","page":"API Reference","title":"SDDP.evaluate","text":"evaluate(\n    model::PolicyGraph{T},\n    validation_scenarios::ValidationScenarios{T,S},\n) where {T,S}\n\nEvaluate the performance of the policy contained in model after a call to train on the scenarios specified by validation_scenarios.\n\nExamples\n\nmodel, validation_scenarios = read_from_file(\"my_model.sof.json\")\ntrain(model; iteration_limit = 100)\nsimulations = evaluate(model, validation_scenarios)\n\n\n\n\n\n","category":"method"},{"location":"apireference/#SDDP.ValidationScenarios","page":"API Reference","title":"SDDP.ValidationScenarios","text":"ValidationScenario{T,S}(scenarios::Vector{ValidationScenario{T,S}})\n\nAn AbstractSamplingScheme based on a vector of scenarios.\n\nEach scenario is a vector of Tuple{T, S} where the first element is the node to visit and the second element is the realization of the stagewise-independent noise term. Pass nothing if the node is deterministic.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.ValidationScenario","page":"API Reference","title":"SDDP.ValidationScenario","text":"ValidationScenario{T,S}(scenario::Vector{Tuple{T,S}})\n\nA single scenario for testing.\n\nSee also: ValidationScenarios.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/markov_uncertainty/","page":"Markovian policy graphs","title":"Markovian policy graphs","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/tutorial/markov_uncertainty.jl\"","category":"page"},{"location":"tutorial/markov_uncertainty/#Markovian-policy-graphs","page":"Markovian policy graphs","title":"Markovian policy graphs","text":"","category":"section"},{"location":"tutorial/markov_uncertainty/","page":"Markovian policy graphs","title":"Markovian policy graphs","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorial/markov_uncertainty/","page":"Markovian policy graphs","title":"Markovian policy graphs","text":"In our previous tutorials (An introduction to SDDP.jl and Uncertainty in the objective function), we formulated a simple hydrothermal scheduling problem with stagewise-independent random variables in the right-hand side of the constraints and in the objective function. Now, in this tutorial, we introduce some stagewise-dependent uncertainty using a Markov chain.","category":"page"},{"location":"tutorial/markov_uncertainty/#Formulating-the-problem","page":"Markovian policy graphs","title":"Formulating the problem","text":"","category":"section"},{"location":"tutorial/markov_uncertainty/","page":"Markovian policy graphs","title":"Markovian policy graphs","text":"In this tutorial we consider a Markov chain with two climate states: wet and dry. Each Markov state is associated with an integer, in this case the wet climate state  is Markov state 1 and the dry climate state is Markov state 2. In the wet climate state, the probability of the high inflow increases to 50%, and the probability of the low inflow decreases to 1/6. In the dry climate state, the converse happens. There is also persistence in the climate state: the probability of remaining in the current state is 75%, and the probability of transitioning to the other climate state is 25%. We assume that the first stage starts in the wet climate state.","category":"page"},{"location":"tutorial/markov_uncertainty/","page":"Markovian policy graphs","title":"Markovian policy graphs","text":"Here is a picture of the model we're going to implement.","category":"page"},{"location":"tutorial/markov_uncertainty/","page":"Markovian policy graphs","title":"Markovian policy graphs","text":"(Image: Markovian policy graph)","category":"page"},{"location":"tutorial/markov_uncertainty/","page":"Markovian policy graphs","title":"Markovian policy graphs","text":"There are five nodes in our graph. Each node is named by a tuple (t, i), where t is the stage for t=1,2,3, and i is the Markov state for i=1,2. As before, the wavy lines denote the stagewise-independent random variable.","category":"page"},{"location":"tutorial/markov_uncertainty/","page":"Markovian policy graphs","title":"Markovian policy graphs","text":"For each stage, we need to provide a Markov transition matrix. This is an MxN matrix, where the element A[i, j] gives the probability of transitioning from Markov state i in the previous stage to Markov state j in the current stage. The first stage is special because we assume there is a \"zero'th\" stage which has one Markov state (the round node in the graph above). Furthermore, the number of columns in the transition matrix of a stage (i.e. the number of Markov states) must equal the number of rows in the next stage's transition matrix. For our example, the vector of Markov transition matrices is given by:","category":"page"},{"location":"tutorial/markov_uncertainty/","page":"Markovian policy graphs","title":"Markovian policy graphs","text":"T = Array{Float64,2}[[1.0]', [0.75 0.25], [0.75 0.25; 0.25 0.75]]","category":"page"},{"location":"tutorial/markov_uncertainty/","page":"Markovian policy graphs","title":"Markovian policy graphs","text":"note: Note\nMake sure to add the ' after the first transition matrix so Julia can distinguish between a vector and a matrix.","category":"page"},{"location":"tutorial/markov_uncertainty/#Creating-a-model","page":"Markovian policy graphs","title":"Creating a model","text":"","category":"section"},{"location":"tutorial/markov_uncertainty/","page":"Markovian policy graphs","title":"Markovian policy graphs","text":"using SDDP, HiGHS\n\nΩ = [\n    (inflow = 0.0, fuel_multiplier = 1.5),\n    (inflow = 50.0, fuel_multiplier = 1.0),\n    (inflow = 100.0, fuel_multiplier = 0.75),\n]\n\nmodel = SDDP.MarkovianPolicyGraph(\n    transition_matrices = Array{Float64,2}[\n        [1.0]',\n        [0.75 0.25],\n        [0.75 0.25; 0.25 0.75],\n    ],\n    sense = :Min,\n    lower_bound = 0.0,\n    optimizer = HiGHS.Optimizer,\n) do subproblem, node\n    # Unpack the stage and Markov index.\n    t, markov_state = node\n    # Define the state variable.\n    @variable(subproblem, 0 <= volume <= 200, SDDP.State, initial_value = 200)\n    # Define the control variables.\n    @variables(subproblem, begin\n        thermal_generation >= 0\n        hydro_generation >= 0\n        hydro_spill >= 0\n        inflow\n    end)\n    # Define the constraints\n    @constraints(\n        subproblem,\n        begin\n            volume.out == volume.in + inflow - hydro_generation - hydro_spill\n            thermal_generation + hydro_generation == 150.0\n        end\n    )\n    # Note how we can use `markov_state` to dispatch an `if` statement.\n    probability = if markov_state == 1  # wet climate state\n        [1 / 6, 1 / 3, 1 / 2]\n    else  # dry climate state\n        [1 / 2, 1 / 3, 1 / 6]\n    end\n\n    fuel_cost = [50.0, 100.0, 150.0]\n    SDDP.parameterize(subproblem, Ω, probability) do ω\n        JuMP.fix(inflow, ω.inflow)\n        @stageobjective(\n            subproblem,\n            ω.fuel_multiplier * fuel_cost[t] * thermal_generation\n        )\n    end\nend","category":"page"},{"location":"tutorial/markov_uncertainty/","page":"Markovian policy graphs","title":"Markovian policy graphs","text":"tip: Tip\nFor more information on SDDP.MarkovianPolicyGraphs, read Create a general policy graph.","category":"page"},{"location":"tutorial/markov_uncertainty/#Training-and-simulating-the-policy","page":"Markovian policy graphs","title":"Training and simulating the policy","text":"","category":"section"},{"location":"tutorial/markov_uncertainty/","page":"Markovian policy graphs","title":"Markovian policy graphs","text":"As in the previous three tutorials, we train the policy:","category":"page"},{"location":"tutorial/markov_uncertainty/","page":"Markovian policy graphs","title":"Markovian policy graphs","text":"SDDP.train(model)","category":"page"},{"location":"tutorial/markov_uncertainty/","page":"Markovian policy graphs","title":"Markovian policy graphs","text":"Instead of performing a Monte Carlo simulation like the previous tutorials, we may want to simulate one particular sequence of noise realizations. This historical simulation can also be conducted by passing a SDDP.Historical sampling scheme to the sampling_scheme keyword of the SDDP.simulate function.","category":"page"},{"location":"tutorial/markov_uncertainty/","page":"Markovian policy graphs","title":"Markovian policy graphs","text":"We can confirm that the historical sequence of nodes was visited by querying the :node_index key of the simulation results.","category":"page"},{"location":"tutorial/markov_uncertainty/","page":"Markovian policy graphs","title":"Markovian policy graphs","text":"simulations = SDDP.simulate(\n    model,\n    sampling_scheme = SDDP.Historical([\n        ((1, 1), Ω[1]),\n        ((2, 2), Ω[3]),\n        ((3, 1), Ω[2]),\n    ]),\n)\n\n[stage[:node_index] for stage in simulations[1]]","category":"page"},{"location":"tutorial/markov_uncertainty/","page":"Markovian policy graphs","title":"Markovian policy graphs","text":"","category":"page"},{"location":"tutorial/markov_uncertainty/","page":"Markovian policy graphs","title":"Markovian policy graphs","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/FAST_hydro_thermal/","page":"FAST: the hydro-thermal problem","title":"FAST: the hydro-thermal problem","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/examples/FAST_hydro_thermal.jl\"","category":"page"},{"location":"examples/FAST_hydro_thermal/#FAST:-the-hydro-thermal-problem","page":"FAST: the hydro-thermal problem","title":"FAST: the hydro-thermal problem","text":"","category":"section"},{"location":"examples/FAST_hydro_thermal/","page":"FAST: the hydro-thermal problem","title":"FAST: the hydro-thermal problem","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/FAST_hydro_thermal/","page":"FAST: the hydro-thermal problem","title":"FAST: the hydro-thermal problem","text":"An implementation of the Hydro-thermal example from FAST","category":"page"},{"location":"examples/FAST_hydro_thermal/","page":"FAST: the hydro-thermal problem","title":"FAST: the hydro-thermal problem","text":"using SDDP, HiGHS, Test\n\nfunction fast_hydro_thermal()\n    model = SDDP.PolicyGraph(\n        SDDP.LinearGraph(2),\n        lower_bound = 0.0,\n        optimizer = HiGHS.Optimizer,\n    ) do sp, t\n        @variable(sp, 0 <= x <= 8, SDDP.State, initial_value = 0.0)\n        @variables(sp, begin\n            y >= 0\n            p >= 0\n            ξ\n        end)\n        @constraints(sp, begin\n            p + y >= 6\n            x.out <= x.in - y + ξ\n        end)\n        RAINFALL = (t == 1 ? [6] : [2, 10])\n        SDDP.parameterize(sp, RAINFALL) do ω\n            return JuMP.fix(ξ, ω)\n        end\n        @stageobjective(sp, 5 * p)\n    end\n\n    det = SDDP.deterministic_equivalent(model, HiGHS.Optimizer)\n    set_silent(det)\n    JuMP.optimize!(det)\n    @test JuMP.objective_value(det) == 10\n    SDDP.train(model)\n    @test SDDP.calculate_bound(model) == 10\n    return\nend\n\nfast_hydro_thermal()","category":"page"},{"location":"examples/FAST_hydro_thermal/","page":"FAST: the hydro-thermal problem","title":"FAST: the hydro-thermal problem","text":"","category":"page"},{"location":"examples/FAST_hydro_thermal/","page":"FAST: the hydro-thermal problem","title":"FAST: the hydro-thermal problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/StochDynamicProgramming.jl_multistock/","page":"StochDynamicProgramming: the multistock problem","title":"StochDynamicProgramming: the multistock problem","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/examples/StochDynamicProgramming.jl_multistock.jl\"","category":"page"},{"location":"examples/StochDynamicProgramming.jl_multistock/#StochDynamicProgramming:-the-multistock-problem","page":"StochDynamicProgramming: the multistock problem","title":"StochDynamicProgramming: the multistock problem","text":"","category":"section"},{"location":"examples/StochDynamicProgramming.jl_multistock/","page":"StochDynamicProgramming: the multistock problem","title":"StochDynamicProgramming: the multistock problem","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/StochDynamicProgramming.jl_multistock/","page":"StochDynamicProgramming: the multistock problem","title":"StochDynamicProgramming: the multistock problem","text":"This example comes from StochDynamicProgramming.jl.","category":"page"},{"location":"examples/StochDynamicProgramming.jl_multistock/","page":"StochDynamicProgramming: the multistock problem","title":"StochDynamicProgramming: the multistock problem","text":"using SDDP, HiGHS, Test\n\nfunction test_multistock_example()\n    model = SDDP.LinearPolicyGraph(\n        stages = 5,\n        lower_bound = -5.0,\n        optimizer = HiGHS.Optimizer,\n    ) do subproblem, stage\n        @variable(\n            subproblem,\n            0 <= stock[i = 1:3] <= 1,\n            SDDP.State,\n            initial_value = 0.5\n        )\n        @variables(subproblem, begin\n            0 <= control[i = 1:3] <= 0.5\n            ξ[i = 1:3]  # Dummy for RHS noise.\n        end)\n        @constraints(\n            subproblem,\n            begin\n                sum(control) - 0.5 * 3 <= 0\n                [i = 1:3], stock[i].out == stock[i].in + control[i] - ξ[i]\n            end\n        )\n        Ξ = collect(\n            Base.product((0.0, 0.15, 0.3), (0.0, 0.15, 0.3), (0.0, 0.15, 0.3)),\n        )[:]\n        SDDP.parameterize(subproblem, Ξ) do ω\n            return JuMP.fix.(ξ, ω)\n        end\n        @stageobjective(subproblem, (sin(3 * stage) - 1) * sum(control))\n    end\n    SDDP.train(\n        model;\n        iteration_limit = 100,\n        cut_type = SDDP.SINGLE_CUT,\n        log_frequency = 10,\n    )\n    @test SDDP.calculate_bound(model) ≈ -4.349 atol = 0.01\n\n    simulation_results = SDDP.simulate(model, 5000)\n    @test length(simulation_results) == 5000\n    μ = SDDP.Statistics.mean(\n        sum(data[:stage_objective] for data in simulation) for\n        simulation in simulation_results\n    )\n    @test μ ≈ -4.349 atol = 0.1\n    return\nend\n\ntest_multistock_example()","category":"page"},{"location":"examples/StochDynamicProgramming.jl_multistock/","page":"StochDynamicProgramming: the multistock problem","title":"StochDynamicProgramming: the multistock problem","text":"","category":"page"},{"location":"examples/StochDynamicProgramming.jl_multistock/","page":"StochDynamicProgramming: the multistock problem","title":"StochDynamicProgramming: the multistock problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/tutorial/plotting.jl\"","category":"page"},{"location":"tutorial/plotting/#Plotting-tools","page":"Plotting tools","title":"Plotting tools","text":"","category":"section"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"In our previous tutorials, we formulated, solved, and simulated multistage stochastic optimization problems. However, we haven't really investigated what the solution looks like. Luckily, SDDP.jl includes a number of plotting tools to help us do that. In this tutorial, we explain the tools and make some pretty pictures.","category":"page"},{"location":"tutorial/plotting/#Preliminaries","page":"Plotting tools","title":"Preliminaries","text":"","category":"section"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"The next two plot types help visualize the policy. Thus, we first need to create a policy and simulate some trajectories. So, let's take the model from Markovian policy graphs, train it for 20 iterations, and then simulate 100 Monte Carlo realizations of the policy.","category":"page"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"using SDDP, HiGHS\n\nΩ = [\n    (inflow = 0.0, fuel_multiplier = 1.5),\n    (inflow = 50.0, fuel_multiplier = 1.0),\n    (inflow = 100.0, fuel_multiplier = 0.75),\n]\n\nmodel = SDDP.MarkovianPolicyGraph(\n    transition_matrices = Array{Float64,2}[\n        [1.0]',\n        [0.75 0.25],\n        [0.75 0.25; 0.25 0.75],\n    ],\n    sense = :Min,\n    lower_bound = 0.0,\n    optimizer = HiGHS.Optimizer,\n) do subproblem, node\n    t, markov_state = node\n    @variable(subproblem, 0 <= volume <= 200, SDDP.State, initial_value = 200)\n    @variables(subproblem, begin\n        thermal_generation >= 0\n        hydro_generation >= 0\n        hydro_spill >= 0\n        inflow\n    end)\n    @constraints(\n        subproblem,\n        begin\n            volume.out == volume.in + inflow - hydro_generation - hydro_spill\n            thermal_generation + hydro_generation == 150.0\n        end\n    )\n    probability =\n        markov_state == 1 ? [1 / 6, 1 / 3, 1 / 2] : [1 / 2, 1 / 3, 1 / 6]\n    fuel_cost = [50.0, 100.0, 150.0]\n    SDDP.parameterize(subproblem, Ω, probability) do ω\n        JuMP.fix(inflow, ω.inflow)\n        @stageobjective(\n            subproblem,\n            ω.fuel_multiplier * fuel_cost[t] * thermal_generation\n        )\n    end\nend\n\nSDDP.train(model, iteration_limit = 20, run_numerical_stability_report = false)\n\nsimulations = SDDP.simulate(\n    model,\n    100,\n    [:volume, :thermal_generation, :hydro_generation, :hydro_spill],\n)\n\nprintln(\"Completed $(length(simulations)) simulations.\")","category":"page"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"Great! Now we have some data in simulations to visualize.","category":"page"},{"location":"tutorial/plotting/#Spaghetti-plots","page":"Plotting tools","title":"Spaghetti plots","text":"","category":"section"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"The first plotting utility we discuss is a spaghetti plot (you'll understand the name when you see the graph).","category":"page"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"To create a spaghetti plot, begin by creating a new SDDP.SpaghettiPlot instance as follows:","category":"page"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"plt = SDDP.SpaghettiPlot(simulations)","category":"page"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"We can add plots to plt using the SDDP.add_spaghetti function.","category":"page"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"SDDP.add_spaghetti(plt; title = \"Reservoir volume\") do data\n    return data[:volume].out\nend","category":"page"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"In addition to returning values from the simulation, you can compute things:","category":"page"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"SDDP.add_spaghetti(plt; title = \"Fuel cost\", ymin = 0, ymax = 250) do data\n    if data[:thermal_generation] > 0\n        return data[:stage_objective] / data[:thermal_generation]\n    else  # No thermal generation, so return 0.0.\n        return 0.0\n    end\nend","category":"page"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"Note that there are many keyword arguments in addition to title. For example, we fixed the minimum and maximum values of the y-axis using ymin and ymax. See the SDDP.add_spaghetti documentation for all the arguments.","category":"page"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"Having built the plot, we now need to display it using SDDP.plot.","category":"page"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"SDDP.plot(plt, \"spaghetti_plot.html\")","category":"page"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"<embed type=\"text/html\" src=\"../../assets/spaghetti_plot.html\" width=\"100%\">","category":"page"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"This should open a webpage that looks like this one.","category":"page"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"Using the mouse, you can highlight individual trajectories by hovering over them. This makes it possible to visualize a single trajectory across multiple dimensions.","category":"page"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"If you click on the plot, then trajectories that are close to the mouse pointer are shown darker and those further away are shown lighter.","category":"page"},{"location":"tutorial/plotting/#Publication-plots","page":"Plotting tools","title":"Publication plots","text":"","category":"section"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"Instead of the interactive Javascript plots, you can also create some publication ready plots using the SDDP.publication_plot function.","category":"page"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"info: Info\nYou need to install the Plots.jl package for this to work. We used the GR backend (gr()), but any Plots.jl backend should work.","category":"page"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"SDDP.publication_plot implements a plot recipe to create ribbon plots of each variable against the stages. The first argument is the vector of simulation dictionaries and the second argument is the dictionary key that you want to plot. Standard Plots.jl keyword arguments such as title and xlabel can be used to modify the look of each plot. By default, the plot displays ribbons of the 0-100, 10-90, and 25-75 percentiles. The dark, solid line in the middle is the median (i.e. 50'th percentile).","category":"page"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"import Plots\nPlots.plot(\n    SDDP.publication_plot(simulations, title = \"Outgoing volume\") do data\n        return data[:volume].out\n    end,\n    SDDP.publication_plot(simulations, title = \"Thermal generation\") do data\n        return data[:thermal_generation]\n    end;\n    xlabel = \"Stage\",\n    ylims = (0, 200),\n    layout = (1, 2),\n)","category":"page"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"You can save this plot as a PDF using the Plots.jl function savefig:","category":"page"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"Plots.savefig(\"my_picture.pdf\")","category":"page"},{"location":"tutorial/plotting/#Plotting-the-value-function","page":"Plotting tools","title":"Plotting the value function","text":"","category":"section"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"You can obtain an object representing the value function of a node using SDDP.ValueFunction.","category":"page"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"V = SDDP.ValueFunction(model[(1, 1)])","category":"page"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"The value function can be evaluated using SDDP.evaluate.","category":"page"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"SDDP.evaluate(V; volume = 1)","category":"page"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"evaluate returns the height of the value function, and a subgradient with respect to the convex state variables.","category":"page"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"You can also plot the value function using SDDP.plot","category":"page"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"SDDP.plot(V, volume = 0:200, filename = \"value_function.html\")","category":"page"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"<embed type=\"text/html\" src=\"../../assets/value_function.html\" width=\"100%\">","category":"page"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"This should open a webpage that looks like this one.","category":"page"},{"location":"tutorial/plotting/#Convergence-dashboard","page":"Plotting tools","title":"Convergence dashboard","text":"","category":"section"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"If the text-based logging isn't to your liking, you can open a visualization of the training by passing  dashboard = true to SDDP.train.","category":"page"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"SDDP.train(model; dashboard = true)","category":"page"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"By default, dashboard = false because there is an initial overhead associated with opening and preparing the plot.","category":"page"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"warning: Warning\nThe dashboard is experimental. There are known bugs associated with it, e.g., SDDP.jl#226.","category":"page"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"","category":"page"},{"location":"tutorial/plotting/","page":"Plotting tools","title":"Plotting tools","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/examples/the_farmers_problem.jl\"","category":"page"},{"location":"examples/the_farmers_problem/#The-farmer's-problem","page":"The farmer's problem","title":"The farmer's problem","text":"","category":"section"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"This problem is taken from Section 1.1 of the book Birge, J. R., & Louveaux, F. (2011). Introduction to Stochastic Programming. New York, NY: Springer New York. Paragraphs in quotes are taken verbatim.","category":"page"},{"location":"examples/the_farmers_problem/#Problem-description","page":"The farmer's problem","title":"Problem description","text":"","category":"section"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"Consider a European farmer who specializes in raising wheat, corn, and sugar beets on his 500 acres of land. During the winter, [they want] to decide how much land to devote to each crop.The farmer knows that at least 200 tons (T) of wheat and 240 T of corn are needed for cattle feed. These amounts can be raised on the farm or bought from a wholesaler. Any production in excess of the feeding requirement would be sold.Over the last decade, mean selling prices have been $170 and $150 per ton of wheat and corn, respectively. The purchase prices are 40% more than this due to the wholesaler’s margin and transportation costs.Another profitable crop is sugar beet, which [they expect] to sell at $36/T; however, the European Commission imposes a quota on sugar beet production. Any amount in excess of the quota can be sold only at $10/T. The farmer’s quota for next year is 6000 T.\"Based on past experience, the farmer knows that the mean yield on [their] land is roughly 2.5 T, 3 T, and 20 T per acre for wheat, corn, and sugar beets, respectively.[To introduce uncertainty,] assume some correlation among the yields of the different crops. A very simplified representation of this would be to assume that years are good, fair, or bad for all crops, resulting in above average, average, or below average yields for all crops. To fix these ideas, above and below average indicate a yield 20% above or below the mean yield.","category":"page"},{"location":"examples/the_farmers_problem/#Problem-data","page":"The farmer's problem","title":"Problem data","text":"","category":"section"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"The area of the farm.","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"MAX_AREA = 500.0","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"There are three crops:","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"CROPS = [:wheat, :corn, :sugar_beet]","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"Each of the crops has a different planting cost ($/acre).","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"PLANTING_COST = Dict(:wheat => 150.0, :corn => 230.0, :sugar_beet => 260.0)","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"The farmer requires a minimum quantity of wheat and corn, but not of sugar beet (tonnes).","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"MIN_QUANTITIES = Dict(:wheat => 200.0, :corn => 240.0, :sugar_beet => 0.0)","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"In Europe, there is a quota system for producing crops. The farmer owns the following quota for each crop (tonnes):","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"QUOTA_MAX = Dict(:wheat => Inf, :corn => Inf, :sugar_beet => 6_000.0)","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"The farmer can sell crops produced under the quota for the following amounts ($/tonne):","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"SELL_IN_QUOTA = Dict(:wheat => 170.0, :corn => 150.0, :sugar_beet => 36.0)","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"If they sell more than their allotted quota, the farmer earns the following on each tonne of crop above the quota ($/tonne):","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"SELL_NO_QUOTA = Dict(:wheat => 0.0, :corn => 0.0, :sugar_beet => 10.0)","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"The purchase prices for wheat and corn are 40% more than their sales price. However, the description does not address the purchase price of sugar beet. Therefore, we use a large value of $1,000/tonne.","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"BUY_PRICE = Dict(:wheat => 238.0, :corn => 210.0, :sugar_beet => 1_000.0)","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"On average, each crop has the following yield in tonnes/acre:","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"MEAN_YIELD = Dict(:wheat => 2.5, :corn => 3.0, :sugar_beet => 20.0)","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"However, the yield is random. In good years, the yield is +20% above average, and in bad years, the yield is -20% below average.","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"YIELD_MULTIPLIER = Dict(:good => 1.2, :fair => 1.0, :bad => 0.8)","category":"page"},{"location":"examples/the_farmers_problem/#Mathematical-formulation","page":"The farmer's problem","title":"Mathematical formulation","text":"","category":"section"},{"location":"examples/the_farmers_problem/#SDDP.jl-code","page":"The farmer's problem","title":"SDDP.jl code","text":"","category":"section"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"note: Note\nIn what follows, we make heavy use of the fact that you can look up variables by their symbol name in a JuMP model as follows:@variable(model, x)\nmodel[:x]Read the JuMP documentation if this isn't familiar to you.","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"First up, load SDDP.jl and a solver. For this example, we use HiGHS.jl.","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"using SDDP, HiGHS","category":"page"},{"location":"examples/the_farmers_problem/#State-variables","page":"The farmer's problem","title":"State variables","text":"","category":"section"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"State variables are the information that flows between stages. In our example, the state variables are the areas of land devoted to growing each crop.","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"function add_state_variables(subproblem)\n    @variable(subproblem, area[c = CROPS] >= 0, SDDP.State, initial_value = 0)\nend","category":"page"},{"location":"examples/the_farmers_problem/#First-stage-problem","page":"The farmer's problem","title":"First stage problem","text":"","category":"section"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"We can only plant a maximum of 500 acres, and we want to minimize the planting cost","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"function create_first_stage_problem(subproblem)\n    @constraint(\n        subproblem,\n        sum(subproblem[:area][c].out for c in CROPS) <= MAX_AREA\n    )\n    @stageobjective(\n        subproblem,\n        -sum(PLANTING_COST[c] * subproblem[:area][c].out for c in CROPS)\n    )\nend","category":"page"},{"location":"examples/the_farmers_problem/#Second-stage-problem","page":"The farmer's problem","title":"Second stage problem","text":"","category":"section"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"Now let's consider the second stage problem. This is more complicated than the first stage, so we've broken it down into four sections:","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"control variables\nconstraints\nthe objective\nthe uncertainty","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"First, let's add the second stage control variables.","category":"page"},{"location":"examples/the_farmers_problem/#Variables","page":"The farmer's problem","title":"Variables","text":"","category":"section"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"We add four types of control variables. Technically, the yield isn't a control variable. However, we add it as a dummy \"helper\" variable because it will be used when we add uncertainty.","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"function second_stage_variables(subproblem)\n    @variables(subproblem, begin\n        0 <= yield[c = CROPS]                          # tonnes/acre\n        0 <= buy[c = CROPS]                            # tonnes\n        0 <= sell_in_quota[c = CROPS] <= QUOTA_MAX[c]  # tonnes\n        0 <= sell_no_quota[c = CROPS]                  # tonnes\n    end)\nend","category":"page"},{"location":"examples/the_farmers_problem/#Constraints","page":"The farmer's problem","title":"Constraints","text":"","category":"section"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"We need to define is the minimum quantity constraint. This ensures that MIN_QUANTITIES[c] of each crop is produced.","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"function second_stage_constraint_min_quantity(subproblem)\n    @constraint(\n        subproblem,\n        [c = CROPS],\n        subproblem[:yield][c] + subproblem[:buy][c] -\n        subproblem[:sell_in_quota][c] - subproblem[:sell_no_quota][c] >=\n        MIN_QUANTITIES[c]\n    )\nend","category":"page"},{"location":"examples/the_farmers_problem/#Objective","page":"The farmer's problem","title":"Objective","text":"","category":"section"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"The objective of the second stage is to maximise revenue from selling crops, less the cost of buying corn and wheat if necessary to meet the minimum quantity constraint.","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"function second_stage_objective(subproblem)\n    @stageobjective(\n        subproblem,\n        sum(\n            SELL_IN_QUOTA[c] * subproblem[:sell_in_quota][c] +\n            SELL_NO_QUOTA[c] * subproblem[:sell_no_quota][c] -\n            BUY_PRICE[c] * subproblem[:buy][c] for c in CROPS\n        )\n    )\nend","category":"page"},{"location":"examples/the_farmers_problem/#Random-variables","page":"The farmer's problem","title":"Random variables","text":"","category":"section"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"Then, in the SDDP.parameterize function, we set the coefficient using JuMP.set_normalized_coefficient.","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"function second_stage_uncertainty(subproblem)\n    @constraint(\n        subproblem,\n        uncertainty[c = CROPS],\n        1.0 * subproblem[:area][c].in == subproblem[:yield][c]\n    )\n    SDDP.parameterize(subproblem, [:good, :fair, :bad]) do ω\n        for c in CROPS\n            JuMP.set_normalized_coefficient(\n                uncertainty[c],\n                subproblem[:area][c].in,\n                MEAN_YIELD[c] * YIELD_MULTIPLIER[ω],\n            )\n        end\n    end\nend","category":"page"},{"location":"examples/the_farmers_problem/#Putting-it-all-together","page":"The farmer's problem","title":"Putting it all together","text":"","category":"section"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"Now we're ready to build the multistage stochastic programming model. In addition to the things already discussed, we need a few extra pieces of information.","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"First, we are maximizing, so we set sense = :Max. Second, we need to provide a valid upper bound. (See Choosing an initial bound for more on this.) We know from Birge and Louveaux that the optimal solution is $108,390.  So, let's choose $500,000 just to be safe.","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"Here is the full model.","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"model = SDDP.LinearPolicyGraph(\n    stages = 2,\n    sense = :Max,\n    upper_bound = 500_000.0,\n    optimizer = HiGHS.Optimizer,\n) do subproblem, stage\n    add_state_variables(subproblem)\n    if stage == 1\n        create_first_stage_problem(subproblem)\n    else\n        second_stage_variables(subproblem)\n        second_stage_constraint_min_quantity(subproblem)\n        second_stage_uncertainty(subproblem)\n        second_stage_objective(subproblem)\n    end\nend","category":"page"},{"location":"examples/the_farmers_problem/#Training-a-policy","page":"The farmer's problem","title":"Training a policy","text":"","category":"section"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"Now that we've built a model, we need to train it using SDDP.train. The keyword iteration_limit stops the training after 20 iterations. See Choose a stopping rule for other ways to stop the training.","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"SDDP.train(model; iteration_limit = 20)","category":"page"},{"location":"examples/the_farmers_problem/#Checking-the-policy","page":"The farmer's problem","title":"Checking the policy","text":"","category":"section"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"Birge and Louveaux report that the optimal objective value is $108,390. Check that we got the correct solution using SDDP.calculate_bound:","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"@assert isapprox(SDDP.calculate_bound(model), 108_390.0, atol = 0.1)","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorial/warnings/","page":"Words of warning","title":"Words of warning","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/tutorial/warnings.jl\"","category":"page"},{"location":"tutorial/warnings/#Words-of-warning","page":"Words of warning","title":"Words of warning","text":"","category":"section"},{"location":"tutorial/warnings/","page":"Words of warning","title":"Words of warning","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorial/warnings/","page":"Words of warning","title":"Words of warning","text":"SDDP is a powerful solution technique for multistage stochastic programming. However, there are a number of subtle things to be aware of before creating your own models.","category":"page"},{"location":"tutorial/warnings/#Relatively-complete-recourse","page":"Words of warning","title":"Relatively complete recourse","text":"","category":"section"},{"location":"tutorial/warnings/","page":"Words of warning","title":"Words of warning","text":"Models built in SDDP.jl need a property called relatively complete recourse.","category":"page"},{"location":"tutorial/warnings/","page":"Words of warning","title":"Words of warning","text":"One definition of relatively complete recourse is that all feasible decisions (not necessarily optimal) in a subproblem lead to feasible decisions in future subproblems.","category":"page"},{"location":"tutorial/warnings/","page":"Words of warning","title":"Words of warning","text":"For example, in the following problem, one feasible first stage decision is x.out = 0. But this causes an infeasibility in the second stage which requires x.in >= 1. This will throw an error about infeasibility if you try to solve.","category":"page"},{"location":"tutorial/warnings/","page":"Words of warning","title":"Words of warning","text":"using SDDP, HiGHS\n\nmodel = SDDP.LinearPolicyGraph(\n    stages = 2,\n    lower_bound = 0,\n    optimizer = HiGHS.Optimizer,\n) do sp, t\n    @variable(sp, x >= 0, SDDP.State, initial_value = 1)\n    if t == 2\n        @constraint(sp, x.in >= 1)\n    end\n    @stageobjective(sp, x.out)\nend\n\ntry                         #hide\n    SDDP.train(model, iteration_limit = 1, print_level = 0)\ncatch err                   #hide\n    showerror(stderr, err)  #hide\nend                         #hide","category":"page"},{"location":"tutorial/warnings/","page":"Words of warning","title":"Words of warning","text":"warning: Warning\nThe actual constraints causing the infeasibilities can be deceptive! A good strategy to debug is to comment out all constraints. Then, one-by-one, un-comment the constraints and try resolving the model to check if it finds a feasible solution.","category":"page"},{"location":"tutorial/warnings/#Numerical-stability","page":"Words of warning","title":"Numerical stability","text":"","category":"section"},{"location":"tutorial/warnings/","page":"Words of warning","title":"Words of warning","text":"If you aren't aware, SDDP builds an outer-approximation to a convex function using cutting planes. This results in a formulation that is particularly hard for solvers like HiGHS, Gurobi, and CPLEX to deal with. As a result, you may run into weird behavior. This behavior could include:","category":"page"},{"location":"tutorial/warnings/","page":"Words of warning","title":"Words of warning","text":"Iterations suddenly taking a long time (the solver stalled)\nSubproblems turning infeasible or unbounded after many iterations\nSolvers returning \"Numerical Error\" statuses","category":"page"},{"location":"tutorial/warnings/#Problem-scaling","page":"Words of warning","title":"Problem scaling","text":"","category":"section"},{"location":"tutorial/warnings/","page":"Words of warning","title":"Words of warning","text":"In almost all cases, the cause of this is poor problem scaling. For our purpose, poor problem scaling means having variables with very large numbers and variables with very small numbers in the same model.","category":"page"},{"location":"tutorial/warnings/","page":"Words of warning","title":"Words of warning","text":"tip: Tip\nGurobi has an excellent set of articles on numerical issues and how to avoid them.","category":"page"},{"location":"tutorial/warnings/","page":"Words of warning","title":"Words of warning","text":"Consider, for example, the hydro-thermal scheduling problem we have been discussing in previous tutorials.","category":"page"},{"location":"tutorial/warnings/","page":"Words of warning","title":"Words of warning","text":"If we define the volume of the reservoir in terms of m³, then a lake might have a capacity of 10^10 m³: @variable(subproblem, 0 <= volume <= 10^10). Moreover, the cost per cubic meter might be around $0.05/m³. To calculate the  value of water in our reservoir, we need to multiple a variable on the order of 10^10, by one on the order of 10⁻²! That is twelve orders of magnitude!","category":"page"},{"location":"tutorial/warnings/","page":"Words of warning","title":"Words of warning","text":"To improve the performance of the SDDP algorithm (and reduce the chance of weird behavior), try to re-scale the units of the problem in order to reduce the largest difference in magnitude. For example, if we talk in terms of million m³, then we have a capacity of 10⁴ million m³, and a price of $50,000 per million m³. Now things are only one order of magnitude apart.","category":"page"},{"location":"tutorial/warnings/#Numerical-stability-report","page":"Words of warning","title":"Numerical stability report","text":"","category":"section"},{"location":"tutorial/warnings/","page":"Words of warning","title":"Words of warning","text":"To aid in the diagnose of numerical issues, you can call SDDP.numerical_stability_report. By default, this aggregates all of the nodes into a single report. You can produce a stability report for each node by passing by_node=true.","category":"page"},{"location":"tutorial/warnings/","page":"Words of warning","title":"Words of warning","text":"using SDDP\n\nmodel = SDDP.LinearPolicyGraph(stages = 2, lower_bound = -1e10) do subproblem, t\n    @variable(subproblem, x >= -1e7, SDDP.State, initial_value = 1e-5)\n    @constraint(subproblem, 1e9 * x.out >= 1e-6 * x.in + 1e-8)\n    @stageobjective(subproblem, 1e9 * x.out)\nend\n\nSDDP.numerical_stability_report(model)","category":"page"},{"location":"tutorial/warnings/","page":"Words of warning","title":"Words of warning","text":"The report analyses the magnitude (in absolute terms) of the coefficients in the constraint matrix, the objective function, any variable bounds, and in the RHS of the constraints. A warning will be thrown in SDDP.jl detects very large or small values. As discussed in Problem scaling, this is an indication that you should reformulate your model.","category":"page"},{"location":"tutorial/warnings/","page":"Words of warning","title":"Words of warning","text":"By default, a numerical stability check is run when you call SDDP.train, although it can be turned off by passing run_numerical_stability_report = false.","category":"page"},{"location":"tutorial/warnings/#Solver-specific-options","page":"Words of warning","title":"Solver-specific options","text":"","category":"section"},{"location":"tutorial/warnings/","page":"Words of warning","title":"Words of warning","text":"If you have a particularly troublesome model, you should investigate setting solver-specific options to improve the numerical stability of each solver. For example, Gurobi has a NumericFocus option.","category":"page"},{"location":"tutorial/warnings/#Choosing-an-initial-bound","page":"Words of warning","title":"Choosing an initial bound","text":"","category":"section"},{"location":"tutorial/warnings/","page":"Words of warning","title":"Words of warning","text":"One of the important requirements when building a SDDP model is to choose an appropriate bound on the objective (lower if minimizing, upper if maximizing). However, it can be hard to choose a bound if you don't know the solution! (Which is very likely.)","category":"page"},{"location":"tutorial/warnings/","page":"Words of warning","title":"Words of warning","text":"The bound should not be as large as possible (since this will help with convergence and the numerical issues discussed above), but if chosen too small, it may cut off the feasible region and lead to a sub-optimal solution.","category":"page"},{"location":"tutorial/warnings/","page":"Words of warning","title":"Words of warning","text":"Consider the following simple model, where we first set lower_bound to 0.0.","category":"page"},{"location":"tutorial/warnings/","page":"Words of warning","title":"Words of warning","text":"using SDDP, HiGHS\n\nmodel = SDDP.LinearPolicyGraph(\n    stages = 3,\n    sense = :Min,\n    lower_bound = 0.0,\n    optimizer = HiGHS.Optimizer,\n) do subproblem, t\n    @variable(subproblem, x >= 0, SDDP.State, initial_value = 2)\n    @variable(subproblem, u >= 0)\n    @variable(subproblem, v >= 0)\n    @constraint(subproblem, x.out == x.in - u)\n    @constraint(subproblem, u + v == 1.5)\n    @stageobjective(subproblem, t * v)\nend\n\nSDDP.train(model, iteration_limit = 5, run_numerical_stability_report = false)","category":"page"},{"location":"tutorial/warnings/","page":"Words of warning","title":"Words of warning","text":"Now consider the case when we set the lower_bound to 10.0:","category":"page"},{"location":"tutorial/warnings/","page":"Words of warning","title":"Words of warning","text":"using SDDP, HiGHS\n\nmodel = SDDP.LinearPolicyGraph(\n    stages = 3,\n    sense = :Min,\n    lower_bound = 10.0,\n    optimizer = HiGHS.Optimizer,\n) do subproblem, t\n    @variable(subproblem, x >= 0, SDDP.State, initial_value = 2)\n    @variable(subproblem, u >= 0)\n    @variable(subproblem, v >= 0)\n    @constraint(subproblem, x.out == x.in - u)\n    @constraint(subproblem, u + v == 1.5)\n    @stageobjective(subproblem, t * v)\nend\n\nSDDP.train(model, iteration_limit = 5, run_numerical_stability_report = false)","category":"page"},{"location":"tutorial/warnings/","page":"Words of warning","title":"Words of warning","text":"How do we tell which is more appropriate? There are a few clues that you should look out for.","category":"page"},{"location":"tutorial/warnings/","page":"Words of warning","title":"Words of warning","text":"The bound converges to a value above (if minimizing) the simulated cost of the policy. In this case, the problem is deterministic, so it is easy to tell. But you can also check by performing a Monte Carlo simulation like we did in An introduction to SDDP.jl.\nThe bound converges to different values when we change the bound. This is another clear give-away. The bound provided by the user is only used in the initial iterations. It should not change the value of the converged policy. Thus, if you don't know an appropriate value for the bound, choose an initial value, and then increase (or decrease) the value of the bound to confirm that the value of the policy doesn't change.\nThe bound converges to a value close to the bound provided by the user. This varies between models, but notice that 11.0 is quite close to 10.0 compared with 3.5 and 0.0.","category":"page"},{"location":"tutorial/warnings/","page":"Words of warning","title":"Words of warning","text":"","category":"page"},{"location":"tutorial/warnings/","page":"Words of warning","title":"Words of warning","text":"This page was generated using Literate.jl.","category":"page"},{"location":"guides/add_a_multidimensional_state_variable/#Add-a-multi-dimensional-state-variable","page":"Add a multi-dimensional state variable","title":"Add a multi-dimensional state variable","text":"","category":"section"},{"location":"guides/add_a_multidimensional_state_variable/","page":"Add a multi-dimensional state variable","title":"Add a multi-dimensional state variable","text":"DocTestSetup = quote\n    using SDDP, HiGHS\nend","category":"page"},{"location":"guides/add_a_multidimensional_state_variable/","page":"Add a multi-dimensional state variable","title":"Add a multi-dimensional state variable","text":"Just like normal JuMP variables, it is possible to create containers of state variables.","category":"page"},{"location":"guides/add_a_multidimensional_state_variable/","page":"Add a multi-dimensional state variable","title":"Add a multi-dimensional state variable","text":"julia> model = SDDP.LinearPolicyGraph(\n           stages=1, lower_bound = 0, optimizer = HiGHS.Optimizer\n       ) do subproblem, t\n           # A scalar state variable.\n           @variable(subproblem, x >= 0, SDDP.State, initial_value = 0)\n           println(\"Lower bound of outgoing x is: \", JuMP.lower_bound(x.out))\n           # A vector of state variables.\n           @variable(subproblem, y[i = 1:2] >= i, SDDP.State, initial_value = i)\n           println(\"Lower bound of outgoing y[1] is: \", JuMP.lower_bound(y[1].out))\n           # A JuMP.Containers.DenseAxisArray of state variables.\n           @variable(subproblem,\n               z[i = 3:4, j = [:A, :B]] >= i, SDDP.State, initial_value = i)\n           println(\"Lower bound of outgoing z[3, :B] is: \", JuMP.lower_bound(z[3, :B].out))\n       end;\nLower bound of outgoing x is: 0.0\nLower bound of outgoing y[1] is: 1.0\nLower bound of outgoing z[3, :B] is: 3.0","category":"page"},{"location":"tutorial/objective_uncertainty/","page":"Uncertainty in the objective function","title":"Uncertainty in the objective function","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/tutorial/objective_uncertainty.jl\"","category":"page"},{"location":"tutorial/objective_uncertainty/#Uncertainty-in-the-objective-function","page":"Uncertainty in the objective function","title":"Uncertainty in the objective function","text":"","category":"section"},{"location":"tutorial/objective_uncertainty/","page":"Uncertainty in the objective function","title":"Uncertainty in the objective function","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorial/objective_uncertainty/","page":"Uncertainty in the objective function","title":"Uncertainty in the objective function","text":"In the previous tutorial, An introduction to SDDP.jl, we created a stochastic hydro-thermal scheduling model. In this tutorial, we extend the problem by adding uncertainty to the fuel costs.","category":"page"},{"location":"tutorial/objective_uncertainty/","page":"Uncertainty in the objective function","title":"Uncertainty in the objective function","text":"Previously, we assumed that the fuel cost was deterministic: $50/MWh in the first stage, $100/MWh in the second stage, and $150/MWh in the third stage. For this tutorial, we assume that in addition to these base costs, the actual fuel cost is correlated with the inflows.","category":"page"},{"location":"tutorial/objective_uncertainty/","page":"Uncertainty in the objective function","title":"Uncertainty in the objective function","text":"Our new model for the uncertainty is given by the following table:","category":"page"},{"location":"tutorial/objective_uncertainty/","page":"Uncertainty in the objective function","title":"Uncertainty in the objective function","text":"ω 1 2 3\nP(ω) 1/3 1/3 1/3\ninflow 0 50 100\nfuel multiplier 1.5 1.0 0.75","category":"page"},{"location":"tutorial/objective_uncertainty/","page":"Uncertainty in the objective function","title":"Uncertainty in the objective function","text":"In stage t, the objective is now to minimize:","category":"page"},{"location":"tutorial/objective_uncertainty/","page":"Uncertainty in the objective function","title":"Uncertainty in the objective function","text":"fuel_multiplier * fuel_cost[t] * thermal_generation","category":"page"},{"location":"tutorial/objective_uncertainty/#Creating-a-model","page":"Uncertainty in the objective function","title":"Creating a model","text":"","category":"section"},{"location":"tutorial/objective_uncertainty/","page":"Uncertainty in the objective function","title":"Uncertainty in the objective function","text":"To add an uncertain objective, we can simply call @stageobjective from inside the SDDP.parameterize function.","category":"page"},{"location":"tutorial/objective_uncertainty/","page":"Uncertainty in the objective function","title":"Uncertainty in the objective function","text":"using SDDP, HiGHS\n\nmodel = SDDP.LinearPolicyGraph(\n    stages = 3,\n    sense = :Min,\n    lower_bound = 0.0,\n    optimizer = HiGHS.Optimizer,\n) do subproblem, t\n    # Define the state variable.\n    @variable(subproblem, 0 <= volume <= 200, SDDP.State, initial_value = 200)\n    # Define the control variables.\n    @variables(subproblem, begin\n        thermal_generation >= 0\n        hydro_generation >= 0\n        hydro_spill >= 0\n        inflow\n    end)\n    # Define the constraints\n    @constraints(\n        subproblem,\n        begin\n            volume.out == volume.in + inflow - hydro_generation - hydro_spill\n            thermal_generation + hydro_generation == 150.0\n        end\n    )\n    fuel_cost = [50.0, 100.0, 150.0]\n    # Parameterize the subproblem.\n    Ω = [\n        (inflow = 0.0, fuel_multiplier = 1.5),\n        (inflow = 50.0, fuel_multiplier = 1.0),\n        (inflow = 100.0, fuel_multiplier = 0.75),\n    ]\n    SDDP.parameterize(subproblem, Ω, [1 / 3, 1 / 3, 1 / 3]) do ω\n        JuMP.fix(inflow, ω.inflow)\n        @stageobjective(\n            subproblem,\n            ω.fuel_multiplier * fuel_cost[t] * thermal_generation\n        )\n    end\nend","category":"page"},{"location":"tutorial/objective_uncertainty/#Training-and-simulating-the-policy","page":"Uncertainty in the objective function","title":"Training and simulating the policy","text":"","category":"section"},{"location":"tutorial/objective_uncertainty/","page":"Uncertainty in the objective function","title":"Uncertainty in the objective function","text":"As in the previous two tutorials, we train and simulate the policy:","category":"page"},{"location":"tutorial/objective_uncertainty/","page":"Uncertainty in the objective function","title":"Uncertainty in the objective function","text":"SDDP.train(model)\n\nsimulations = SDDP.simulate(model, 500)\n\nobjective_values =\n    [sum(stage[:stage_objective] for stage in sim) for sim in simulations]\n\nusing Statistics\n\nμ = round(mean(objective_values), digits = 2)\nci = round(1.96 * std(objective_values) / sqrt(500), digits = 2)\n\nprintln(\"Confidence interval: \", μ, \" ± \", ci)\nprintln(\"Lower bound: \", round(SDDP.calculate_bound(model), digits = 2))","category":"page"},{"location":"tutorial/objective_uncertainty/","page":"Uncertainty in the objective function","title":"Uncertainty in the objective function","text":"","category":"page"},{"location":"tutorial/objective_uncertainty/","page":"Uncertainty in the objective function","title":"Uncertainty in the objective function","text":"This page was generated using Literate.jl.","category":"page"},{"location":"guides/add_a_risk_measure/#Add-a-risk-measure","page":"Add a risk measure","title":"Add a risk measure","text":"","category":"section"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"DocTestSetup = quote\n    using SDDP, HiGHS\nend","category":"page"},{"location":"guides/add_a_risk_measure/#Training-a-risk-averse-model","page":"Add a risk measure","title":"Training a risk-averse model","text":"","category":"section"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"SDDP.jl supports a variety of risk measures. Two common ones are SDDP.Expectation and SDDP.WorstCase. Let's see how to train a policy using them. There are three possible ways.","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"If the same risk measure is used at every node in the policy graph, we can just pass an instance of one of the risk measures to the risk_measure keyword argument of the SDDP.train function.","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"SDDP.train(\n    model,\n    risk_measure = SDDP.WorstCase(),\n    iteration_limit = 10\n)","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"However, if you want different risk measures at different nodes, there are two options. First, you can pass risk_measure a dictionary of risk measures, with one entry for each node. The keys of the dictionary are the indices of the nodes.","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"SDDP.train(\n    model,\n    risk_measure = Dict(\n        1 => SDDP.Expectation(),\n        2 => SDDP.WorstCase()\n    ),\n    iteration_limit = 10\n)","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"An alternative method is to pass risk_measure a function that takes one argument, the index of a node, and returns an instance of a risk measure:","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"SDDP.train(\n    model,\n    risk_measure = (node_index) -> begin\n        if node_index == 1\n            return SDDP.Expectation()\n        else\n            return SDDP.WorstCase()\n        end\n    end,\n    iteration_limit = 10\n)","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"note: Note\nIf you simulate the policy, the simulated value is the risk-neutral value of the policy.","category":"page"},{"location":"guides/add_a_risk_measure/#Risk-measures","page":"Add a risk measure","title":"Risk measures","text":"","category":"section"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"To illustrate the risk-measures included in SDDP.jl, we consider a discrete random variable with four outcomes.","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"The random variable is supported on the values 1, 2, 3, and 4:","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"noise_supports = [1, 2, 3, 4]","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"The associated probability of each outcome is as follows:","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"nominal_probability = [0.1, 0.2, 0.3, 0.4]","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"With each outcome ω, the agent observes a cost Z(ω):","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"cost_realizations = [5.0, 4.0, 6.0, 2.0]","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"We assume that we are minimizing:","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"is_minimization = true","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"Finally, we create a vector that will be used to store the risk-adjusted probabilities:","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"risk_adjusted_probability = zeros(4)","category":"page"},{"location":"guides/add_a_risk_measure/#Expectation","page":"Add a risk measure","title":"Expectation","text":"","category":"section"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"SDDP.Expectation","category":"page"},{"location":"guides/add_a_risk_measure/#SDDP.Expectation","page":"Add a risk measure","title":"SDDP.Expectation","text":"Expectation()\n\nThe Expectation risk measure. Identical to taking the expectation with respect to the nominal distribution.\n\n\n\n\n\n","category":"type"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"using SDDP\nSDDP.adjust_probability(\n    SDDP.Expectation(),\n    risk_adjusted_probability,\n    nominal_probability,\n    noise_supports,\n    cost_realizations,\n    is_minimization\n)\nrisk_adjusted_probability","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"SDDP.Expectation is the default risk measure in SDDP.jl.","category":"page"},{"location":"guides/add_a_risk_measure/#Worst-case","page":"Add a risk measure","title":"Worst-case","text":"","category":"section"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"SDDP.WorstCase","category":"page"},{"location":"guides/add_a_risk_measure/#SDDP.WorstCase","page":"Add a risk measure","title":"SDDP.WorstCase","text":"WorstCase()\n\nThe worst-case risk measure. Places all of the probability weight on the worst outcome.\n\n\n\n\n\n","category":"type"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"SDDP.adjust_probability(\n    SDDP.WorstCase(),\n    risk_adjusted_probability,\n    nominal_probability,\n    noise_supports,\n    cost_realizations,\n    is_minimization\n)\nrisk_adjusted_probability","category":"page"},{"location":"guides/add_a_risk_measure/#Average-value-at-risk-(AV@R)","page":"Add a risk measure","title":"Average value at risk (AV@R)","text":"","category":"section"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"SDDP.AVaR","category":"page"},{"location":"guides/add_a_risk_measure/#SDDP.AVaR","page":"Add a risk measure","title":"SDDP.AVaR","text":"AVaR(β)\n\nThe average value at risk (AV@R) risk measure.\n\nComputes the expectation of the β fraction of worst outcomes. β must be in [0, 1]. When β=1, this is equivalent to the Expectation risk measure. When β=0, this is equivalent  to the WorstCase risk measure.\n\nAV@R is also known as the conditional value at risk (CV@R) or expected shortfall.\n\n\n\n\n\n","category":"type"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"SDDP.adjust_probability(\n    SDDP.AVaR(0.5),\n    risk_adjusted_probability,\n    nominal_probability,\n    noise_supports,\n    cost_realizations,\n    is_minimization\n)\nrisk_adjusted_probability","category":"page"},{"location":"guides/add_a_risk_measure/#Convex-combination-of-risk-measures","page":"Add a risk measure","title":"Convex combination of risk measures","text":"","category":"section"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"Using the axioms of coherent risk measures, it is easy to show that any convex combination of coherent risk measures is also a coherent risk measure. Convex combinations of risk measures can be created directly:","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"cvx_comb_measure = 0.5 * SDDP.Expectation() + 0.5 * SDDP.WorstCase()\nSDDP.adjust_probability(\n    cvx_comb_measure,\n    risk_adjusted_probability,\n    nominal_probability,\n    noise_supports,\n    cost_realizations,\n    is_minimization\n)\nrisk_adjusted_probability","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"As a special case, the SDDP.EAVaR risk-measure is a convex combination of SDDP.Expectation and SDDP.AVaR:","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"SDDP.EAVaR(beta=0.25, lambda=0.4)","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"SDDP.EAVaR","category":"page"},{"location":"guides/add_a_risk_measure/#SDDP.EAVaR","page":"Add a risk measure","title":"SDDP.EAVaR","text":"EAVaR(;lambda=1.0, beta=1.0)\n\nA risk measure that is a convex combination of Expectation and Average Value @ Risk (also called Conditional Value @ Risk).\n\n    λ * E[x] + (1 - λ) * AV@R(β)[x]\n\nKeyword Arguments\n\nlambda: Convex weight on the expectation ((1-lambda) weight is put on the AV@R component. Inreasing values of lambda are less risk averse (more weight on expectation).\nbeta: The quantile at which to calculate the Average Value @ Risk. Increasing values of beta are less risk averse. If beta=0, then the AV@R component is the worst case risk measure.\n\n\n\n\n\n","category":"function"},{"location":"guides/add_a_risk_measure/#Distributionally-robust","page":"Add a risk measure","title":"Distributionally robust","text":"","category":"section"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"SDDP.jl supports two types of distributionally robust risk measures: the modified Χ² method of Philpott et al. (2018), and a method based on the Wasserstein distance metric.","category":"page"},{"location":"guides/add_a_risk_measure/#Modified-Chi-squard","page":"Add a risk measure","title":"Modified Chi-squard","text":"","category":"section"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"SDDP.ModifiedChiSquared","category":"page"},{"location":"guides/add_a_risk_measure/#SDDP.ModifiedChiSquared","page":"Add a risk measure","title":"SDDP.ModifiedChiSquared","text":"ModifiedChiSquared(radius::Float64; minimum_std=1e-5)\n\nThe distributionally robust SDDP risk measure of Philpott, A., de Matos, V., Kapelevich, L. Distributionally robust SDDP. Computational Management Science (2018) 165:431-454.\n\nExplanation\n\nIn a Distributionally Robust Optimization (DRO) approach, we modify the probabilities we associate with all future scenarios so that the resulting probability distribution is the \"worst case\" probability distribution, in some sense.\n\nIn each backward pass we will compute a worst case probability distribution vector p. We compute p so that:\n\np ∈ argmax p'z\n      s.t. [r; p - a] in SecondOrderCone()\n           sum(p) == 1\n           p >= 0\n\nwhere\n\nz is a vector of future costs. We assume that our aim is to minimize  future cost p'z. If we maximize reward, we would have p ∈ argmin{p'z}.\na is the uniform distribution\nr is a user specified radius - the larger the radius, the more conservative the policy.\n\nNotes\n\nThe largest radius that will work with S scenarios is sqrt((S-1)/S).\n\nIf the uncorrected standard deviation of the objecive realizations is less than minimum_std, then the risk-measure will default to Expectation().\n\nThis code was contributed by Lea Kapelevich.\n\n\n\n\n\n","category":"type"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"SDDP.adjust_probability(\n    SDDP.ModifiedChiSquared(0.5),\n    risk_adjusted_probability,\n    [0.25, 0.25, 0.25, 0.25],\n    noise_supports,\n    cost_realizations,\n    is_minimization\n)\nrisk_adjusted_probability","category":"page"},{"location":"guides/add_a_risk_measure/#Wasserstein","page":"Add a risk measure","title":"Wasserstein","text":"","category":"section"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"SDDP.Wasserstein","category":"page"},{"location":"guides/add_a_risk_measure/#SDDP.Wasserstein","page":"Add a risk measure","title":"SDDP.Wasserstein","text":"Wasserstein(norm::Function, solver_factory; alpha::Float64)\n\nA distributionally-robust risk measure based on the Wasserstein distance.\n\nAs alpha increases, the measure becomes more risk-averse. When alpha=0, the measure is equivalent to the expectation operator. As alpha increases, the measure approaches the Worst-case risk measure.\n\n\n\n\n\n","category":"type"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"import HiGHS\nSDDP.adjust_probability(\n    SDDP.Wasserstein(HiGHS.Optimizer; alpha=0.5) do x, y\n        return abs(x - y)\n    end,\n    risk_adjusted_probability,\n    nominal_probability,\n    noise_supports,\n    cost_realizations,\n    is_minimization\n)\nrisk_adjusted_probability","category":"page"},{"location":"guides/add_a_risk_measure/#Entropic","page":"Add a risk measure","title":"Entropic","text":"","category":"section"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"SDDP.Entropic","category":"page"},{"location":"guides/add_a_risk_measure/#SDDP.Entropic","page":"Add a risk measure","title":"SDDP.Entropic","text":"Entropic(γ::Float64)\n\nThe entropic risk measure as described by:\n\nDowson, O., Morton, D.P. & Pagnoncelli, B.K. Incorporating convex risk\nmeasures into multistage stochastic programming algorithms. Annals of\nOperations Research (2022). [doi](https://doi.org/10.1007/s10479-022-04977-w).\n\nAs γ increases, the measure becomes more risk-averse.\n\n\n\n\n\n","category":"type"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"SDDP.adjust_probability(\n    SDDP.Entropic(0.1),\n    risk_adjusted_probability,\n    nominal_probability,\n    noise_supports,\n    cost_realizations,\n    is_minimization\n)\nrisk_adjusted_probability","category":"page"},{"location":"examples/infinite_horizon_trivial/","page":"Infinite horizon trivial","title":"Infinite horizon trivial","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/examples/infinite_horizon_trivial.jl\"","category":"page"},{"location":"examples/infinite_horizon_trivial/#Infinite-horizon-trivial","page":"Infinite horizon trivial","title":"Infinite horizon trivial","text":"","category":"section"},{"location":"examples/infinite_horizon_trivial/","page":"Infinite horizon trivial","title":"Infinite horizon trivial","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/infinite_horizon_trivial/","page":"Infinite horizon trivial","title":"Infinite horizon trivial","text":"using SDDP, HiGHS, Test\n\nfunction infinite_trivial()\n    graph = SDDP.Graph(\n        :root_node,\n        [:week],\n        [(:root_node => :week, 1.0), (:week => :week, 0.9)],\n    )\n    model = SDDP.PolicyGraph(\n        graph,\n        lower_bound = 0.0,\n        optimizer = HiGHS.Optimizer,\n    ) do subproblem, node\n        @variable(subproblem, state, SDDP.State, initial_value = 0)\n        @constraint(subproblem, state.in == state.out)\n        @stageobjective(subproblem, 2.0)\n    end\n    SDDP.train(model; log_frequency = 10)\n    @test SDDP.calculate_bound(model) ≈ 2.0 / (1 - 0.9) atol = 1e-3\n    return\nend\n\ninfinite_trivial()","category":"page"},{"location":"examples/infinite_horizon_trivial/","page":"Infinite horizon trivial","title":"Infinite horizon trivial","text":"","category":"page"},{"location":"examples/infinite_horizon_trivial/","page":"Infinite horizon trivial","title":"Infinite horizon trivial","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/air_conditioning/","page":"Air conditioning","title":"Air conditioning","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/examples/air_conditioning.jl\"","category":"page"},{"location":"examples/air_conditioning/#Air-conditioning","page":"Air conditioning","title":"Air conditioning","text":"","category":"section"},{"location":"examples/air_conditioning/","page":"Air conditioning","title":"Air conditioning","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/air_conditioning/","page":"Air conditioning","title":"Air conditioning","text":"Taken from Anthony Papavasiliou's notes on SDDP","category":"page"},{"location":"examples/air_conditioning/","page":"Air conditioning","title":"Air conditioning","text":"Consider the following problem","category":"page"},{"location":"examples/air_conditioning/","page":"Air conditioning","title":"Air conditioning","text":"Produce air conditioners for 3 months\n200 units/month at 100 $/unit\nOvertime costs 300 $/unit\nKnown demand of 100 units for period 1\nEqually likely demand, 100 or 300 units, for periods 2, 3\nStorage cost is 50 $/unit\nAll demand must be met","category":"page"},{"location":"examples/air_conditioning/","page":"Air conditioning","title":"Air conditioning","text":"The known optimal solution is $62,500","category":"page"},{"location":"examples/air_conditioning/","page":"Air conditioning","title":"Air conditioning","text":"using SDDP, HiGHS, Test\n\nfunction air_conditioning_model(duality_handler)\n    model = SDDP.LinearPolicyGraph(\n        stages = 3,\n        lower_bound = 0.0,\n        optimizer = HiGHS.Optimizer,\n    ) do sp, stage\n        @variable(\n            sp,\n            0 <= stored_production <= 100,\n            Int,\n            SDDP.State,\n            initial_value = 0\n        )\n        @variable(sp, 0 <= production <= 200, Int)\n        @variable(sp, overtime >= 0, Int)\n        @variable(sp, demand)\n        DEMAND = [[100.0], [100.0, 300.0], [100.0, 300.0]]\n        SDDP.parameterize(ω -> JuMP.fix(demand, ω), sp, DEMAND[stage])\n        @constraint(\n            sp,\n            stored_production.out ==\n            stored_production.in + production + overtime - demand\n        )\n        @stageobjective(\n            sp,\n            100 * production + 300 * overtime + 50 * stored_production.out\n        )\n    end\n    SDDP.train(model; duality_handler = duality_handler)\n    @test isapprox(SDDP.calculate_bound(model), 62_500.0, atol = 0.1)\n    return\nend\n\nfor duality_handler in [SDDP.LagrangianDuality(), SDDP.ContinuousConicDuality()]\n    air_conditioning_model(duality_handler)\nend","category":"page"},{"location":"examples/air_conditioning/","page":"Air conditioning","title":"Air conditioning","text":"","category":"page"},{"location":"examples/air_conditioning/","page":"Air conditioning","title":"Air conditioning","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/sldp_example_two/","page":"SLDP: example 2","title":"SLDP: example 2","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/examples/sldp_example_two.jl\"","category":"page"},{"location":"examples/sldp_example_two/#SLDP:-example-2","page":"SLDP: example 2","title":"SLDP: example 2","text":"","category":"section"},{"location":"examples/sldp_example_two/","page":"SLDP: example 2","title":"SLDP: example 2","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/sldp_example_two/","page":"SLDP: example 2","title":"SLDP: example 2","text":"This example is derived from Section 4.3 of the paper: Ahmed, S., Cabral, F. G., & da Costa, B. F. P. (2019). Stochastic Lipschitz Dynamic Programming. Optimization Online. PDF","category":"page"},{"location":"examples/sldp_example_two/","page":"SLDP: example 2","title":"SLDP: example 2","text":"using SDDP\nimport HiGHS\nimport Test\n\nfunction sldp_example_two(; first_stage_integer::Bool = true, N = 2)\n    model = SDDP.LinearPolicyGraph(\n        stages = 2,\n        lower_bound = -100.0,\n        optimizer = HiGHS.Optimizer,\n    ) do sp, t\n        @variable(sp, 0 <= x[1:2] <= 5, SDDP.State, initial_value = 0.0)\n        if t == 1\n            if first_stage_integer\n                @variable(sp, 0 <= u[1:2] <= 5, Int)\n                @constraint(sp, [i = 1:2], u[i] == x[i].out)\n            end\n            @stageobjective(sp, -1.5 * x[1].out - 4 * x[2].out)\n        else\n            @variable(sp, 0 <= y[1:4] <= 1, Bin)\n            @variable(sp, ω[1:2])\n            @stageobjective(sp, -16 * y[1] - 19 * y[2] - 23 * y[3] - 28 * y[4])\n            @constraint(\n                sp,\n                2 * y[1] + 3 * y[2] + 4 * y[3] + 5 * y[4] <= ω[1] - x[1].in\n            )\n            @constraint(\n                sp,\n                6 * y[1] + 1 * y[2] + 3 * y[3] + 2 * y[4] <= ω[2] - x[2].in\n            )\n            steps = range(5, stop = 15, length = N)\n            SDDP.parameterize(sp, [[i, j] for i in steps for j in steps]) do φ\n                return JuMP.fix.(ω, φ)\n            end\n        end\n    end\n    if get(ARGS, 1, \"\") == \"--write\"\n        # Run `$ julia sldp_example_two.jl --write` to update the benchmark\n        # model directory\n        model_dir = joinpath(@__DIR__, \"..\", \"..\", \"..\", \"benchmarks\", \"models\")\n        SDDP.write_to_file(\n            model,\n            joinpath(model_dir, \"sldp_example_two_$(N).sof.json.gz\");\n            test_scenarios = 30,\n        )\n        return\n    end\n    SDDP.train(model; log_frequency = 10)\n    bound = SDDP.calculate_bound(model)\n\n    if N == 2\n        Test.@test bound <= -57.0\n    elseif N == 3\n        Test.@test bound <= -59.33\n    elseif N == 6\n        Test.@test bound <= -61.22\n    end\n    return\nend\n\nsldp_example_two(N = 2)\nsldp_example_two(N = 3)\nsldp_example_two(N = 6)","category":"page"},{"location":"examples/sldp_example_two/","page":"SLDP: example 2","title":"SLDP: example 2","text":"","category":"page"},{"location":"examples/sldp_example_two/","page":"SLDP: example 2","title":"SLDP: example 2","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorial/objective_states/","page":"Objective states","title":"Objective states","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/tutorial/objective_states.jl\"","category":"page"},{"location":"tutorial/objective_states/#Objective-states","page":"Objective states","title":"Objective states","text":"","category":"section"},{"location":"tutorial/objective_states/","page":"Objective states","title":"Objective states","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorial/objective_states/","page":"Objective states","title":"Objective states","text":"There are many applications in which we want to model a price process that follows some auto-regressive process. Common examples include stock prices on financial exchanges and spot-prices in energy markets.","category":"page"},{"location":"tutorial/objective_states/","page":"Objective states","title":"Objective states","text":"However, it is well known that these cannot be incorporated in to SDDP because they result in cost-to-go functions that are convex with respect to some state variables (e.g., the reservoir levels) and concave with respect to other state variables (e.g., the spot price in the current stage).","category":"page"},{"location":"tutorial/objective_states/","page":"Objective states","title":"Objective states","text":"To overcome this problem, the approach in the literature has been to discretize the price process in order to model it using a Markovian policy graph like those discussed in Markovian policy graphs.","category":"page"},{"location":"tutorial/objective_states/","page":"Objective states","title":"Objective states","text":"However, recent work offers a way to include stagewise-dependent objective uncertainty into the objective function of SDDP subproblems. Readers are directed to the following works for an introduction:","category":"page"},{"location":"tutorial/objective_states/","page":"Objective states","title":"Objective states","text":"Downward, A., Dowson, O., and Baucke, R. (2017). Stochastic dual dynamic programming with stagewise dependent objective uncertainty. Optimization Online. link\nDowson, O. PhD Thesis. University of Auckland, 2018. link","category":"page"},{"location":"tutorial/objective_states/","page":"Objective states","title":"Objective states","text":"The method discussed in the above works introduces the concept of an objective state into SDDP. Unlike normal state variables in SDDP (e.g., the volume of water in the reservoir), the cost-to-go function is concave with respect to the objective states. Thus, the method builds an outer approximation of the cost-to-go function in the normal state-space, and an inner approximation of the cost-to-go function in the objective state-space.","category":"page"},{"location":"tutorial/objective_states/","page":"Objective states","title":"Objective states","text":"warning: Warning\nSupport for objective states in SDDP.jl is experimental. Models are considerably more computational intensive, the interface is less user-friendly, and there are subtle gotchas to be aware of. Only use this if you have read and understood the theory behind the method.","category":"page"},{"location":"tutorial/objective_states/#One-dimensional-objective-states","page":"Objective states","title":"One-dimensional objective states","text":"","category":"section"},{"location":"tutorial/objective_states/","page":"Objective states","title":"Objective states","text":"Let's assume that the fuel cost is not fixed, but instead evolves according to a multiplicative auto-regressive process: fuel_cost[t] = ω * fuel_cost[t-1], where ω is drawn from the sample space [0.75, 0.9, 1.1, 1.25] with equal probability.","category":"page"},{"location":"tutorial/objective_states/","page":"Objective states","title":"Objective states","text":"An objective state can be added to a subproblem using the SDDP.add_objective_state function. This can only be called once per subproblem. If you want to add a multi-dimensional objective state, read Multi-dimensional objective states. SDDP.add_objective_state takes a number of keyword arguments. The two required ones are","category":"page"},{"location":"tutorial/objective_states/","page":"Objective states","title":"Objective states","text":"initial_value: the value of the objective state at the root node of the policy graph (i.e., identical to the initial_value when defining normal state variables.\nlipschitz: the Lipschitz constant of the cost-to-go function with respect to the objective state. In other words, this value is the maximum change in the cost-to-go function at any point in the state space, given a one-unit change in the objective state.","category":"page"},{"location":"tutorial/objective_states/","page":"Objective states","title":"Objective states","text":"There are also two optional keyword arguments: lower_bound and upper_bound, which give SDDP.jl hints (importantly, not constraints) about the domain of the objective state. Setting these bounds appropriately can improve the speed of convergence.","category":"page"},{"location":"tutorial/objective_states/","page":"Objective states","title":"Objective states","text":"Finally, SDDP.add_objective_state requires an update function. This function takes two arguments. The first is the incoming value of the objective state, and the second is the realization of the stagewise-independent noise term (set using SDDP.parameterize). The function should return the value of the objective state to be used in the current subproblem.","category":"page"},{"location":"tutorial/objective_states/","page":"Objective states","title":"Objective states","text":"This connection with the stagewise-independent noise term means that SDDP.parameterize must be called in a subproblem that defines an objective state. Inside SDDP.parameterize, the value of the objective state to be used in the current subproblem (i.e., after the update function), can be queried using SDDP.objective_state.","category":"page"},{"location":"tutorial/objective_states/","page":"Objective states","title":"Objective states","text":"Here is the full model with the objective state.","category":"page"},{"location":"tutorial/objective_states/","page":"Objective states","title":"Objective states","text":"using SDDP, HiGHS\n\nmodel = SDDP.LinearPolicyGraph(\n    stages = 3,\n    sense = :Min,\n    lower_bound = 0.0,\n    optimizer = HiGHS.Optimizer,\n) do subproblem, t\n    @variable(subproblem, 0 <= volume <= 200, SDDP.State, initial_value = 200)\n    @variables(subproblem, begin\n        thermal_generation >= 0\n        hydro_generation >= 0\n        hydro_spill >= 0\n        inflow\n    end)\n    @constraints(\n        subproblem,\n        begin\n            volume.out == volume.in + inflow - hydro_generation - hydro_spill\n            demand_constraint, thermal_generation + hydro_generation == 150.0\n        end\n    )\n\n    # Add an objective state. ω will be the same value that is called in\n    # `SDDP.parameterize`.\n\n    SDDP.add_objective_state(\n        subproblem,\n        initial_value = 50.0,\n        lipschitz = 10_000.0,\n        lower_bound = 50.0,\n        upper_bound = 150.0,\n    ) do fuel_cost, ω\n        return ω.fuel * fuel_cost\n    end\n\n    # Create the cartesian product of a multi-dimensional random variable.\n\n    Ω = [\n        (fuel = f, inflow = w) for f in [0.75, 0.9, 1.1, 1.25] for\n        w in [0.0, 50.0, 100.0]\n    ]\n\n    SDDP.parameterize(subproblem, Ω) do ω\n        # Query the current fuel cost.\n        fuel_cost = SDDP.objective_state(subproblem)\n        @stageobjective(subproblem, fuel_cost * thermal_generation)\n        return JuMP.fix(inflow, ω.inflow)\n    end\nend","category":"page"},{"location":"tutorial/objective_states/","page":"Objective states","title":"Objective states","text":"After creating our model, we can train and simulate as usual.","category":"page"},{"location":"tutorial/objective_states/","page":"Objective states","title":"Objective states","text":"SDDP.train(model; run_numerical_stability_report = false)\n\nsimulations = SDDP.simulate(model, 1)\n\nprint(\"Finished training and simulating.\")","category":"page"},{"location":"tutorial/objective_states/","page":"Objective states","title":"Objective states","text":"To demonstrate how the objective states are updated, consider the sequence of noise observations:","category":"page"},{"location":"tutorial/objective_states/","page":"Objective states","title":"Objective states","text":"[stage[:noise_term] for stage in simulations[1]]","category":"page"},{"location":"tutorial/objective_states/","page":"Objective states","title":"Objective states","text":"This, the fuel cost in the first stage should be 0.75 * 50 = 37.5. The fuel cost in the second stage should be 1.1 * 37.5 = 41.25. The fuel cost in the third stage should be 0.75 * 41.25 = 30.9375.","category":"page"},{"location":"tutorial/objective_states/","page":"Objective states","title":"Objective states","text":"To confirm this, the values of the objective state in a simulation can be queried using the :objective_state key.","category":"page"},{"location":"tutorial/objective_states/","page":"Objective states","title":"Objective states","text":"[stage[:objective_state] for stage in simulations[1]]","category":"page"},{"location":"tutorial/objective_states/#Multi-dimensional-objective-states","page":"Objective states","title":"Multi-dimensional objective states","text":"","category":"section"},{"location":"tutorial/objective_states/","page":"Objective states","title":"Objective states","text":"You can construct multi-dimensional price processes using NTuples. Just replace every scalar value associated with the objective state by a tuple. For example, initial_value = 1.0 becomes initial_value = (1.0, 2.0).","category":"page"},{"location":"tutorial/objective_states/","page":"Objective states","title":"Objective states","text":"Here is an example:","category":"page"},{"location":"tutorial/objective_states/","page":"Objective states","title":"Objective states","text":"model = SDDP.LinearPolicyGraph(\n    stages = 3,\n    sense = :Min,\n    lower_bound = 0.0,\n    optimizer = HiGHS.Optimizer,\n) do subproblem, t\n    @variable(subproblem, 0 <= volume <= 200, SDDP.State, initial_value = 200)\n    @variables(subproblem, begin\n        thermal_generation >= 0\n        hydro_generation >= 0\n        hydro_spill >= 0\n        inflow\n    end)\n    @constraints(\n        subproblem,\n        begin\n            volume.out == volume.in + inflow - hydro_generation - hydro_spill\n            demand_constraint, thermal_generation + hydro_generation == 150.0\n        end\n    )\n\n    SDDP.add_objective_state(\n        subproblem,\n        initial_value = (50.0, 50.0),\n        lipschitz = (10_000.0, 10_000.0),\n        lower_bound = (50.0, 50.0),\n        upper_bound = (150.0, 150.0),\n    ) do fuel_cost, ω\n        # fuel_cost is a tuple, containing the (fuel_cost[t-1], fuel_cost[t-2])\n        # This function returns a new tuple containing\n        # (fuel_cost[t], fuel_cost[t-1]). Thus, we need to compute the new\n        # cost:\n        new_cost = fuel_cost[1] + 0.5 * (fuel_cost[1] - fuel_cost[2]) + ω.fuel\n        # And then return the appropriate tuple:\n        return (new_cost, fuel_cost[1])\n    end\n\n    Ω = [\n        (fuel = f, inflow = w) for f in [-10.0, -5.0, 5.0, 10.0] for\n        w in [0.0, 50.0, 100.0]\n    ]\n\n    SDDP.parameterize(subproblem, Ω) do ω\n        fuel_cost, _ = SDDP.objective_state(subproblem)\n        @stageobjective(subproblem, fuel_cost * thermal_generation)\n        return JuMP.fix(inflow, ω.inflow)\n    end\nend\n\nSDDP.train(model; run_numerical_stability_report = false)\n\nsimulations = SDDP.simulate(model, 1)\n\nprint(\"Finished training and simulating.\")","category":"page"},{"location":"tutorial/objective_states/","page":"Objective states","title":"Objective states","text":"This time, since our objective state is two-dimensional, the objective states are tuples with two elements:","category":"page"},{"location":"tutorial/objective_states/","page":"Objective states","title":"Objective states","text":"[stage[:objective_state] for stage in simulations[1]]","category":"page"},{"location":"tutorial/objective_states/#objective_state_warnings","page":"Objective states","title":"Warnings","text":"","category":"section"},{"location":"tutorial/objective_states/","page":"Objective states","title":"Objective states","text":"There are number of things to be aware of when using objective states.","category":"page"},{"location":"tutorial/objective_states/","page":"Objective states","title":"Objective states","text":"The key assumption is that price is independent of the states and actions in the model.\nThat means that the price cannot appear in any @constraints. Nor can you use any @variables in the update function.\nChoosing an appropriate Lipschitz constant is difficult.\nThe points discussed in Choosing an initial bound are relevant. The Lipschitz constant should not be chosen as large as possible (since this will help with convergence and the numerical issues discussed above), but if chosen to small, it may cut of the feasible region and lead to a sub-optimal solution.\nYou need to ensure that the cost-to-go function is concave with respect to the objective state before the update.\nIf the update function is linear, this is always the case. In some situations, the update function can be nonlinear (e.g., multiplicative as we have above). In general, placing constraints on the price (e.g., clamp(price, 0, 1)) will destroy concavity. Caveat emptor. It's up to you if this is a problem. If it isn't you'll get a good heuristic with no guarantee of global optimality.","category":"page"},{"location":"tutorial/objective_states/","page":"Objective states","title":"Objective states","text":"","category":"page"},{"location":"tutorial/objective_states/","page":"Objective states","title":"Objective states","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/air_conditioning_forward/","page":"Training with a different forward model","title":"Training with a different forward model","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/examples/air_conditioning_forward.jl\"","category":"page"},{"location":"examples/air_conditioning_forward/#Training-with-a-different-forward-model","page":"Training with a different forward model","title":"Training with a different forward model","text":"","category":"section"},{"location":"examples/air_conditioning_forward/","page":"Training with a different forward model","title":"Training with a different forward model","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/air_conditioning_forward/","page":"Training with a different forward model","title":"Training with a different forward model","text":"using SDDP\nimport HiGHS\nimport Test\n\nfunction create_air_conditioning_model(; convex::Bool)\n    return SDDP.LinearPolicyGraph(\n        stages = 3,\n        lower_bound = 0.0,\n        optimizer = HiGHS.Optimizer,\n    ) do sp, t\n        @variable(sp, 0 <= x <= 100, SDDP.State, initial_value = 0)\n        @variable(sp, 0 <= u_production <= 200)\n        @variable(sp, u_overtime >= 0)\n        if !convex\n            set_integer(x.out)\n            set_integer(u_production)\n            set_integer(u_overtime)\n        end\n        @constraint(sp, demand, x.in - x.out + u_production + u_overtime == 0)\n        Ω = [[100.0], [100.0, 300.0], [100.0, 300.0]]\n        SDDP.parameterize(ω -> JuMP.set_normalized_rhs(demand, ω), sp, Ω[t])\n        @stageobjective(sp, 100 * u_production + 300 * u_overtime + 50 * x.out)\n    end\nend\n\nconvex = create_air_conditioning_model(; convex = true)\nnon_convex = create_air_conditioning_model(; convex = false)\nSDDP.train(\n    convex;\n    forward_pass = SDDP.AlternativeForwardPass(non_convex),\n    post_iteration_callback = SDDP.AlternativePostIterationCallback(non_convex),\n    iteration_limit = 10,\n)\nTest.@test isapprox(SDDP.calculate_bound(non_convex), 62_500.0, atol = 0.1)\nTest.@test isapprox(SDDP.calculate_bound(convex), 62_500.0, atol = 0.1)","category":"page"},{"location":"examples/air_conditioning_forward/","page":"Training with a different forward model","title":"Training with a different forward model","text":"","category":"page"},{"location":"examples/air_conditioning_forward/","page":"Training with a different forward model","title":"Training with a different forward model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/objective_state_newsvendor/","page":"Newsvendor","title":"Newsvendor","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/examples/objective_state_newsvendor.jl\"","category":"page"},{"location":"examples/objective_state_newsvendor/#Newsvendor","page":"Newsvendor","title":"Newsvendor","text":"","category":"section"},{"location":"examples/objective_state_newsvendor/","page":"Newsvendor","title":"Newsvendor","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/objective_state_newsvendor/","page":"Newsvendor","title":"Newsvendor","text":"This example is based on the classical newsvendor problem, but features an AR(1) spot-price.","category":"page"},{"location":"examples/objective_state_newsvendor/","page":"Newsvendor","title":"Newsvendor","text":"   V(x[t-1], ω[t]) =         max p[t] × u[t]\n                      subject to x[t] = x[t-1] - u[t] + ω[t]\n                                 u[t] ∈ [0, 1]\n                                 x[t] ≥ 0\n                                 p[t] = p[t-1] + ϕ[t]","category":"page"},{"location":"examples/objective_state_newsvendor/","page":"Newsvendor","title":"Newsvendor","text":"The initial conditions are","category":"page"},{"location":"examples/objective_state_newsvendor/","page":"Newsvendor","title":"Newsvendor","text":"x[0] = 2.0\np[0] = 1.5\nω[t] ~ {0, 0.05, 0.10, ..., 0.45, 0.5} with uniform probability.\nϕ[t] ~ {-0.25, -0.125, 0.125, 0.25} with uniform probability.","category":"page"},{"location":"examples/objective_state_newsvendor/","page":"Newsvendor","title":"Newsvendor","text":"using SDDP, HiGHS, Statistics, Test\n\nfunction joint_distribution(; kwargs...)\n    names = tuple([first(kw) for kw in kwargs]...)\n    values = tuple([last(kw) for kw in kwargs]...)\n    output_type = NamedTuple{names,Tuple{eltype.(values)...}}\n    distribution = map(output_type, Base.product(values...))\n    return distribution[:]\nend\n\nfunction newsvendor_example(; cut_type)\n    model = SDDP.PolicyGraph(\n        SDDP.LinearGraph(3),\n        sense = :Max,\n        upper_bound = 50.0,\n        optimizer = HiGHS.Optimizer,\n    ) do subproblem, stage\n        @variables(subproblem, begin\n            x >= 0, (SDDP.State, initial_value = 2)\n            0 <= u <= 1\n            w\n        end)\n        @constraint(subproblem, x.out == x.in - u + w)\n        SDDP.add_objective_state(\n            subproblem,\n            initial_value = 1.5,\n            lower_bound = 0.75,\n            upper_bound = 2.25,\n            lipschitz = 100.0,\n        ) do y, ω\n            return y + ω.price_noise\n        end\n        noise_terms = joint_distribution(\n            demand = 0:0.05:0.5,\n            price_noise = [-0.25, -0.125, 0.125, 0.25],\n        )\n        SDDP.parameterize(subproblem, noise_terms) do ω\n            JuMP.fix(w, ω.demand)\n            price = SDDP.objective_state(subproblem)\n            @stageobjective(subproblem, price * u)\n        end\n    end\n    SDDP.train(\n        model;\n        log_frequency = 10,\n        time_limit = 20.0,\n        cut_type = cut_type,\n    )\n    @test SDDP.calculate_bound(model) ≈ 4.04 atol = 0.05\n    results = SDDP.simulate(model, 500)\n    objectives =\n        [sum(s[:stage_objective] for s in simulation) for simulation in results]\n    @test round(Statistics.mean(objectives); digits = 2) ≈ 4.04 atol = 0.1\n    return\nend\n\nnewsvendor_example(cut_type = SDDP.SINGLE_CUT)\nnewsvendor_example(cut_type = SDDP.MULTI_CUT)","category":"page"},{"location":"examples/objective_state_newsvendor/","page":"Newsvendor","title":"Newsvendor","text":"","category":"page"},{"location":"examples/objective_state_newsvendor/","page":"Newsvendor","title":"Newsvendor","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/tutorial/arma.jl\"","category":"page"},{"location":"tutorial/arma/#Auto-regressive-stochastic-processes","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"","category":"section"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"SDDP.jl assumes that the random variable in each node is independent of the random variables in all other nodes. However, a common request is to model the random variables by some auto-regressive process.","category":"page"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"There are two ways to do this:","category":"page"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"model the random variable as a Markov chain\nuse the \"state-space expansion\" trick","category":"page"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"info: Info\nThis tutorial is in the context of a hydro-thermal scheduling example, but it should be apparent how the ideas transfer to other applications.","category":"page"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"using SDDP\nimport HiGHS","category":"page"},{"location":"tutorial/arma/#state-space-expansion","page":"Auto-regressive stochastic processes","title":"The state-space expansion trick","text":"","category":"section"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"In An introduction to SDDP.jl, we assumed that the inflows were stagewise-independent. However, in many cases this is not correct, and inflow models are more accurately described by an auto-regressive process such as:","category":"page"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"inflow_t = inflow_t-1 + varepsilon","category":"page"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"Here varepsilon is a random variable, and the inflow in stage t is the inflow in stage t-1 plus varepsilon (which might be negative).","category":"page"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"For simplicity, we omit any coefficients and other terms, but this could easily be extended to a model like","category":"page"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"inflow_t = a times inflow_t-1 + b + varepsilon","category":"page"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"In practice, you can estimate a distribution for varepsilon by fitting the chosen statistical model to historical data, and then using the empirical residuals.","category":"page"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"To implement the auto-regressive model in SDDP.jl, we introduce inflow as a state variable.","category":"page"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"tip: Tip\nOur rule of thumb for \"when is something a state variable?\" is: if you need the value of a variable from a previous stage to compute something in stage t, then that variable is a state variable.","category":"page"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"model = SDDP.LinearPolicyGraph(\n    stages = 3,\n    sense = :Min,\n    lower_bound = 0.0,\n    optimizer = HiGHS.Optimizer,\n) do sp, t\n    @variable(sp, 0 <= x <= 200, SDDP.State, initial_value = 200)\n    @variable(sp, g_t >= 0)\n    @variable(sp, g_h >= 0)\n    @variable(sp, s >= 0)\n    @constraint(sp, g_h + g_t == 150)\n    c = [50, 100, 150]\n    @stageobjective(sp, c[t] * g_t)\n    # =========================================================================\n    # New stuff below Here\n    # Add inflow as a state\n    @variable(sp, inflow, SDDP.State, initial_value = 50.0)\n    # Add the random variable as a control variable\n    @variable(sp, ε)\n    # The equation describing our statistical model\n    @constraint(sp, inflow.out == inflow.in + ε)\n    # The new water balance constraint using the state variable\n    @constraint(sp, x.out == x.in - g_h - s + inflow.out)\n    # Assume we have some empirical residuals:\n    Ω = [-10.0, 0.1, 9.6]\n    SDDP.parameterize(sp, Ω) do ω\n        return JuMP.fix(ε, ω)\n    end\nend","category":"page"},{"location":"tutorial/arma/#When-can-this-trick-be-used?","page":"Auto-regressive stochastic processes","title":"When can this trick be used?","text":"","category":"section"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"The state-space expansion trick should be used when:","category":"page"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"The random variable appears additively in the objective or in the constraints. Something like inflow * decision_variable will not work.\nThe statistical model is linear, or can be written using the JuMP @constraint macro.\nThe dimension of the random variable is small (see Vector auto-regressive models for the multi-variate case).","category":"page"},{"location":"tutorial/arma/#The-Markov-chain-approach","page":"Auto-regressive stochastic processes","title":"The Markov chain approach","text":"","category":"section"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"In the Markov chain approach, we model the stochastic process for inflow by a discrete Markov chain. Markov chains are nodes with transition probabilities between the nodes. SDDP.jl has good support for solving problems in which the uncertainty is formulated as a Markov chain.","category":"page"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"The first step of the Markov chain approach is to write a function which simulates the stochastic process. Here is a simulator for our inflow model:","category":"page"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"function simulator()\n    inflow = zeros(3)\n    current = 50.0\n    Ω = [-10.0, 0.1, 9.6]\n    for t in 1:3\n        current += rand(Ω)\n        inflow[t] = current\n    end\n    return inflow\nend","category":"page"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"When called with no arguments, it produces a vector of inflows:","category":"page"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"simulator()","category":"page"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"warning: Warning\nThe simulator must return a Vector{Float64}, so it is limited to a uni-variate random variable. It is possible to do something similar for multi-variate random variable, but you'll have to manually construct the Markov transition matrix, and solution times scale poorly, even in the two-dimensional case.","category":"page"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"The next step is to call SDDP.MarkovianGraph with our simulator. This function will attempt to fit a Markov chain to the stochastic process produced by your simulator. There are two key arguments:","category":"page"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"budget is the total number of nodes we want in the Markov chain\nscenarios is a limit on the number of times we can call simulator","category":"page"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"graph = SDDP.MarkovianGraph(simulator; budget = 8, scenarios = 30)","category":"page"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"Here we can see we have created a MarkovianGraph with nodes like (2, 59.7). The first element of each node is the stage, and the second element is the inflow.","category":"page"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"Create a SDDP.PolicyGraph using graph as follows:","category":"page"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"model = SDDP.PolicyGraph(\n    graph,  # <--- New stuff\n    sense = :Min,\n    lower_bound = 0.0,\n    optimizer = HiGHS.Optimizer,\n) do sp, node\n    t, inflow = node  # <--- New stuff\n    @variable(sp, 0 <= x <= 200, SDDP.State, initial_value = 200)\n    @variable(sp, g_t >= 0)\n    @variable(sp, g_h >= 0)\n    @variable(sp, s >= 0)\n    @constraint(sp, g_h + g_t == 150)\n    c = [50, 100, 150]\n    @stageobjective(sp, c[t] * g_t)\n    # The new water balance constraint using the node:\n    @constraint(sp, x.out == x.in - g_h - s + inflow)\nend","category":"page"},{"location":"tutorial/arma/#When-can-this-trick-be-used?-2","page":"Auto-regressive stochastic processes","title":"When can this trick be used?","text":"","category":"section"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"The Markov chain approach should be used when:","category":"page"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"The random variable is uni-variate\nThe random variable appears in the objective function or as a variable coefficient in the constraint matrix\nIt's non-trivial to write the stochastic process as a series of constraints (for example, it uses nonlinear terms)\nThe number of nodes is modest (for example, a budget of hundreds, up to perhaps 1000)","category":"page"},{"location":"tutorial/arma/#Vector-auto-regressive-models","page":"Auto-regressive stochastic processes","title":"Vector auto-regressive models","text":"","category":"section"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"The state-space expansion section assumed that the random variable was uni-variate. However, the approach naturally extends to vector auto-regressive models. For example, if inflow is a 2-dimensional vector, then we can model a vector auto-regressive model to it as follows:","category":"page"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"inflow_t = A times inflow_t-1 + b + varepsilon","category":"page"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"Here A is a 2-by-2 matrix, and b and varepsilon are 2-by-1 vectors.","category":"page"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"model = SDDP.LinearPolicyGraph(\n    stages = 3,\n    sense = :Min,\n    lower_bound = 0.0,\n    optimizer = HiGHS.Optimizer,\n) do sp, t\n    @variable(sp, 0 <= x <= 200, SDDP.State, initial_value = 200)\n    @variable(sp, g_t >= 0)\n    @variable(sp, g_h >= 0)\n    @variable(sp, s >= 0)\n    @constraint(sp, g_h + g_t == 150)\n    c = [50, 100, 150]\n    @stageobjective(sp, c[t] * g_t)\n    # =========================================================================\n    # New stuff below Here\n    # Add inflow as a state\n    @variable(sp, inflow[1:2], SDDP.State, initial_value = 50.0)\n    # Add the random variable as a control variable\n    @variable(sp, ε[1:2])\n    # The equation describing our statistical model\n    A = [0.8 0.2; 0.2 0.8]\n    @constraint(\n        sp,\n        [i = 1:2],\n        inflow[i].out == sum(A[i, j] * inflow[j].in for j in 1:2) + ε[i],\n    )\n    # The new water balance constraint using the state variable\n    @constraint(sp, x.out == x.in - g_h - s + inflow[1].out + inflow[2].out)\n    # Assume we have some empirical residuals:\n    Ω₁ = [-10.0, 0.1, 9.6]\n    Ω₂ = [-10.0, 0.1, 9.6]\n    Ω = [(ω₁, ω₂) for ω₁ in Ω₁ for ω₂ in Ω₂]\n    SDDP.parameterize(sp, Ω) do ω\n        JuMP.fix(ε[1], ω[1])\n        JuMP.fix(ε[2], ω[2])\n        return\n    end\nend","category":"page"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"","category":"page"},{"location":"tutorial/arma/","page":"Auto-regressive stochastic processes","title":"Auto-regressive stochastic processes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/tutorial/mdps.jl\"","category":"page"},{"location":"tutorial/mdps/#Example:-Markov-Decision-Processes","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"","category":"section"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"SDDP.jl can be used to solve a variety of Markov Decision processes. If the problem has continuous state and control spaces, and the objective and transition function are convex, then SDDP.jl can find a globally optimal policy. In other cases, SDDP.jl will find a locally optimal policy.","category":"page"},{"location":"tutorial/mdps/#A-simple-example","page":"Example: Markov Decision Processes","title":"A simple example","text":"","category":"section"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"A simple demonstration of this is the example taken from page 98 of the book \"Markov Decision Processes: Discrete stochastic Dynamic Programming\", by Martin L. Putterman.","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"The example, as described in Section 4.6.3 of the book, is to minimize a sum of squares of N non-negative variables, subject to a budget constraint that the variable values add up to M. Put mathematically, that is:","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"beginaligned\nmin   sumlimits_i=1^N x_i^2       \nst   sumlimits_i=1^N x_i = M     \n           x_i ge 0 quad i in 1ldotsN\nendaligned","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"The optimal objective value is M^2N, and the optimal solution is x_i = M  N, which can be shown by induction.","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"This can be reformulated as a Markov Decision Process by introducing a state variable, s, which tracks the un-spent budget over N stages.","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"beginaligned\nV_t(s) = min   x^2 + V_t+1(s^prime) \nst   s^prime = s - x \n           x le s \n           x ge 0 \n           s ge 0\nendaligned","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"and in the last stage V_N, there is an additional constraint that s^prime = 0.","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"The budget of M is computed by solving for V_1(M).","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"info: Info\nSince everything here is continuous and convex, SDDP.jl will find the globally optimal policy.","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"If the reformulation from the single problem into the recursive form of the Markov Decision Process is not obvious, consult Putterman's book.","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"We can model and solve this problem using SDDP.jl as follows:","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"using SDDP\nimport Ipopt\n\nM, N = 5, 3\n\nmodel = SDDP.LinearPolicyGraph(\n    stages = N,\n    lower_bound = 0.0,\n    optimizer = Ipopt.Optimizer,\n) do subproblem, node\n    @variable(subproblem, s >= 0, SDDP.State, initial_value = M)\n    @variable(subproblem, x >= 0)\n    @stageobjective(subproblem, x^2)\n    @constraint(subproblem, x <= s.in)\n    @constraint(subproblem, s.out == s.in - x)\n    if node == N\n        fix(s.out, 0.0; force = true)\n    end\n    return\nend\n\nSDDP.train(model)","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"Check that we got the theoretical optimum:","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"SDDP.calculate_bound(model), M^2 / N","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"And check that we found the theoretical value for each x_i:","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"simulations = SDDP.simulate(model, 1, [:x])\nfor data in simulations[1]\n    println(\"x_$(data[:node_index]) = $(data[:x])\")\nend","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"Close enough! We don't get exactly 5/3 because of numerical tolerances within our choice of optimization solver (in this case, Ipopt).","category":"page"},{"location":"tutorial/mdps/#A-more-complicated-policy","page":"Example: Markov Decision Processes","title":"A more complicated policy","text":"","category":"section"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"SDDP.jl is also capable of finding policies for other types of Markov Decision Processes. A classic example of a Markov Decision Process is the problem of finding a path through a maze.","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"Here's one example of a maze. Try changing the parameters to explore different mazes:","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"M, N = 3, 4\ninitial_square = (1, 1)\nreward, illegal_squares, penalties = (3, 4), [(2, 2)], [(3, 1), (2, 4)]\npath = fill(\"⋅\", M, N)\npath[initial_square...] = \"1\"\nfor (k, v) in (illegal_squares => \"▩\", penalties => \"†\", [reward] => \"*\")\n    for (i, j) in k\n        path[i, j] = v\n    end\nend\nprint(join([join(path[i, :], ' ') for i in 1:size(path, 1)], '\\n'))","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"Our goal is to get from square 1 to square *. If we step on a †, we incur a penalty of 1. Squares with ▩ are blocked; we cannot move there.","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"There are a variety of ways that we can solve this problem. We're going to solve it using a stationary binary stochastic programming formulation.","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"Our state variable will be a matrix of binary variables x_ij, where each element is 1 if the agent is in the square and 0 otherwise. In each period, we incur a reward of 1 if we are in the reward square and a penalty of -1 if we are in a penalties square. We cannot move to the illegal_squares, so those x_ij = 0. Feasibility between moves is modelled by constraints of the form:","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"x^prime_ij le sumlimits_(ab)in P x_ab","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"where P is the set of squares from which it is valid to move from (a, b) to (i, j).","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"Because we are looking for a stationary policy, we need a unicyclic graph with a discount factor:","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"discount_factor = 0.9\ngraph = SDDP.UnicyclicGraph(discount_factor)","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"Then we can formulate our full model:","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"import HiGHS\n\nmodel = SDDP.PolicyGraph(\n    graph;\n    sense = :Max,\n    upper_bound = 1 / (1 - discount_factor),\n    optimizer = HiGHS.Optimizer,\n) do sp, _\n    # Our state is a binary variable for each square\n    @variable(\n        sp,\n        x[i = 1:M, j = 1:N],\n        Bin,\n        SDDP.State,\n        initial_value = (i, j) == initial_square,\n    )\n    # Can only be in one square at a time\n    @constraint(sp, sum(x[i, j].out for i in 1:M, j in 1:N) == 1)\n    # Incur rewards and penalties\n    @stageobjective(\n        sp,\n        x[reward...].out - sum(x[i, j].out for (i, j) in penalties)\n    )\n    # Some squares are illegal\n    @constraint(sp, [(i, j) in illegal_squares], x[i, j].out <= 0)\n    # Constraints on valid moves\n    for i in 1:M, j in 1:N\n        moves = [(i - 1, j), (i + 1, j), (i, j), (i, j + 1), (i, j - 1)]\n        filter!(v -> 1 <= v[1] <= M && 1 <= v[2] <= N, moves)\n        @constraint(sp, x[i, j].out <= sum(x[a, b].in for (a, b) in moves))\n    end\n    return\nend","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"The upper bound is obtained by assuming that we reach the reward square in one move and stay there.","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"warning: Warning\nSince there are discrete decisions here, SDDP.jl is not guaranteed to find the globally optimal policy.","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"SDDP.train(model)","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"Simulating a cyclic policy graph requires an explicit sampling_scheme that does not terminate early based on the cycle probability:","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"simulations = SDDP.simulate(\n    model,\n    1,\n    [:x];\n    sampling_scheme = SDDP.InSampleMonteCarlo(\n        max_depth = 5,\n        terminate_on_dummy_leaf = false,\n    ),\n);\n","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"Fill in the path with the time-step in which we visit the square:","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"for (t, data) in enumerate(simulations[1]), i in 1:M, j in 1:N\n    if data[:x][i, j].in > 0.5\n        path[i, j] = \"$t\"\n    end\nend\n\nprint(join([join(path[i, :], ' ') for i in 1:size(path, 1)], '\\n'))","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"tip: Tip\nThis formulation will likely struggle as the number of cells in the maze increases. Can you think of an equivalent formulation that uses fewer state variables?","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"","category":"page"},{"location":"tutorial/mdps/","page":"Example: Markov Decision Processes","title":"Example: Markov Decision Processes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/examples/Hydro_thermal.jl\"","category":"page"},{"location":"examples/Hydro_thermal/#Hydro-thermal-scheduling","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"","category":"section"},{"location":"examples/Hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/Hydro_thermal/#Problem-Description","page":"Hydro-thermal scheduling","title":"Problem Description","text":"","category":"section"},{"location":"examples/Hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"In a hydro-thermal problem, the agent controls a hydro-electric generator and reservoir. Each time period, they need to choose a generation quantity from thermal g_t, and hydro g_h, in order to meet demand w_d, which is a stagewise-independent random variable. The state variable, x, is the quantity of water in the reservoir at the start of each time period, and it has a minimum level of 5 units and a maximum level of 15 units. We assume that there are 10 units of water in the reservoir at the start of time, so that x_0 = 10. The state-variable is connected through time by the water balance constraint: x.out = x.in - g_h - s + w_i, where x.out is the quantity of water at the end of the time period, x.in is the quantity of water at the start of the time period, s is the quantity of water spilled from the reservoir, and w_i is a stagewise-independent random variable that represents the inflow into the reservoir during the time period.","category":"page"},{"location":"examples/Hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"We assume that there are three stages, t=1, 2, 3, representing summer-fall, winter, and spring, and that we are solving this problem in an infinite-horizon setting with a discount factor of 0.95.","category":"page"},{"location":"examples/Hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"In each stage, the agent incurs the cost of spillage, plus the cost of thermal generation. We assume that the cost of thermal generation is dependent on the stage t = 1, 2, 3, and that in each stage, w is drawn from the set (w_i, w_d) = {(0, 7.5), (3, 5), (10, 2.5)} with equal probability.","category":"page"},{"location":"examples/Hydro_thermal/#Importing-packages","page":"Hydro-thermal scheduling","title":"Importing packages","text":"","category":"section"},{"location":"examples/Hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"For this example, in addition to SDDP, we need HiGHS as a solver and Statisitics to compute the mean of our simulations.","category":"page"},{"location":"examples/Hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"using HiGHS\nusing SDDP\nusing Statistics","category":"page"},{"location":"examples/Hydro_thermal/#Constructing-the-policy-graph","page":"Hydro-thermal scheduling","title":"Constructing the policy graph","text":"","category":"section"},{"location":"examples/Hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"There are three stages in our infinite-horizon problem, so we construct a unicyclic policy graph using SDDP.UnicyclicGraph:","category":"page"},{"location":"examples/Hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"graph = SDDP.UnicyclicGraph(0.95; num_nodes = 3)","category":"page"},{"location":"examples/Hydro_thermal/#Constructing-the-model","page":"Hydro-thermal scheduling","title":"Constructing the model","text":"","category":"section"},{"location":"examples/Hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"Much of the macro code (i.e., lines starting with @) in the first part of the following should be familiar to users of JuMP.","category":"page"},{"location":"examples/Hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"Inside the do-end block, sp is a standard JuMP model, and t is an index for the state variable that will be called with t = 1, 2, 3.","category":"page"},{"location":"examples/Hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"The state variable x, constructed by passing the SDDP.State tag to @variable is actually a Julia struct with two fields: x.in and x.out corresponding to the incoming and outgoing state variables respectively. Both x.in and x.out are standard JuMP variables. The initial_value keyword provides the value of the state variable in the root node (i.e., x_0).","category":"page"},{"location":"examples/Hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"Compared to a JuMP model, one key difference is that we use @stageobjective instead of @objective. The SDDP.parameterize function takes a list of supports for w and parameterizes the JuMP model sp by setting the right-hand sides of the appropriate constraints (note how the constraints initially have a right-hand side of 0). By default, it is assumed that the realizations have uniform probability, but a probability mass vector can also be provided.","category":"page"},{"location":"examples/Hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"model = SDDP.PolicyGraph(\n    graph,\n    sense = :Min,\n    lower_bound = 0.0,\n    optimizer = HiGHS.Optimizer,\n) do sp, t\n    @variable(sp, 5 <= x <= 15, SDDP.State, initial_value = 10)\n    @variable(sp, g_t >= 0)\n    @variable(sp, g_h >= 0)\n    @variable(sp, s >= 0)\n    @constraint(sp, balance, x.out - x.in + g_h + s == 0)\n    @constraint(sp, demand, g_h + g_t == 0)\n    @stageobjective(sp, s + t * g_t)\n    SDDP.parameterize(sp, [[0, 7.5], [3, 5], [10, 2.5]]) do w\n        set_normalized_rhs(balance, w[1])\n        return set_normalized_rhs(demand, w[2])\n    end\nend","category":"page"},{"location":"examples/Hydro_thermal/#Training-the-policy","page":"Hydro-thermal scheduling","title":"Training the policy","text":"","category":"section"},{"location":"examples/Hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"Once a model has been constructed, the next step is to train the policy. This can be achieved using SDDP.train. There are many options that can be passed, but iteration_limit terminates the training after the prescribed number of SDDP iterations.","category":"page"},{"location":"examples/Hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"SDDP.train(model, iteration_limit = 100)","category":"page"},{"location":"examples/Hydro_thermal/#Simulating-the-policy","page":"Hydro-thermal scheduling","title":"Simulating the policy","text":"","category":"section"},{"location":"examples/Hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"After training, we can simulate the policy using SDDP.simulate.","category":"page"},{"location":"examples/Hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"sims = SDDP.simulate(model, 100, [:g_t])\nmu = round(mean([s[1][:g_t] for s in sims]), digits = 2)\nprintln(\"On average, $(mu) units of thermal are used in the first stage.\")","category":"page"},{"location":"examples/Hydro_thermal/#Extracting-the-water-values","page":"Hydro-thermal scheduling","title":"Extracting the water values","text":"","category":"section"},{"location":"examples/Hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"Finally, we can use SDDP.ValueFunction and SDDP.evaluate to obtain and evaluate the value function at different points in the state-space. Note that since we are minimizing, the price has a negative sign: each additional unit of water leads to a decrease in the expected long-run cost.","category":"page"},{"location":"examples/Hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"V = SDDP.ValueFunction(model[1])\ncost, price = SDDP.evaluate(V, x = 10)","category":"page"},{"location":"examples/Hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"","category":"page"},{"location":"examples/Hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/hydro_valley/","page":"Hydro valleys","title":"Hydro valleys","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/examples/hydro_valley.jl\"","category":"page"},{"location":"examples/hydro_valley/#Hydro-valleys","page":"Hydro valleys","title":"Hydro valleys","text":"","category":"section"},{"location":"examples/hydro_valley/","page":"Hydro valleys","title":"Hydro valleys","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/hydro_valley/","page":"Hydro valleys","title":"Hydro valleys","text":"This problem is a version of the hydro-thermal scheduling problem. The goal is to operate two hydro-dams in a valley chain over time in the face of inflow and price uncertainty.","category":"page"},{"location":"examples/hydro_valley/","page":"Hydro valleys","title":"Hydro valleys","text":"Turbine response curves are modelled by piecewise linear functions which map the flow rate into a power. These can be controlled by specifying the breakpoints in the piecewise linear function as the knots in the Turbine struct.","category":"page"},{"location":"examples/hydro_valley/","page":"Hydro valleys","title":"Hydro valleys","text":"The model can be created using the hydro_valley_model function. It has a few keyword arguments to allow automated testing of the library. hasstagewiseinflows determines if the RHS noise constraint should be added. hasmarkovprice determines if the price uncertainty (modelled by a Markov chain) should be added.","category":"page"},{"location":"examples/hydro_valley/","page":"Hydro valleys","title":"Hydro valleys","text":"In the third stage, the Markov chain has some unreachable states to test some code-paths in the library.","category":"page"},{"location":"examples/hydro_valley/","page":"Hydro valleys","title":"Hydro valleys","text":"We can also set the sense to :Min or :Max (the objective and bound are flipped appropriately).","category":"page"},{"location":"examples/hydro_valley/","page":"Hydro valleys","title":"Hydro valleys","text":"using SDDP, HiGHS, Test, Random\n\nstruct Turbine\n    flowknots::Vector{Float64}\n    powerknots::Vector{Float64}\nend\n\nstruct Reservoir\n    min::Float64\n    max::Float64\n    initial::Float64\n    turbine::Turbine\n    spill_cost::Float64\n    inflows::Vector{Float64}\nend\n\nfunction hydro_valley_model(;\n    hasstagewiseinflows::Bool = true,\n    hasmarkovprice::Bool = true,\n    sense::Symbol = :Max,\n)\n    valley_chain = [\n        Reservoir(\n            0,\n            200,\n            200,\n            Turbine([50, 60, 70], [55, 65, 70]),\n            1000,\n            [0, 20, 50],\n        ),\n        Reservoir(\n            0,\n            200,\n            200,\n            Turbine([50, 60, 70], [55, 65, 70]),\n            1000,\n            [0, 0, 20],\n        ),\n    ]\n\n    turbine(i) = valley_chain[i].turbine\n\n    # Prices[t, Markov state]\n    prices = [\n        1 2 0\n        2 1 0\n        3 4 0\n    ]\n\n    # Transition matrix\n    if hasmarkovprice\n        transition =\n            Array{Float64,2}[[1.0]', [0.6 0.4], [0.6 0.4 0.0; 0.3 0.7 0.0]]\n    else\n        transition = [ones(Float64, (1, 1)) for t in 1:3]\n    end\n\n    flipobj = (sense == :Max) ? 1.0 : -1.0\n    lower = (sense == :Max) ? -Inf : -1e6\n    upper = (sense == :Max) ? 1e6 : Inf\n\n    N = length(valley_chain)\n\n    # Initialise SDDP Model\n    return m = SDDP.MarkovianPolicyGraph(\n        sense = sense,\n        lower_bound = lower,\n        upper_bound = upper,\n        transition_matrices = transition,\n        optimizer = HiGHS.Optimizer,\n    ) do subproblem, node\n        t, markov_state = node\n\n        # ------------------------------------------------------------------\n        #   SDDP State Variables\n        # Level of upper reservoir\n        @variable(\n            subproblem,\n            valley_chain[r].min <= reservoir[r = 1:N] <= valley_chain[r].max,\n            SDDP.State,\n            initial_value = valley_chain[r].initial\n        )\n\n        # ------------------------------------------------------------------\n        #   Additional variables\n        @variables(\n            subproblem,\n            begin\n                outflow[r = 1:N] >= 0\n                spill[r = 1:N] >= 0\n                inflow[r = 1:N] >= 0\n                generation_quantity >= 0 # Total quantity of water\n                # Proportion of levels to dispatch on\n                0 <=\n                dispatch[r = 1:N, level = 1:length(turbine(r).flowknots)] <=\n                1\n                rainfall[i = 1:N]\n            end\n        )\n\n        # ------------------------------------------------------------------\n        # Constraints\n        @constraints(\n            subproblem,\n            begin\n                # flow from upper reservoir\n                reservoir[1].out ==\n                reservoir[1].in + inflow[1] - outflow[1] - spill[1]\n\n                # other flows\n                flow[i = 2:N],\n                reservoir[i].out ==\n                reservoir[i].in + inflow[i] - outflow[i] - spill[i] +\n                outflow[i-1] +\n                spill[i-1]\n\n                # Total quantity generated\n                generation_quantity == sum(\n                    turbine(r).powerknots[level] * dispatch[r, level] for\n                    r in 1:N for level in 1:length(turbine(r).powerknots)\n                )\n\n                # ------------------------------------------------------------------\n                # Flow out\n                turbineflow[r = 1:N],\n                outflow[r] == sum(\n                    turbine(r).flowknots[level] * dispatch[r, level] for\n                    level in 1:length(turbine(r).flowknots)\n                )\n\n                # Dispatch combination of levels\n                dispatched[r = 1:N],\n                sum(\n                    dispatch[r, level] for\n                    level in 1:length(turbine(r).flowknots)\n                ) <= 1\n            end\n        )\n\n        # rainfall noises\n        if hasstagewiseinflows && t > 1 # in future stages random inflows\n            @constraint(subproblem, inflow_noise[i = 1:N], inflow[i] <= rainfall[i])\n\n            SDDP.parameterize(\n                subproblem,\n                [\n                    (valley_chain[1].inflows[i], valley_chain[2].inflows[i]) for i in 1:length(transition)\n                ],\n            ) do ω\n                for i in 1:N\n                    JuMP.fix(rainfall[i], ω[i])\n                end\n            end\n        else # in the first stage deterministic inflow\n            @constraint(\n                subproblem,\n                initial_inflow_noise[i = 1:N],\n                inflow[i] <= valley_chain[i].inflows[1]\n            )\n        end\n\n        # ------------------------------------------------------------------\n        #   Objective Function\n        if hasmarkovprice\n            @stageobjective(\n                subproblem,\n                flipobj * (\n                    prices[t, markov_state] * generation_quantity -\n                    sum(valley_chain[i].spill_cost * spill[i] for i in 1:N)\n                )\n            )\n        else\n            @stageobjective(\n                subproblem,\n                flipobj * (\n                    prices[t, 1] * generation_quantity -\n                    sum(valley_chain[i].spill_cost * spill[i] for i in 1:N)\n                )\n            )\n        end\n    end\nend\n\nfunction test_hydro_valley_model()\n\n    # For repeatability\n    Random.seed!(11111)\n\n    # deterministic\n    deterministic_model =\n        hydro_valley_model(hasmarkovprice = false, hasstagewiseinflows = false)\n    SDDP.train(\n        deterministic_model,\n        iteration_limit = 10,\n        cut_deletion_minimum = 1,\n        print_level = 0,\n    )\n    @test SDDP.calculate_bound(deterministic_model) ≈ 835.0 atol = 1e-3\n\n    # stagewise inflows\n    stagewise_model = hydro_valley_model(hasmarkovprice = false)\n    SDDP.train(stagewise_model, iteration_limit = 20, print_level = 0)\n    @test SDDP.calculate_bound(stagewise_model) ≈ 838.33 atol = 1e-2\n\n    # Markov prices\n    markov_model = hydro_valley_model(hasstagewiseinflows = false)\n    SDDP.train(markov_model, iteration_limit = 10, print_level = 0)\n    @test SDDP.calculate_bound(markov_model) ≈ 851.8 atol = 1e-2\n\n    # stagewise inflows and Markov prices\n    markov_stagewise_model =\n        hydro_valley_model(hasstagewiseinflows = true, hasmarkovprice = true)\n    SDDP.train(markov_stagewise_model, iteration_limit = 10, print_level = 0)\n    @test SDDP.calculate_bound(markov_stagewise_model) ≈ 855.0 atol = 1.0\n\n    # risk averse stagewise inflows and Markov prices\n    riskaverse_model = hydro_valley_model()\n    SDDP.train(\n        riskaverse_model,\n        risk_measure = SDDP.EAVaR(lambda = 0.5, beta = 0.66),\n        iteration_limit = 10,\n        print_level = 0,\n    )\n    @test SDDP.calculate_bound(riskaverse_model) ≈ 828.157 atol = 1.0\n\n    # stagewise inflows and Markov prices\n    worst_case_model = hydro_valley_model(sense = :Min)\n    SDDP.train(\n        worst_case_model,\n        risk_measure = SDDP.EAVaR(lambda = 0.5, beta = 0.0),\n        iteration_limit = 10,\n        print_level = 0,\n    )\n    @test SDDP.calculate_bound(worst_case_model) ≈ -780.867 atol = 1.0\n\n    # stagewise inflows and Markov prices\n    cutselection_model = hydro_valley_model()\n    SDDP.train(\n        cutselection_model,\n        iteration_limit = 10,\n        print_level = 0,\n        cut_deletion_minimum = 2,\n    )\n    @test SDDP.calculate_bound(cutselection_model) ≈ 855.0 atol = 1.0\n\n    # Distributionally robust Optimization\n    dro_model = hydro_valley_model(hasmarkovprice = false)\n    SDDP.train(\n        dro_model,\n        risk_measure = SDDP.ModifiedChiSquared(sqrt(2 / 3) - 1e-6),\n        iteration_limit = 10,\n        print_level = 0,\n    )\n    @test SDDP.calculate_bound(dro_model) ≈ 835.0 atol = 1.0\n\n    dro_model = hydro_valley_model(hasmarkovprice = false)\n    SDDP.train(\n        dro_model,\n        risk_measure = SDDP.ModifiedChiSquared(1 / 6),\n        iteration_limit = 20,\n        print_level = 0,\n    )\n    @test SDDP.calculate_bound(dro_model) ≈ 836.695 atol = 1.0\n    # (Note) radius ≈ sqrt(2/3), will set all noise probabilities to zero except the worst case noise\n    # (Why?):\n    # The distance from the uniform distribution (the assumed \"true\" distribution)\n    # to a corner of a unit simplex is sqrt(S-1)/sqrt(S) if we have S scenarios. The corner\n    # of a unit simplex is just a unit vector, i.e.: [0 ... 0 1 0 ... 0]. With this probability\n    # vector, only one noise has a non-zero probablity.\n    # In the worst case rhsnoise (0 inflows) the profit is:\n    #  Reservoir1: 70 * $3 + 70 * $2 + 65 * $1 +\n    #  Reservoir2: 70 * $3 + 70 * $2 + 70 * $1\n    ###  = $835\nend\n\ntest_hydro_valley_model()","category":"page"},{"location":"examples/hydro_valley/","page":"Hydro valleys","title":"Hydro valleys","text":"","category":"page"},{"location":"examples/hydro_valley/","page":"Hydro valleys","title":"Hydro valleys","text":"This page was generated using Literate.jl.","category":"page"},{"location":"guides/add_noise_in_the_constraint_matrix/#Add-noise-in-the-constraint-matrix","page":"Add noise in the constraint matrix","title":"Add noise in the constraint matrix","text":"","category":"section"},{"location":"guides/add_noise_in_the_constraint_matrix/","page":"Add noise in the constraint matrix","title":"Add noise in the constraint matrix","text":"DocTestSetup = quote\n    using SDDP, HiGHS\nend","category":"page"},{"location":"guides/add_noise_in_the_constraint_matrix/","page":"Add noise in the constraint matrix","title":"Add noise in the constraint matrix","text":"SDDP.jl supports coefficients in the constraint matrix through the JuMP.set_normalized_coefficient function.","category":"page"},{"location":"guides/add_noise_in_the_constraint_matrix/","page":"Add noise in the constraint matrix","title":"Add noise in the constraint matrix","text":"julia> model = SDDP.LinearPolicyGraph(\n               stages=3, lower_bound = 0, optimizer = HiGHS.Optimizer\n               ) do subproblem, t\n           @variable(subproblem, x, SDDP.State, initial_value = 0.0)\n           @constraint(subproblem, emissions, 1x.out <= 1)\n           SDDP.parameterize(subproblem, [0.2, 0.5, 1.0]) do ω\n               JuMP.set_normalized_coefficient(emissions, x.out, ω)\n               println(emissions)\n           end\n           @stageobjective(subproblem, -x.out)\n       end\nA policy graph with 3 nodes.\n Node indices: 1, 2, 3\n\njulia> SDDP.simulate(model, 1);\nemissions : x_out <= 1\nemissions : 0.2 x_out <= 1\nemissions : 0.5 x_out <= 1","category":"page"},{"location":"guides/add_noise_in_the_constraint_matrix/","page":"Add noise in the constraint matrix","title":"Add noise in the constraint matrix","text":"note: Note\nJuMP will normalize constraints by moving all variables to the left-hand side. Thus, @constraint(model, 0 <= 1 - x.out) becomes x.out <= 1. JuMP.set_normalized_coefficient sets the coefficient on the normalized constraint.","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/explanation/risk.jl\"","category":"page"},{"location":"explanation/risk/#Risk-aversion","page":"Risk aversion","title":"Risk aversion","text":"","category":"section"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"(Image: ) (Image: )","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"In Introductory theory, we implemented a basic version of the SDDP algorithm. This tutorial extends that implementation to add risk-aversion.","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"Packages","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"This tutorial uses the following packages. For clarity, we call import PackageName so that we must prefix PackageName. to all functions and structs provided by that package. Everything not prefixed is either part of base Julia, or we wrote it.","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"import ForwardDiff\nimport HiGHS\nimport Ipopt\nimport JuMP\nimport Statistics","category":"page"},{"location":"explanation/risk/#Risk-aversion:-what-and-why?","page":"Risk aversion","title":"Risk aversion: what and why?","text":"","category":"section"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"Often, the agents making decisions in complex systems are risk-averse, that is, they care more about avoiding very bad outcomes, than they do about having a good average outcome.","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"As an example, consumers in a hydro-thermal problem may be willing to pay a slightly higher electricity price on average, if it means that there is a lower probability of blackouts.","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"Risk aversion in multistage stochastic programming has been well studied in the academic literature, and is widely used in production implementations around the world.","category":"page"},{"location":"explanation/risk/#Risk-measures","page":"Risk aversion","title":"Risk measures","text":"","category":"section"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"One way to add risk aversion to models is to use a risk measure. A risk measure is a function that maps a random variable to a real number.","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"You are probably already familiar with lots of different risk measures. For example, the mean, median, mode, and maximum are all risk measures.","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"We call the act of applying a risk measure to a random variable \"computing the risk\" of a random variable.","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"To keep things simple, and because we need it for SDDP, we restrict our attention to random variables Z with a finite sample space Omega and positive probabilities p_omega for all omega in Omega. We denote the realizations of Z by Z(omega) = z_omega.","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"A risk measure, mathbbFZ, is a convex risk measure if it satisfies the following axioms:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"Axiom 1: monotonicity","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"Given two random variables Z_1 and Z_2, with Z_1 le Z_2 almost surely, then mathbbFZ_1 le FZ_2.","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"Axiom 2: translation equivariance","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"Given two random variables Z_1 and Z_2, then for all a in mathbbR, mathbbFZ + a = mathbbFZ + a.","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"Axiom 3: convexity","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"Given two random variables Z_1 and Z_2, then for all a in 0 1,","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"mathbbFa Z_1 + (1 - a) Z_2 le a mathbbFZ_1 + (1-a)mathbbFZ_2","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"Now we know what a risk measure is, let's see how we can use them to form risk-averse decision rules.","category":"page"},{"location":"explanation/risk/#Risk-averse-decision-rules:-Part-I","page":"Risk aversion","title":"Risk-averse decision rules: Part I","text":"","category":"section"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"We started this tutorial by explaining that we are interested in risk aversion because some agents are risk-averse. What that really means, is that they want a policy that is also risk-averse. The question then becomes, how do we create risk-averse decision rules and policies?","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"Recall from Introductory theory that we can form an optimal decision rule using the recursive formulation:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"beginaligned\nV_i(x omega) = minlimits_barx x^prime u   C_i(barx u omega) + mathbbE_j in i^+ varphi in Omega_jV_j(x^prime varphi)\n x^prime = T_i(barx u omega) \n u in U_i(barx omega) \n barx = x\nendaligned","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"where our decision rule, pi_i(x omega), solves this optimization problem and returns a u^* corresponding to an optimal solution.","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"If we can replace the expectation operator mathbbE with another (more risk-averse) risk measure mathbbF, then our decision rule will attempt to choose a control decision now that minimizes the risk of the future costs, as opposed to the expectation of the future costs. This makes our decisions more risk-averse, because we care more about the worst outcomes than we do about the average.","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"Therefore, we can form a risk-averse decision rule using the formulation:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"beginaligned\nV_i(x omega) = minlimits_barx x^prime u   C_i(barx u omega) + mathbbF_j in i^+ varphi in Omega_jV_j(x^prime varphi)\n x^prime = T_i(barx u omega) \n u in U_i(barx omega) \n barx = x\nendaligned","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"To convert this problem into a tractable equivalent, we apply Kelley's algorithm to the risk-averse cost-to-go term mathbbF_j in i^+ varphi in Omega_jV_j(x^prime varphi), to obtain the approximated problem:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"beginaligned\nV_i^K(x omega) = minlimits_barx x^prime u   C_i(barx u omega) + theta\n x^prime = T_i(barx u omega) \n u in U_i(barx omega) \n barx = x \n theta ge mathbbF_j in i^+ varphi in Omega_jleftV_j^k(x^prime_k varphi)right + fracddx^primemathbbF_j in i^+ varphi in Omega_jleftV_j^k(x^prime_k varphi)right^top (x^prime - x^prime_k)quad k=1ldotsK\nendaligned","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"warning: Warning\nNote how we need to explicitly compute a risk-averse subgradient! (We need a subgradient because the function might not be differentiable.) When constructing cuts with the expectation operator in Introductory theory, we implicitly used the law of total expectation to combine the two expectations; we can't do that for a general risk measure.","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"tip: Homework challenge\nIf it's not obvious why we can use Kelley's here, try to use the axioms of a convex risk measure to show that mathbbF_j in i^+ varphi in Omega_jV_j(x^prime varphi) is a convex function w.r.t. x^prime if V_j is also a convex function.","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"Our challenge is now to find a way to compute the risk-averse cost-to-go function mathbbF_j in i^+ varphi in Omega_jleftV_j^k(x^prime_k varphi)right, and a way to compute a subgradient of the risk-averse cost-to-go function with respect to x^prime.","category":"page"},{"location":"explanation/risk/#Primal-risk-measures","page":"Risk aversion","title":"Primal risk measures","text":"","category":"section"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"Now we know what a risk measure is, and how we will use it, let's implement some code to see how we can compute the risk of some random variables.","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"note: Note\nWe're going to start by implementing the primal version of each risk measure. We implement the dual version in the next section.","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"First, we need some data:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"Z = [1.0, 2.0, 3.0, 4.0]","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"with probabilities:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"p = [0.1, 0.2, 0.4, 0.3]","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"We're going to implement a number of different risk measures, so to leverage Julia's multiple dispatch, we create an abstract type:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"abstract type AbstractRiskMeasure end","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"and function to overload:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"\"\"\"\n    primal_risk(F::AbstractRiskMeasure, Z::Vector{<:Real}, p::Vector{Float64})\n\nUse `F` to compute the risk of the random variable defined by a vector of costs\n`Z` and non-zero probabilities `p`.\n\"\"\"\nfunction primal_risk end","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"note: Note\nWe want Vector{<:Real} instead of Vector{Float64} because we're going to automatically differentiate this function in the next section.","category":"page"},{"location":"explanation/risk/#Expectation","page":"Risk aversion","title":"Expectation","text":"","category":"section"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"The expectation, mathbbE, also called the mean or the average, is the most widely used convex risk measure. The expectation of a random variable is just the sum of Z weighted by the probability:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"mathbbFZ = mathbbE_pZ = sumlimits_omegainOmega p_omega z_omega","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"struct Expectation <: AbstractRiskMeasure end\n\nfunction primal_risk(::Expectation, Z::Vector{<:Real}, p::Vector{Float64})\n    return sum(p[i] * Z[i] for i in 1:length(p))\nend","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"Let's try it out:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"primal_risk(Expectation(), Z, p)","category":"page"},{"location":"explanation/risk/#WorstCase","page":"Risk aversion","title":"WorstCase","text":"","category":"section"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"The worst-case risk measure, also called the maximum, is another widely used convex risk measure. This risk measure doesn't care about the probability vector p, only the cost vector Z:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"mathbbFZ = maxZ = maxlimits_omegainOmega z_omega","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"struct WorstCase <: AbstractRiskMeasure end\n\nfunction primal_risk(::WorstCase, Z::Vector{<:Real}, ::Vector{Float64})\n    return maximum(Z)\nend","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"Let's try it out:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"primal_risk(WorstCase(), Z, p)","category":"page"},{"location":"explanation/risk/#Entropic","page":"Risk aversion","title":"Entropic","text":"","category":"section"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"A more interesting, and less widely used risk measure is the entropic risk measure. The entropic risk measure is parameterized by a value gamma  0, and computes the risk of a random variable as:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"mathbbF_gammaZ = frac1gammalogleft(mathbbE_pe^gamma Zright) = frac1gammalogleft(sumlimits_omegainOmegap_omega e^gamma z_omegaright)","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"tip: Homework challenge\nProve that the entropic risk measure satisfies the three axioms of a convex risk measure.","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"struct Entropic <: AbstractRiskMeasure\n    γ::Float64\n    function Entropic(γ)\n        if !(γ > 0)\n            throw(DomainError(γ, \"Entropic risk measure must have γ > 0.\"))\n        end\n        return new(γ)\n    end\nend\n\nfunction primal_risk(F::Entropic, Z::Vector{<:Real}, p::Vector{Float64})\n    return 1 / F.γ * log(sum(p[i] * exp(F.γ * Z[i]) for i in 1:length(p)))\nend","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"warning: Warning\nexp(x) overflows when x  709. Therefore, if we are passed a vector of Float64, use arbitrary precision arithmetic with big.(Z).","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"function primal_risk(F::Entropic, Z::Vector{Float64}, p::Vector{Float64})\n    return Float64(primal_risk(F, big.(Z), p))\nend","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"Let's try it out for different values of gamma:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"for γ in [0.001, 0.01, 0.1, 1.0, 10.0, 100.0, 1_000.0]\n    println(\"γ = $(γ), F[Z] = \", primal_risk(Entropic(γ), Z, p))\nend","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"info: Info\nThe entropic has two extremes. As gamma rightarrow 0, the entropic acts like the expectation risk measure, and as gamma rightarrow infty, the entropic acts like the worst-case risk measure.","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"Computing risk measures this way works well for computing the primal value. However, there isn't an obvious way to compute a subgradient of the risk-averse cost-to-go function, which we need for our cut calculation.","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"There is a nice solution to this problem, and that is to use the dual representation of a risk measure, instead of the primal.","category":"page"},{"location":"explanation/risk/#Dual-risk-measures","page":"Risk aversion","title":"Dual risk measures","text":"","category":"section"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"Convex risk measures have a dual representation as follows:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"mathbbFZ = suplimits_q inmathcalM(p) mathbbE_qZ - alpha(p q)","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"where alpha is a concave function that maps the probability vectors p and q to a real number, and mathcalM(p) subseteq mathcalP is a convex subset of the probability simplex:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"mathcalP = p ge 0sumlimits_omegainOmegap_omega = 1","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"The dual of a convex risk measure can be interpreted as taking the expectation of the random variable Z with respect to the worst probability vector q that lies within the set mathcalM, less some concave penalty term alpha(p q).","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"If we define a function dual_risk_inner that computes q and α:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"\"\"\"\n    dual_risk_inner(\n        F::AbstractRiskMeasure, Z::Vector{Float64}, p::Vector{Float64}\n    )::Tuple{Vector{Float64},Float64}\n\nReturn a tuple formed by the worst-case probability vector `q` and the\ncorresponding evaluation `α(p, q)`.\n\"\"\"\nfunction dual_risk_inner end","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"then we can write a generic dual_risk function as:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"function dual_risk(\n    F::AbstractRiskMeasure,\n    Z::Vector{Float64},\n    p::Vector{Float64},\n)\n    q, α = dual_risk_inner(F, Z, p)\n    return sum(q[i] * Z[i] for i in 1:length(q)) - α\nend","category":"page"},{"location":"explanation/risk/#Expectation-2","page":"Risk aversion","title":"Expectation","text":"","category":"section"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"For the expectation risk measure, mathcalM(p) = p, and alpha(cdot cdot) = 0. Therefore:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"function dual_risk_inner(::Expectation, ::Vector{Float64}, p::Vector{Float64})\n    return p, 0.0\nend","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"We can check we get the same result as the primal version:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"dual_risk(Expectation(), Z, p) == primal_risk(Expectation(), Z, p)","category":"page"},{"location":"explanation/risk/#Worst-case","page":"Risk aversion","title":"Worst-case","text":"","category":"section"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"For the worst-case risk measure, mathcalM(p) = mathcalP, and alpha(cdot cdot) = 0. Therefore, the dual representation just puts all of the probability weight on the maximum outcome:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"function dual_risk_inner(::WorstCase, Z::Vector{Float64}, ::Vector{Float64})\n    q = zeros(length(Z))\n    _, index = findmax(Z)\n    q[index] = 1.0\n    return q, 0.0\nend","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"We can check we get the same result as the primal version:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"dual_risk(WorstCase(), Z, p) == primal_risk(WorstCase(), Z, p)","category":"page"},{"location":"explanation/risk/#Entropic-2","page":"Risk aversion","title":"Entropic","text":"","category":"section"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"For the entropic risk measure, mathcalM(p) = mathcalP, and:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"alpha(p q) = frac1gammasumlimits_omegainOmega q_omega logleft(fracq_omegap_omegaright)","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"One way to solve the dual problem is to explicitly solve a nonlinear optimization problem:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"function dual_risk_inner(F::Entropic, Z::Vector{Float64}, p::Vector{Float64})\n    N = length(p)\n    model = JuMP.Model(Ipopt.Optimizer)\n    JuMP.set_silent(model)\n    # For this problem, the solve is more accurate if we turn off problem\n    # scaling.\n    JuMP.set_optimizer_attribute(model, \"nlp_scaling_method\", \"none\")\n    JuMP.@variable(model, 0 <= q[1:N] <= 1)\n    JuMP.@constraint(model, sum(q) == 1)\n    JuMP.@NLexpression(\n        model,\n        α,\n        1 / F.γ * sum(q[i] * log(q[i] / p[i]) for i in 1:N),\n    )\n    JuMP.@NLobjective(model, Max, sum(q[i] * Z[i] for i in 1:N) - α)\n    JuMP.optimize!(model)\n    return JuMP.value.(q), JuMP.value(α)\nend","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"We can check we get the same result as the primal version:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"for γ in [0.001, 0.01, 0.1, 1.0, 10.0, 100.0]\n    primal = primal_risk(Entropic(γ), Z, p)\n    dual = dual_risk(Entropic(γ), Z, p)\n    success = primal ≈ dual ? \"✓\" : \"×\"\n    println(\"$(success) γ = $(γ), primal = $(primal), dual = $(dual)\")\nend","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"info: Info\nThis method of solving the dual problem \"on-the-side\" is used by SDDP.jl for a number of risk measures, including a distributionally robust risk measure with the Wasserstein distance. Check out all the risk measures that SDDP.jl supports in Add a risk measure.","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"The \"on-the-side\" method is very general, and it lets us incorporate any convex risk measure into SDDP. However, this comes at an increased computational cost and potential numerical issues (e.g., not converging to the exact solution).","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"However, for the entropic risk measure, Dowson, Morton, and Pagnoncelli (2020) derive the following closed form solution for q^*:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"q_omega^* = fracp_omega e^gamma z_omegasumlimits_varphi in Omega p_varphi e^gamma z_varphi","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"This is faster because we don't need to use Ipopt, and it avoids some of the numerical issues associated with solving a nonlinear program.","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"function dual_risk_inner(F::Entropic, Z::Vector{Float64}, p::Vector{Float64})\n    q, α = zeros(length(p)), big(0.0)\n    peγz = p .* exp.(F.γ .* big.(Z))\n    sum_peγz = sum(peγz)\n    for i in 1:length(q)\n        big_q = peγz[i] / sum_peγz\n        α += big_q * log(big_q / p[i])\n        q[i] = Float64(big_q)\n    end\n    return q, Float64(α / F.γ)\nend","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"warning: Warning\nAgain, note that we use big to avoid introducing overflow errors, before explicitly casting back to Float64 for the values we return.","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"We can check we get the same result as the primal version:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"for γ in [0.001, 0.01, 0.1, 1.0, 10.0, 100.0]\n    primal = primal_risk(Entropic(γ), Z, p)\n    dual = dual_risk(Entropic(γ), Z, p)\n    success = primal ≈ dual ? \"✓\" : \"×\"\n    println(\"$(success) γ = $(γ), primal = $(primal), dual = $(dual)\")\nend","category":"page"},{"location":"explanation/risk/#Risk-averse-subgradients","page":"Risk aversion","title":"Risk-averse subgradients","text":"","category":"section"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"We ended the section on primal risk measures by explaining how we couldn't use the primal risk measure in the cut calculation because we needed some way of computing a risk-averse subgradient:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"theta ge mathbbF_j in i^+ varphi in Omega_jleftV_j^k(x^prime_k varphi)right + fracddx^primemathbbF_j in i^+ varphi in Omega_jleftV_j^k(x^prime_k varphi)right^top (x^prime - x^prime_k)","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"The reason we use the dual representation is because of the following theorem, which explains how to compute a risk-averse gradient.","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"info: The risk-averse subgradient theorem\nLet omega in Omega index a random vector with finite support and with nominal probability mass function, p in mathcalP, which satisfies p  0.Consider a convex risk measure, mathbbF, with a convex risk set, mathcalM(p), so that mathbbF can be expressed as the dual form.Let V(xomega) be convex with respect to x for all fixed omegainOmega, and let lambda(tildex omega) be a subgradient of V(xomega) with respect to x at x = tildex for each omega in Omega.Then, sum_omegainOmegaq^*_omega lambda(tildexomega) is a subgradient of mathbbFV(xomega) at tildex, whereq^* in argmax_q in mathcalM(p)leftmathbbE_qV(tildexomega) - alpha(p q)right","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"This theorem can be a little hard to unpack, so let's see an example:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"function dual_risk_averse_subgradient(\n    V::Function,\n    # Use automatic differentiation to compute the gradient of V w.r.t. x,\n    # given a fixed ω.\n    λ::Function = (x, ω) -> ForwardDiff.gradient(x -> V(x, ω), x);\n    F::AbstractRiskMeasure,\n    Ω::Vector,\n    p::Vector{Float64},\n    x̃::Vector{Float64},\n)\n    # Evaluate the function at x=x̃ for all ω ∈ Ω.\n    V_ω = [V(x̃, ω) for ω in Ω]\n    # Solve the dual problem to obtain an optimal q^*.\n    q, α = dual_risk_inner(F, V_ω, p)\n    # Compute the risk-averse subgradient by taking the expectation of the\n    # subgradients w.r.t. q^*.\n    dVdx = sum(q[i] * λ(x̃, ω) for (i, ω) in enumerate(Ω))\n    return dVdx\nend","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"We can compare the subgradient obtained with the dual form against the automatic differentiation of the primal_risk function.","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"function primal_risk_averse_subgradient(\n    V::Function;\n    F::AbstractRiskMeasure,\n    Ω::Vector,\n    p::Vector{Float64},\n    x̃::Vector{Float64},\n)\n    inner(x) = primal_risk(F, [V(x, ω) for ω in Ω], p)\n    return ForwardDiff.gradient(inner, x̃)\nend","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"As our example function, we use:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"V(x, ω) = ω * x[1]^2","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"with:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"Ω = [1.0, 2.0, 3.0]","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"and:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"p = [0.3, 0.4, 0.3]","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"at the point:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"x̃ = [3.0]","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"If mathbbF is the expectation risk-measure, then:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"mathbbFV(x omega) =  2 x^2","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"The function evaluation x=3 is 18 and the subgradient is 12. Let's check we get it right with the dual form:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"dual_risk_averse_subgradient(V; F = Expectation(), Ω = Ω, p = p, x̃ = x̃)","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"and the primal form:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"primal_risk_averse_subgradient(V; F = Expectation(), Ω = Ω, p = p, x̃ = x̃)","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"If mathbbF is the worst-case risk measure, then:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"mathbbFV(x omega) = 3 x^2","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"The function evaluation at x=3 is 27, and the subgradient is 18. Let's check we get it right with the dual form:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"dual_risk_averse_subgradient(V; F = WorstCase(), Ω = Ω, p = p, x̃ = x̃)","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"and the primal form:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"primal_risk_averse_subgradient(V; F = WorstCase(), Ω = Ω, p = p, x̃ = x̃)","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"If mathbbF is the entropic risk measure, the math is a little more difficult to derive analytically. However, we can check against our primal version:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"for γ in [0.001, 0.01, 0.1, 1.0, 10.0, 100.0]\n    dual =\n        dual_risk_averse_subgradient(V; F = Entropic(γ), Ω = Ω, p = p, x̃ = x̃)\n    primal = primal_risk_averse_subgradient(\n        V;\n        F = Entropic(γ),\n        Ω = Ω,\n        p = p,\n        x̃ = x̃,\n    )\n    success = primal ≈ dual ? \"✓\" : \"×\"\n    println(\"$(success) γ = $(γ), primal = $(primal), dual = $(dual)\")\nend","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"Uh oh! What happened with the last line? It looks our primal_risk_averse_subgradient encountered an error and returned a subgradient of NaN. This is because of the overflow issue with exp(x). However, we can be confident that our dual method of computing the risk-averse subgradient is both correct and more numerically robust than the primal version.","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"info: Info\nAs another sanity check, notice how as gamma rightarrow 0, we tend toward the solution of the expectation risk-measure [12], and as gamma rightarrow infty, we tend toward the solution of the worse-case risk measure [18].","category":"page"},{"location":"explanation/risk/#Risk-averse-decision-rules:-Part-II","page":"Risk aversion","title":"Risk-averse decision rules: Part II","text":"","category":"section"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"Why is the risk-averse subgradient theorem helpful? Using the dual representation of a convex risk measure, we can re-write the cut:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"theta ge mathbbF_j in i^+ varphi in Omega_jleftV_j^k(x^prime_k varphi)right + fracddx^primemathbbF_j in i^+ varphi in Omega_jleftV_j^k(x^prime_k varphi)right^top (x^prime - x^prime_k)quad k=1ldotsK","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"as:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"theta ge mathbbE_q_kleftV_j^k(x^prime_k varphi) + fracddx^primeV_j^k(x^prime_k varphi)^top (x^prime - x^prime_k)right - alpha(p q_k)quad k=1ldotsK","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"where q_k = mathrmargsuplimits_q inmathcalM(p) mathbbE_qV_j^k(x_k^prime varphi) - alpha(p q).","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"Therefore, we can formulate a risk-averse decision rule as:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"beginaligned\nV_i^K(x omega) = minlimits_barx x^prime u   C_i(barx u omega) + theta\n x^prime = T_i(barx u omega) \n u in U_i(barx omega) \n barx = x \n theta ge mathbbE_q_kleftV_j^k(x^prime_k varphi) + fracddx^primeV_j^k(x^prime_k varphi)^top (x^prime - x^prime_k)right - alpha(p q_k)quad k=1ldotsK \n theta ge M\nendaligned","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"where q_k = mathrmargsuplimits_q inmathcalM(p) mathbbE_qV_j^k(x_k^prime varphi) - alpha(p q).","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"Thus, to implement risk-averse SDDP, all we need to do is modify the backward pass to include this calculation of q_k, form the cut using q_k instead of p, and subtract the penalty term alpha(p q_k).","category":"page"},{"location":"explanation/risk/#Implementation","page":"Risk aversion","title":"Implementation","text":"","category":"section"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"Now we're ready to implement our risk-averse version of SDDP.","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"As a prerequisite, we need most of the code from Introductory theory.","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"<p><details>\n<summary>Click to view code from the tutorial \"Introductory theory\".</summary>","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"struct State\n    in::JuMP.VariableRef\n    out::JuMP.VariableRef\nend\n\nstruct Uncertainty\n    parameterize::Function\n    Ω::Vector{Any}\n    P::Vector{Float64}\nend\n\nstruct Node\n    subproblem::JuMP.Model\n    states::Dict{Symbol,State}\n    uncertainty::Uncertainty\n    cost_to_go::JuMP.VariableRef\nend\n\nstruct PolicyGraph\n    nodes::Vector{Node}\n    arcs::Vector{Dict{Int,Float64}}\nend\n\nfunction Base.show(io::IO, model::PolicyGraph)\n    println(io, \"A policy graph with $(length(model.nodes)) nodes\")\n    println(io, \"Arcs:\")\n    for (from, arcs) in enumerate(model.arcs)\n        for (to, probability) in arcs\n            println(io, \"  $(from) => $(to) w.p. $(probability)\")\n        end\n    end\n    return\nend\n\nfunction PolicyGraph(\n    subproblem_builder::Function;\n    graph::Vector{Dict{Int,Float64}},\n    lower_bound::Float64,\n    optimizer,\n)\n    nodes = Node[]\n    for t in 1:length(graph)\n        model = JuMP.Model(optimizer)\n        states, uncertainty = subproblem_builder(model, t)\n        JuMP.@variable(model, cost_to_go >= lower_bound)\n        obj = JuMP.objective_function(model)\n        JuMP.@objective(model, Min, obj + cost_to_go)\n        if length(graph[t]) == 0\n            JuMP.fix(cost_to_go, 0.0; force = true)\n        end\n        push!(nodes, Node(model, states, uncertainty, cost_to_go))\n    end\n    return PolicyGraph(nodes, graph)\nend\n\nfunction sample_uncertainty(uncertainty::Uncertainty)\n    r = rand()\n    for (p, ω) in zip(uncertainty.P, uncertainty.Ω)\n        r -= p\n        if r < 0.0\n            return ω\n        end\n    end\n    return error(\"We should never get here because P should sum to 1.0.\")\nend\n\nfunction sample_next_node(model::PolicyGraph, current::Int)\n    if length(model.arcs[current]) == 0\n        return nothing\n    else\n        r = rand()\n        for (to, probability) in model.arcs[current]\n            r -= probability\n            if r < 0.0\n                return to\n            end\n        end\n        return nothing\n    end\nend\n\nfunction forward_pass(model::PolicyGraph, io::IO = stdout)\n    incoming_state =\n        Dict(k => JuMP.fix_value(v.in) for (k, v) in model.nodes[1].states)\n    simulation_cost = 0.0\n    trajectory = Tuple{Int,Dict{Symbol,Float64}}[]\n    t = 1\n    while t !== nothing\n        node = model.nodes[t]\n        ω = sample_uncertainty(node.uncertainty)\n        node.uncertainty.parameterize(ω)\n        for (k, v) in incoming_state\n            JuMP.fix(node.states[k].in, v; force = true)\n        end\n        JuMP.optimize!(node.subproblem)\n        if JuMP.termination_status(node.subproblem) != JuMP.MOI.OPTIMAL\n            error(\"Something went terribly wrong!\")\n        end\n        outgoing_state = Dict(k => JuMP.value(v.out) for (k, v) in node.states)\n        stage_cost =\n            JuMP.objective_value(node.subproblem) - JuMP.value(node.cost_to_go)\n        simulation_cost += stage_cost\n        incoming_state = outgoing_state\n        push!(trajectory, (t, outgoing_state))\n        t = sample_next_node(model, t)\n    end\n    return trajectory, simulation_cost\nend\n\nfunction upper_bound(model::PolicyGraph; replications::Int)\n    simulations = [forward_pass(model, devnull) for i in 1:replications]\n    z = [s[2] for s in simulations]\n    μ = Statistics.mean(z)\n    tσ = 1.96 * Statistics.std(z) / sqrt(replications)\n    return μ, tσ\nend\n\nfunction lower_bound(model::PolicyGraph)\n    node = model.nodes[1]\n    bound = 0.0\n    for (p, ω) in zip(node.uncertainty.P, node.uncertainty.Ω)\n        node.uncertainty.parameterize(ω)\n        JuMP.optimize!(node.subproblem)\n        bound += p * JuMP.objective_value(node.subproblem)\n    end\n    return bound\nend\n\nfunction evaluate_policy(\n    model::PolicyGraph;\n    node::Int,\n    incoming_state::Dict{Symbol,Float64},\n    random_variable,\n)\n    the_node = model.nodes[node]\n    the_node.uncertainty.parameterize(random_variable)\n    for (k, v) in incoming_state\n        JuMP.fix(the_node.states[k].in, v; force = true)\n    end\n    JuMP.optimize!(the_node.subproblem)\n    return Dict(\n        k => JuMP.value.(v) for\n        (k, v) in JuMP.object_dictionary(the_node.subproblem)\n    )\nend","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"</details></p>","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"First, we need to modify the backward pass to compute the cuts using the risk-averse subgradient theorem:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"function backward_pass(\n    model::PolicyGraph,\n    trajectory::Vector{Tuple{Int,Dict{Symbol,Float64}}},\n    io::IO = stdout;\n    risk_measure::AbstractRiskMeasure,\n)\n    println(io, \"| Backward pass\")\n    for i in reverse(1:length(trajectory))\n        index, outgoing_states = trajectory[i]\n        node = model.nodes[index]\n        println(io, \"| | Visiting node $(index)\")\n        if length(model.arcs[index]) == 0\n            continue\n        end\n        # =====================================================================\n        # New! Create vectors to store the cut expressions, V(x,ω) and p:\n        cut_expressions, V_ω, p = JuMP.AffExpr[], Float64[], Float64[]\n        # =====================================================================\n        for (j, P_ij) in model.arcs[index]\n            next_node = model.nodes[j]\n            for (k, v) in outgoing_states\n                JuMP.fix(next_node.states[k].in, v; force = true)\n            end\n            for (pφ, φ) in zip(next_node.uncertainty.P, next_node.uncertainty.Ω)\n                next_node.uncertainty.parameterize(φ)\n                JuMP.optimize!(next_node.subproblem)\n                V = JuMP.objective_value(next_node.subproblem)\n                dVdx = Dict(\n                    k => JuMP.reduced_cost(v.in) for (k, v) in next_node.states\n                )\n                # =============================================================\n                # New! Construct and append the expression\n                # `V_j^K(x_k, φ) + dVdx_j^K(x'_k, φ)ᵀ(x - x_k)` to the list of\n                # cut expressions.\n                push!(\n                    cut_expressions,\n                    JuMP.@expression(\n                        node.subproblem,\n                        V + sum(\n                            dVdx[k] * (x.out - outgoing_states[k]) for\n                            (k, x) in node.states\n                        ),\n                    )\n                )\n                # Add the objective value to Z:\n                push!(V_ω, V)\n                # Add the probability to p:\n                push!(p, P_ij * pφ)\n                # =============================================================\n            end\n        end\n        # =====================================================================\n        # New! Using the solutions in V_ω, compute q and α:\n        q, α = dual_risk_inner(risk_measure, V_ω, p)\n        println(io, \"| | | Z = \", Z)\n        println(io, \"| | | p = \", p)\n        println(io, \"| | | q = \", q)\n        println(io, \"| | | α = \", α)\n        # Then add the cut:\n        c = JuMP.@constraint(\n            node.subproblem,\n            node.cost_to_go >=\n            sum(q[i] * cut_expressions[i] for i in 1:length(q)) - α\n        )\n        # =====================================================================\n        println(io, \"| | | Adding cut : \", c)\n    end\n    return nothing\nend","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"We also need to update the train loop of SDDP to pass a risk measure to the backward pass:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"function train(\n    model::PolicyGraph;\n    iteration_limit::Int,\n    replications::Int,\n    # =========================================================================\n    # New! Add a risk_measure argument\n    risk_measure::AbstractRiskMeasure,\n    # =========================================================================\n    io::IO = stdout,\n)\n    for i in 1:iteration_limit\n        println(io, \"Starting iteration $(i)\")\n        outgoing_states, _ = forward_pass(model, io)\n        # =====================================================================\n        # New! Pass the risk measure to the backward pass.\n        backward_pass(model, outgoing_states, io; risk_measure = risk_measure)\n        # =====================================================================\n        println(io, \"| Finished iteration\")\n        println(io, \"| | lower_bound = \", lower_bound(model))\n    end\n    μ, tσ = upper_bound(model; replications = replications)\n    println(io, \"Upper bound = $(μ) ± $(tσ)\")\n    return\nend","category":"page"},{"location":"explanation/risk/#Risk-averse-bounds","page":"Risk aversion","title":"Risk-averse bounds","text":"","category":"section"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"warning: Warning\nThis section is important.","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"When we had a risk-neutral policy (i.e., we only used the expectation risk measure), we discussed how we could form valid lower and upper bounds.","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"The upper bound is still valid as a Monte Carlo simulation of the expected cost of the policy. (Although this upper bound doesn't capture the change in the policy we wanted to achieve, namely that the impact of the worst outcomes were reduced.)","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"However, if we use a different risk measure, the lower bound is no longer valid!","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"We can still calculate a \"lower bound\" as the objective of the first-stage approximated subproblem, and this will converge to a finite value. However, we can't meaningfully interpret it as a bound with respect to the optimal policy. Therefore, it's best to just ignore the lower bound when training a risk-averse policy.","category":"page"},{"location":"explanation/risk/#Example:-risk-averse-hydro-thermal-scheduling","page":"Risk aversion","title":"Example: risk-averse hydro-thermal scheduling","text":"","category":"section"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"Now it's time for an example. We create the same problem as Introductory theory:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"model = PolicyGraph(\n    graph = [Dict(2 => 1.0), Dict(3 => 1.0), Dict{Int,Float64}()],\n    lower_bound = 0.0,\n    optimizer = HiGHS.Optimizer,\n) do subproblem, t\n    JuMP.set_silent(subproblem)\n    JuMP.@variable(subproblem, volume_in == 200)\n    JuMP.@variable(subproblem, 0 <= volume_out <= 200)\n    states = Dict(:volume => State(volume_in, volume_out))\n    JuMP.@variables(subproblem, begin\n        thermal_generation >= 0\n        hydro_generation >= 0\n        hydro_spill >= 0\n        inflow\n    end)\n    JuMP.@constraints(\n        subproblem,\n        begin\n            volume_out == volume_in + inflow - hydro_generation - hydro_spill\n            demand_constraint, thermal_generation + hydro_generation == 150.0\n        end\n    )\n    fuel_cost = [50.0, 100.0, 150.0]\n    JuMP.@objective(subproblem, Min, fuel_cost[t] * thermal_generation)\n    uncertainty =\n        Uncertainty([0.0, 50.0, 100.0], [1 / 3, 1 / 3, 1 / 3]) do ω\n            return JuMP.fix(inflow, ω)\n        end\n    return states, uncertainty\nend","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"Then we train a risk-averse policy, passing a risk measure to train:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"train(\n    model;\n    iteration_limit = 3,\n    replications = 100,\n    risk_measure = Entropic(1.0),\n)","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"Finally, evaluate the decision rule:","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"evaluate_policy(\n    model;\n    node = 1,\n    incoming_state = Dict(:volume => 150.0),\n    random_variable = 75,\n)","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"info: Info\nFor this trivial example, the risk-averse policy isn't very different from the policy obtained using the expectation risk-measure. If you try it on some bigger/more interesting problems, you should see the expected cost increase, and the upper tail of the policy decrease.","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"","category":"page"},{"location":"explanation/risk/","page":"Risk aversion","title":"Risk aversion","text":"This page was generated using Literate.jl.","category":"page"}]
}
