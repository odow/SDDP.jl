<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial Three: objective noise · SDDP.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SDDP.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="01_first_steps.html">Tutorial One: first steps</a></li><li><a class="toctext" href="02_rhs_noise.html">Tutorial Two: RHS noise</a></li><li class="current"><a class="toctext" href="03_objective_noise.html">Tutorial Three: objective noise</a><ul class="internal"><li><a class="toctext" href="#Formulating-the-problem-1">Formulating the problem</a></li><li><a class="toctext" href="#Solving-the-problem-1">Solving the problem</a></li><li><a class="toctext" href="#Understanding-the-solution-1">Understanding the solution</a></li></ul></li><li><a class="toctext" href="04_markovian_policygraphs.html">Tutorial Four: Markovian policy graphs</a></li><li><a class="toctext" href="05_risk.html">Tutorial Five: risk</a></li><li><a class="toctext" href="06_cut_selection.html">Tutorial Six: cut selection</a></li><li><a class="toctext" href="07_plotting.html">Tutorial Seven: plotting</a></li><li><a class="toctext" href="08_odds_and_ends.html">Tutorial Eight: odds and ends</a></li><li><a class="toctext" href="09_nonlinear.html">Tutorial Nine: nonlinear models</a></li><li><a class="toctext" href="10_parallel.html">Tutorial Ten: parallelism</a></li><li><a class="toctext" href="11_DRO.html">Tutorial Eleven: distributionally robust SDDP</a></li><li><a class="toctext" href="12_price_interpolation.html">Tutorial Twelve: price interpolation</a></li><li><a class="toctext" href="13_constraint_noise.html">Tutorial Thirteen: constraint noise</a></li></ul></li><li><a class="toctext" href="../readings.html">Readings</a></li><li><a class="toctext" href="../apireference.html">Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li>Tutorials</li><li><a href="03_objective_noise.html">Tutorial Three: objective noise</a></li></ul><a class="edit-page" href="https://github.com/odow/SDDP.jl/blob/master/docs/src/tutorial/03_objective_noise.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tutorial Three: objective noise</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Tutorial-Three:-objective-noise-1" href="#Tutorial-Three:-objective-noise-1">Tutorial Three: objective noise</a></h1><p>In <a href="01_first_steps.html#Tutorial-One:-first-steps-1">Tutorial One: first steps</a>, we formulated a simple, deterministic hydrothermal scheduling problem. Then, <a href="02_rhs_noise.html#Tutorial-Two:-RHS-noise-1">Tutorial Two: RHS noise</a>, we extended this model to include stagewise-independent noise to the right-hand side of a constraint. Now, in this tutorial, we extend the model to include stagewise-independent noise in the objective function.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Notably, SDDP.jl does not allow stagewise-independent noise terms in the constraint matrix. However, this can be modelled using a Markovian policy graph like the one in <a href="04_markovian_policygraphs.html#Tutorial-Four:-Markovian-policy-graphs-1">Tutorial Four: Markovian policy graphs</a>.</p></div></div><p>Recall that our model for the hydrothermal scheduling problem  from <a href="02_rhs_noise.html#Tutorial-Two:-RHS-noise-1">Tutorial Two: RHS noise</a> is:</p><pre><code class="language-julia">m = SDDPModel(
                  sense = :Min,
                 stages = 3,
                 solver = ClpSolver(),
        objective_bound = 0.0
                                        ) do sp, t
    @state(sp, 0 &lt;= outgoing_volume &lt;= 200, incoming_volume == 200)
    @variables(sp, begin
        thermal_generation &gt;= 0
        hydro_generation   &gt;= 0
        hydro_spill        &gt;= 0
    end)
    @rhsnoise(sp, inflow = [0.0, 50.0, 100.0],
        outgoing_volume - (incoming_volume - hydro_generation - hydro_spill) == inflow
    )
    setnoiseprobability!(sp, [1/3, 1/3, 1/3])
    @constraints(sp, begin
        thermal_generation + hydro_generation == 150
    end)
    fuel_cost = [50.0, 100.0, 150.0]
    @stageobjective(sp, fuel_cost[t] * thermal_generation )
end</code></pre><h2><a class="nav-anchor" id="Formulating-the-problem-1" href="#Formulating-the-problem-1">Formulating the problem</a></h2><p>In this tutorial, we are going to model the fuel cost of the thermal generator by a stagewise-independent process. Specifically, we assume that in each stage, there is an even probability of sampling a fuel cost of 80%, 100%, or 120% of the usual fuel costs of \$50/MWh in the first stage, \$100/MWh in the second stage, and \$150/MWh in the third stage. To add this noise term to the model, we need to use a modified version of the <a href="../apireference.html#SDDP.@stageobjective"><code>@stageobjective</code></a> macro provided by SDDP.jl.</p><p>This version of <a href="../apireference.html#SDDP.@stageobjective"><code>@stageobjective</code></a> is similar to the <a href="../apireference.html#SDDP.@rhsnoise"><code>@rhsnoise</code></a> macro that we discussed in <a href="02_rhs_noise.html#Tutorial-Two:-RHS-noise-1">Tutorial Two: RHS noise</a>. It takes three arguments. The first is the subproblem <code>sp</code>. The second argument is of the form <code>name=[realizations]</code>, where <code>name</code> is a descriptive name, and <code>realizations</code> is a vector of elements in the sample space. The third argument is any valid input to the normal <code>@stageobjective</code> macro.</p><p>It is important to note that there must be the same number of realizations in the objective as there are realizations in the right-hand-side random variable (created using <code>@rhsnoise</code>). The two noise terms will be sampled in unison, so that when the first element of the right-hand side noise is sampled, so to will the first element of the objective noise. If the two noise terms should be sampled independently, the user should form the Cartesian product.</p><p>For our example, the price multiplier and the inflows are negatively correlated. Therefore, when <code>inflow=0.0</code>, the multiplier is <code>1.2</code>, when <code>inflow=50.0</code>, the multiplier is <code>1.0</code>, and when <code>inflow=100.0</code>, the multiplier is <code>0.8</code>. Thus, we have:</p><pre><code class="language-julia">fuel_cost = [50.0, 100.0, 150.0]
@stageobjective(sp, mupliplier = [1.2, 1.0, 0.8],
    mupliplier * fuel_cost[t] * thermal_generation
)</code></pre><p>As in <a href="02_rhs_noise.html#Tutorial-Two:-RHS-noise-1">Tutorial Two: RHS noise</a>, the noise terms are sampled using the probability distribution set by the <a href="../apireference.html#SDDP.setnoiseprobability!"><code>setnoiseprobability!</code></a> function.</p><p>Our model is now:</p><pre><code class="language-julia">m = SDDPModel(
                  sense = :Min,
                 stages = 3,
                 solver = ClpSolver(),
        objective_bound = 0.0
                                        ) do sp, t
    @state(sp, 0 &lt;= outgoing_volume &lt;= 200, incoming_volume == 200)
    @variables(sp, begin
        thermal_generation &gt;= 0
        hydro_generation   &gt;= 0
        hydro_spill        &gt;= 0
    end)
    @rhsnoise(sp, inflow = [0.0, 50.0, 100.0],
        outgoing_volume - (incoming_volume - hydro_generation - hydro_spill) == inflow
    )
    setnoiseprobability!(sp, [1/3, 1/3, 1/3])
    @constraints(sp, begin
        thermal_generation + hydro_generation == 150
    end)
    fuel_cost = [50.0, 100.0, 150.0]
    @stageobjective(sp, mupliplier = [1.2, 1.0, 0.8],
        mupliplier * fuel_cost[t] * thermal_generation
    )
end</code></pre><h2><a class="nav-anchor" id="Solving-the-problem-1" href="#Solving-the-problem-1">Solving the problem</a></h2><p>Now we need to solve the problem. As in the previous two tutorials, we use the <a href="../apireference.html#JuMP.solve"><code>solve</code></a> function. However, this time we use the bound stalling stopping rule. This can be controlled via the <code>bound_stalling</code> keyword to <a href="../apireference.html#JuMP.solve"><code>solve</code></a>. The syntax has a lot going on so we&#39;re going to give an example of how it is used, and then walk through the different components.</p><pre><code class="language-julia">status = solve(m,
    bound_stalling = BoundStalling(
        iterations = 5,
        rtol       = 0.0,
        atol       = 1e-6
    )
)</code></pre><p>First, the <code>iterations</code> argument specifies how many iterations that the bound must change by less than <code>atol</code> or <code>rtol</code> before terminating. For this example, we choose to terminate the SDDP algorithm after the bound has failed to improve for <code>5</code> iterations. Second, the <code>rtol</code> and <code>atol</code> keywords determine the absolute and relative tolerances by which we compare the equality of the bound in consecutive iterations. In this case, since the model is simple we choose an absolute convergence tolerance of <code>1e-6</code>.</p><p>The termination status is <code>:bound_stalling</code>, and the output from the log is now:</p><pre><code class="language-none">-------------------------------------------------------------------------------
                          SDDP.jl © Oscar Dowson, 2017-2018
-------------------------------------------------------------------------------
    Solver:
        Serial solver
    Model:
        Stages:         3
        States:         1
        Subproblems:    3
        Value Function: Default
-------------------------------------------------------------------------------
              Objective              |  Cut  Passes    Simulations   Total
     Simulation       Bound   % Gap  |   #     Time     #    Time    Time
-------------------------------------------------------------------------------
        7.500K         5.733K        |     1    0.0      0    0.0    0.0
       11.800K         8.889K        |     2    0.0      0    0.0    0.0
       14.000K         9.167K        |     3    0.0      0    0.0    0.0
       11.000K         9.167K        |     4    0.0      0    0.0    0.0
        9.000K         9.167K        |     5    0.0      0    0.0    0.0
        2.000K         9.167K        |     6    0.0      0    0.0    0.0
       14.000K         9.167K        |     7    0.0      0    0.0    0.0
-------------------------------------------------------------------------------
    Other Statistics:
        Iterations:         7
        Termination Status: bound_stalling
===============================================================================</code></pre><h2><a class="nav-anchor" id="Understanding-the-solution-1" href="#Understanding-the-solution-1">Understanding the solution</a></h2><p>Instead of performing a Monte Carlo simulation, you may want to simulate one particular sequence of noise realizations. This <em>historical</em> simulation can also be conducted using the <a href="../apireference.html#SDDP.simulate"><code>simulate</code></a> function.</p><pre><code class="language-julia">simulation_result = simulate(m,
    [:outgoing_volume, :thermal_generation, :hydro_generation, :hydro_spill],
    noises = [1, 1, 3]
)</code></pre><p>This time, <code>simulation_result</code> is a single dictionary. We can query the objective of the simulation as follows:</p><pre><code class="language-julia">julia&gt; simulation_result[:objective]
9000.0</code></pre><p>Interestingly, despite sampling the low-inflow, high-price realization in the first stage, the model generates 150 MWh at a price of \$60/MWh:</p><pre><code class="language-julia">julia&gt; simulation_result[:thermal_generation]
3-element Array{Any, 1}:
 150.0
   0.0
   0.0</code></pre><p>This concludes our third tutorial for SDDP.jl. In the next tutorial, <a href="04_markovian_policygraphs.html#Tutorial-Four:-Markovian-policy-graphs-1">Tutorial Four: Markovian policy graphs</a>, we introduce stagewise-dependent noise via a Markov chain.</p><footer><hr/><a class="previous" href="02_rhs_noise.html"><span class="direction">Previous</span><span class="title">Tutorial Two: RHS noise</span></a><a class="next" href="04_markovian_policygraphs.html"><span class="direction">Next</span><span class="title">Tutorial Four: Markovian policy graphs</span></a></footer></article></body></html>
