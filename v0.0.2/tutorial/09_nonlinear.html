<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial Nine: nonlinear models · SDDP.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SDDP.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="01_first_steps.html">Tutorial One: first steps</a></li><li><a class="toctext" href="02_rhs_noise.html">Tutorial Two: RHS noise</a></li><li><a class="toctext" href="03_objective_noise.html">Tutorial Three: objective noise</a></li><li><a class="toctext" href="04_markovian_policygraphs.html">Tutorial Four: Markovian policy graphs</a></li><li><a class="toctext" href="05_risk.html">Tutorial Five: risk</a></li><li><a class="toctext" href="06_cut_selection.html">Tutorial Six: cut selection</a></li><li><a class="toctext" href="07_plotting.html">Tutorial Seven: plotting</a></li><li><a class="toctext" href="08_odds_and_ends.html">Tutorial Eight: odds and ends</a></li><li class="current"><a class="toctext" href="09_nonlinear.html">Tutorial Nine: nonlinear models</a><ul class="internal"></ul></li><li><a class="toctext" href="10_parallel.html">Tutorial Ten: parallelism</a></li><li><a class="toctext" href="11_DRO.html">Tutorial Eleven: distributionally robust SDDP</a></li><li><a class="toctext" href="12_price_interpolation.html">Tutorial Twelve: price interpolation</a></li><li><a class="toctext" href="13_constraint_noise.html">Tutorial Thirteen: constraint noise</a></li></ul></li><li><a class="toctext" href="../readings.html">Readings</a></li><li><a class="toctext" href="../apireference.html">Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li>Tutorials</li><li><a href="09_nonlinear.html">Tutorial Nine: nonlinear models</a></li></ul><a class="edit-page" href="https://github.com/odow/SDDP.jl/blob/master/docs/src/tutorial/09_nonlinear.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tutorial Nine: nonlinear models</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Tutorial-Nine:-nonlinear-models-1" href="#Tutorial-Nine:-nonlinear-models-1">Tutorial Nine: nonlinear models</a></h1><p>In our previous tutorials, we formulated a linear version of the hydrothermal scheduling problem. To do so, we had to make a large assumption, namely, that the inflows were <em>stagewise-independent</em>. In <a href="04_markovian_policygraphs.html#Tutorial-Four:-Markovian-policy-graphs-1">Tutorial Four: Markovian policy graphs</a>, we improved upon this slightly using a Markov chain with persistent <em>climate</em> states. However, another commonly used model is to assume that the inflows follow a log auto-regressive process. In this tutorial, we explain how to implement this in SDDP.jl.</p><p>As a starting point, we use a model that is very similar to the hydrothermal scheduling problem we formulated in <a href="02_rhs_noise.html#Tutorial-Two:-RHS-noise-1">Tutorial Two: RHS noise</a>. In that model, we assumed that there the a constraint:</p><pre><code class="language-julia">@rhsnoise(sp, inflow = [0.0, 50.0, 100.0],
    outgoing_volume - (incoming_volume - hydro_generation - hydro_spill) == inflow
)</code></pre><p>We assumed that the <code>inflow</code> term was <em>stagewise-independent</em>. In this tutorial, we assume that the inflow term can be modelled like:</p><pre><code class="language-none">log(inflow[t]) = log(inflow[t-1]) + log(noise),</code></pre><p>where <code>noise</code> is drawn from <code>[0.9, 1.0, 1.1]</code> with uniform probability. Since we value of the inflow in the previous stage affects the value in the current stage, it needs to be added as a state variable:</p><pre><code class="language-julia">@state(sp, current_inflow &gt;= 1, previous_inflow == 50)</code></pre><p>Note that we place a small, positive lower bound on the <code>current_inflow</code> to prevent the solver calling the undefined <code>log(0.0)</code>.</p><p>Now we want to add the log transition constraint. We can do this using JuMP&#39;s <code>@NLconstraint</code> macro to add this constraint. However, SDDP.jl only supports noise terms in the right hand-side of a linear constraint. We can overcome this limitation by introducing a dummy variable (note that it also has a small, positive lower bound to avoid <code>log(0.0)</code>):</p><pre><code class="language-julia">@variable(sp, noise &gt;= 0.1)
@rhsnoise(sp, ω = [0.9, 1.0, 1.1], noise == ω)
@NLconstraint(sp, log(current_inflow) == log(previous_inflow) + log(noise))</code></pre><p>Finally, we&#39;re using JuMP&#39;s nonlinear functionality, we need to choose an appropriate solver. We choose to use the COIN solver <a href="https://github.com/JuliaOpt/Ippopt.jl">Ipopt</a>. Therefore, our final model is:</p><pre><code class="language-julia">using JuMP, SDDP, Ipopt
m = SDDPModel(
    stages          = 3,
    sense           = :Min,
    solver          = IpoptSolver(print_level=0),
    objective_bound = 0.0
                ) do sp, t
    @states(sp, begin
        200 &gt;= outgoing_volume &gt;= 0, incoming_volume == 200
               current_inflow  &gt;= 1, previous_inflow ==  50
    end)
    @variables(sp, begin
        thermal_generation &gt;= 0
        hydro_generation   &gt;= 0
        hydro_spill        &gt;= 0
        inflow_noise_term  &gt;= 0.1
    end)
    @constraints(sp, begin
        outgoing_volume - (incoming_volume - hydro_generation - hydro_spill) == current_inflow
        hydro_generation + thermal_generation &gt;= 150.0
    end)

    @rhsnoise(sp, ω = [0.9, 1.0, 1.1], inflow_noise_term == ω)
    @NLconstraint(sp, log(current_inflow) == log(previous_inflow) + log(inflow_noise_term))

    fuel_cost = [50.0, 100.0, 150.0]
    @stageobjective(sp, fuel_cost[t] * thermal_generation )
end</code></pre><p>This problem can be solved just like any other SDDP model:</p><pre><code class="language-julia">status = solve(m, iteration_limit = 10)
simulation_result = simulate(m, 1, [:inflow′])</code></pre><p>Then, we can check that the inflows do indeed follow a log auto-regressive process.</p><pre><code class="language-julia">julia&gt; simulaton_result[1][:inflow′]
 55.0
 60.5
 54.45</code></pre><p>That concludes our ninth tutorial for SDDP.jl. In our next tutorial, <a href="10_parallel.html#Tutorial-Ten:-parallelism-1">Tutorial Ten: parallelism</a>, we explain how to solve SDDP models in parallel.</p><footer><hr/><a class="previous" href="08_odds_and_ends.html"><span class="direction">Previous</span><span class="title">Tutorial Eight: odds and ends</span></a><a class="next" href="10_parallel.html"><span class="direction">Next</span><span class="title">Tutorial Ten: parallelism</span></a></footer></article></body></html>
